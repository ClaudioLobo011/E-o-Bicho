<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Admin: Entrada de NF-e - E o Bicho</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
  <link rel="stylesheet" href="../../src/output.css">
</head>
<body class="bg-gray-100">
  <div id="admin-header-placeholder"></div>

  <main class="container mx-auto px-4 pt-1 pb-8 min-h-screen">
    <div class="grid grid-cols-1 md:grid-cols-4 gap-8">
      <aside class="md:col-span-4">
        <div id="admin-sidebar-placeholder"></div>
      </aside>

      <div class="md:col-span-4 space-y-6">
        <header class="bg-white rounded-xl shadow-sm border border-gray-100 p-6 flex flex-col gap-3 md:flex-row md:items-center md:justify-between">
          <div class="space-y-2">
            <div class="flex items-center gap-2 text-sm text-gray-500">
              <span class="inline-flex items-center gap-1 rounded-full bg-primary/10 px-2.5 py-0.5 text-[11px] font-semibold uppercase tracking-wide text-primary">
                <i class="fas fa-shopping-basket"></i>
                Compras
              </span>
              <i class="fas fa-angle-right text-xs"></i>
              <span class="font-medium text-gray-600">Fornecedores</span>
              <i class="fas fa-angle-right text-xs"></i>
              <span class="font-semibold text-gray-800">Entrada de NF-e</span>
            </div>
            <div>
              <h1 class="text-2xl font-bold text-gray-800">Entrada de NF-e</h1>
              <p class="text-sm text-gray-600">Cadastre entradas modelo 55 com dados exigidos pelo Manual de Orientação do Contribuinte 4.0 e notas técnicas vigentes para NFC-e, NF-e e NFSe.</p>
            </div>
          </div>
        </header>

        <section class="bg-white rounded-xl shadow-sm border border-gray-100 p-6 space-y-6">
          <div class="flex flex-col gap-2 md:flex-row md:items-start md:justify-between">
            <div>
              <h2 class="text-lg font-semibold text-gray-800">Cabeçalho da Nota</h2>
              <p class="text-sm text-gray-500">Preencha o identificador da nota, dados do fornecedor e referência numérica conforme layout nacional da NF-e/NFC-e.</p>
            </div>
            <div class="rounded-lg border border-emerald-100 bg-emerald-50 px-4 py-2 text-right">
              <span class="text-xs font-medium text-emerald-700 block">Total da Nota</span>
              <span class="text-xl font-bold text-emerald-900" data-nfe-total>R$ 0,00</span>
              <p class="text-[11px] text-emerald-700">Somatório automático dos itens</p>
            </div>
          </div>

          <div class="grid grid-cols-1 md:grid-cols-[160px_150px_150px_120px_minmax(0,1fr)] gap-4">
            <div>
              <label for="nfe-code" class="block text-sm font-medium text-gray-700 mb-1">Código</label>
              <input
                type="text"
                id="nfe-code"
                class="w-full max-w-[160px] rounded-lg border border-gray-200 bg-gray-50 px-3 py-2 text-sm text-gray-500 cursor-pointer"
                readonly
              >
              <div class="mt-2 flex items-center gap-2">
                <span class="text-[10px] font-semibold uppercase tracking-wide text-gray-500">Status</span>
                <span
                  data-nfe-status-badge
                  class="inline-flex items-center gap-1 rounded-full border px-2 py-0.5 text-[10px] font-semibold uppercase tracking-wide text-gray-600"
                >
                  Cadastrada
                </span>
              </div>
            </div>
            <div>
              <label for="nfe-number" class="block text-sm font-medium text-gray-700 mb-1">NF* (número da nota)</label>
              <input type="text" id="nfe-number" class="w-full max-w-[150px] rounded-lg border border-gray-200 px-3 py-2 text-sm focus:border-primary focus:ring-2 focus:ring-primary/20" placeholder="10245" maxlength="8" required>
            </div>
            <div>
              <label for="nfe-type" class="block text-sm font-medium text-gray-700 mb-1">Tipo</label>
              <select id="nfe-type" class="w-full max-w-[150px] rounded-lg border border-gray-200 px-3 py-2 text-sm focus:border-primary focus:ring-2 focus:ring-primary/20">
                <option value="NF" selected>NF</option>
                <option value="RECIBO">Recibo</option>
              </select>
            </div>
            <div>
              <label for="nfe-series" class="block text-sm font-medium text-gray-700 mb-1">Série</label>
              <input type="text" id="nfe-series" class="w-full max-w-[120px] rounded-lg border border-gray-200 px-3 py-2 text-sm focus:border-primary focus:ring-2 focus:ring-primary/20" placeholder="1">
            </div>
            <div>
              <label for="nfe-supplier" class="block text-sm font-medium text-gray-700 mb-1">Fornecedor*</label>
              <select id="nfe-supplier" class="w-full rounded-lg border border-gray-200 px-3 py-2 text-sm focus:border-primary focus:ring-2 focus:ring-primary/20" required>
                <option value="">Selecione o fornecedor</option>
                <option value="30090856000160">30290856000160 - Distribuidora Nacional de Produtos Veterinários Ltda</option>
                <option value="06117473000150">06117473000150 - MSD Saúde Animal Comércio de Produtos Veterinários Ltda</option>
                <option value="07404231000110">07404231000110 - Ourofino Saúde Animal Ltda</option>
              </select>
            </div>
          </div>
        </section>

        <section class="bg-white rounded-xl shadow-sm border border-gray-100">
          <nav class="flex flex-wrap gap-2 border-b border-gray-100 px-6 pt-6">
            <button type="button" class="tab-button active" data-tab="dados">Dados da Nota</button>
            <button type="button" class="tab-button" data-tab="totais">Totais da Nota</button>
            <button type="button" class="tab-button" data-tab="observacoes">Obs / Outras Informações</button>
            <button type="button" class="tab-button" data-tab="produtos">Produtos</button>
            <button type="button" class="tab-button" data-tab="transportadora">Transportadora</button>
            <button type="button" class="tab-button" data-tab="duplicatas">Duplicatas</button>
            <button type="button" class="tab-button" data-tab="documentos">Documentos Vinculados</button>
          </nav>

          <div class="p-6 space-y-6">
            <div class="tab-panel" data-tab-panel="dados">
              <div class="flex flex-wrap items-center justify-between gap-3 mb-4">
                <div>
                  <h3 class="text-sm font-semibold text-gray-700">Ações principais</h3>
                  <p class="text-xs text-gray-500">Gerencie a nota importando XML, visualizando lotes ou ajustando preços e pedidos.</p>
                </div>
                <div class="grid grid-cols-2 md:grid-cols-4 gap-2">
                  <button type="button" data-open-import-modal class="inline-flex items-center justify-center gap-2 rounded-lg border border-gray-200 px-3 py-2 text-xs font-semibold text-gray-600 hover:bg-gray-50 transition">
                    <i class="fas fa-file-import"></i>
                    Importar XML
                  </button>
                  <button type="button" class="inline-flex items-center justify-center gap-2 rounded-lg border border-gray-200 px-3 py-2 text-xs font-semibold text-gray-600 hover:bg-gray-50 transition">
                    <i class="fas fa-eye"></i>
                    Visualizar Lotes
                  </button>
                  <button
                    type="button"
                    data-open-price-modal
                    class="inline-flex items-center justify-center gap-2 rounded-lg border border-gray-200 px-3 py-2 text-xs font-semibold text-gray-400 transition opacity-60 cursor-not-allowed"
                    disabled
                  >
                    <i class="fas fa-tags"></i>
                    Alterar Preços
                  </button>
                  <button type="button" class="inline-flex items-center justify-center gap-2 rounded-lg border border-gray-200 px-3 py-2 text-xs font-semibold text-gray-600 hover:bg-gray-50 transition">
                    <i class="fas fa-clipboard-list"></i>
                    Pedidos
                  </button>
                </div>
              </div>

              <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                  <label for="issue-date" class="block text-sm font-medium text-gray-700 mb-1">Data Emissão*</label>
                  <input type="date" id="issue-date" class="w-full rounded-lg border border-gray-200 px-3 py-2 text-sm focus:border-primary focus:ring-2 focus:ring-primary/20" required>
                </div>
                <div>
                  <label for="company" class="block text-sm font-medium text-gray-700 mb-1">Empresa*</label>
                  <select id="company" class="w-full rounded-lg border border-gray-200 px-3 py-2 text-sm focus:border-primary focus:ring-2 focus:ring-primary/20" required disabled>
                    <option value="">Carregando empresas...</option>
                  </select>
                </div>
                <div>
                  <label for="nfe-model" class="block text-sm font-medium text-gray-700 mb-1">Modelo da Nota Fiscal*</label>
                  <select id="nfe-model" class="w-full rounded-lg border border-gray-200 px-3 py-2 text-sm focus:border-primary focus:ring-2 focus:ring-primary/20" required>
                    <option value="55" selected>55 – Nota Fiscal Eletrônica (NF-e)</option>
                    <option value="65">65 – Nota Fiscal de Consumidor Eletrônica (NFC-e)</option>
                    <option value="57">57 – Conhecimento de Transporte Eletrônico (CT-e)</option>
                    <option value="nfs-e">NFS-e – Nota Fiscal de Serviços Eletrônica</option>
                  </select>
                </div>
                <div>
                  <label for="access-key" class="block text-sm font-medium text-gray-700 mb-1">Chave da NFe (44 dígitos)</label>
                  <input type="text" id="access-key" maxlength="44" class="w-full rounded-lg border border-gray-200 px-3 py-2 text-sm focus:border-primary focus:ring-2 focus:ring-primary/20" placeholder="35240730290856000160550010000100011999999999">
                  <p class="mt-1 text-xs text-gray-500">Composição: cUF + AAMM + CNPJ + modelo + série + número + tpEmis + cNF + DV.</p>
                </div>
                <div>
                  <label for="entry-date" class="block text-sm font-medium text-gray-700 mb-1">Data Entrada*</label>
                  <input type="date" id="entry-date" class="w-full rounded-lg border border-gray-200 px-3 py-2 text-sm focus:border-primary focus:ring-2 focus:ring-primary/20" required>
                </div>
                <div>
                  <label for="deposit" class="block text-sm font-medium text-gray-700 mb-1">Depósito*</label>
                  <select id="deposit" class="w-full rounded-lg border border-gray-200 px-3 py-2 text-sm focus:border-primary focus:ring-2 focus:ring-primary/20" required disabled>
                    <option value="">Selecione uma empresa para listar os depósitos</option>
                  </select>
                </div>
                <div>
                  <label for="entry-type" class="block text-sm font-medium text-gray-700 mb-1">Tipo de Entrada*</label>
                  <select id="entry-type" class="w-full rounded-lg border border-gray-200 px-3 py-2 text-sm focus:border-primary focus:ring-2 focus:ring-primary/20" required>
                    <option value="">Selecione</option>
                    <option value="revenda">Compra para Revenda</option>
                    <option value="industrializacao">Industrialização</option>
                    <option value="consumo">Uso e Consumo</option>
                    <option value="imobilizado">Ativo Imobilizado</option>
                  </select>
                </div>
              </div>

              <div class="mt-6 border-t border-gray-100 pt-6">
                <h3 class="text-sm font-semibold text-gray-700 mb-4">Dados do Fornecedor</h3>
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
                  <div>
                    <label for="supplier-cnpj" class="block text-sm font-medium text-gray-700 mb-1">CNPJ / CPF</label>
                    <input type="text" id="supplier-cnpj" class="w-full rounded-lg border border-gray-200 px-3 py-2 text-sm focus:border-primary focus:ring-2 focus:ring-primary/20" placeholder="30.290.856/0001-60">
                  </div>
                  <div>
                    <label for="supplier-ie" class="block text-sm font-medium text-gray-700 mb-1">Inscrição Estadual</label>
                    <input type="text" id="supplier-ie" class="w-full rounded-lg border border-gray-200 px-3 py-2 text-sm focus:border-primary focus:ring-2 focus:ring-primary/20" placeholder="244/0178792">
                  </div>
                  <div>
                    <label for="supplier-uf" class="block text-sm font-medium text-gray-700 mb-1">UF</label>
                    <select id="supplier-uf" class="w-full rounded-lg border border-gray-200 px-3 py-2 text-sm focus:border-primary focus:ring-2 focus:ring-primary/20">
                      <option value="">Selecione</option>
                      <option value="SP">SP - São Paulo</option>
                      <option value="RJ">RJ - Rio de Janeiro</option>
                      <option value="MG">MG - Minas Gerais</option>
                      <option value="RS">RS - Rio Grande do Sul</option>
                      <option value="PR">PR - Paraná</option>
                      <option value="SC">SC - Santa Catarina</option>
                      <option value="BA">BA - Bahia</option>
                      <option value="PE">PE - Pernambuco</option>
                      <option value="CE">CE - Ceará</option>
                      <option value="DF">DF - Distrito Federal</option>
                    </select>
                  </div>
                  <div>
                    <label for="supplier-email" class="block text-sm font-medium text-gray-700 mb-1">E-mail fiscal</label>
                    <input type="email" id="supplier-email" class="w-full rounded-lg border border-gray-200 px-3 py-2 text-sm focus:border-primary focus:ring-2 focus:ring-primary/20" placeholder="nfe@distribuidora.com.br">
                  </div>
                  <div class="md:col-span-2 lg:col-span-4">
                    <label for="supplier-address" class="block text-sm font-medium text-gray-700 mb-1">Endereço completo</label>
                    <input type="text" id="supplier-address" class="w-full rounded-lg border border-gray-200 px-3 py-2 text-sm focus:border-primary focus:ring-2 focus:ring-primary/20" placeholder="Av. Paulista, 1800 - Bela Vista, São Paulo - SP, 01310-200">
                  </div>
                </div>
              </div>
            </div>

            <div class="tab-panel hidden" data-tab-panel="totais">
              <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                <div class="space-y-4">
                  <div>
                    <label for="valor-produtos" class="block text-sm font-medium text-gray-700 mb-1">Valor Produtos (R$)</label>
                    <input type="number" step="0.01" id="valor-produtos" class="w-full rounded-lg border border-gray-200 px-3 py-2 text-sm focus:border-primary focus:ring-2 focus:ring-primary/20" placeholder="14000.00">
                  </div>
                  <div>
                    <label for="valor-bonificacao" class="block text-sm font-medium text-gray-700 mb-1">Valor Bonificação (R$)</label>
                    <input
                      type="number"
                      step="0.01"
                      id="valor-bonificacao"
                      class="w-full rounded-lg border border-gray-200 px-3 py-2 text-sm focus:border-primary focus:ring-2 focus:ring-primary/20"
                      placeholder="0.00"
                      readonly
                    >
                  </div>
                  <div>
                    <label for="base-icms" class="block text-sm font-medium text-gray-700 mb-1">Base ICMS (R$)</label>
                    <input type="number" step="0.01" id="base-icms" class="w-full rounded-lg border border-gray-200 px-3 py-2 text-sm focus:border-primary focus:ring-2 focus:ring-primary/20">
                  </div>
                  <div>
                    <label for="valor-icms" class="block text-sm font-medium text-gray-700 mb-1">Valor ICMS (R$)</label>
                    <input type="number" step="0.01" id="valor-icms" class="w-full rounded-lg border border-gray-200 px-3 py-2 text-sm focus:border-primary focus:ring-2 focus:ring-primary/20">
                  </div>
                  <div>
                    <label for="icms-st" class="block text-sm font-medium text-gray-700 mb-1">ICMS Subst. (R$)</label>
                    <input type="number" step="0.01" id="icms-st" class="w-full rounded-lg border border-gray-200 px-3 py-2 text-sm focus:border-primary focus:ring-2 focus:ring-primary/20">
                  </div>
                  <div>
                    <label for="valor-fcp-st" class="block text-sm font-medium text-gray-700 mb-1">Valor FCP ST (R$)</label>
                    <input type="number" step="0.01" id="valor-fcp-st" class="w-full rounded-lg border border-gray-200 px-3 py-2 text-sm focus:border-primary focus:ring-2 focus:ring-primary/20">
                  </div>
                </div>

                <div class="space-y-4">
                  <div>
                    <label for="desconto" class="block text-sm font-medium text-gray-700 mb-1">Desconto (R$)</label>
                    <input type="number" step="0.01" id="desconto" class="w-full rounded-lg border border-gray-200 px-3 py-2 text-sm focus:border-primary focus:ring-2 focus:ring-primary/20">
                  </div>
                  <div>
                    <label for="outras-despesas" class="block text-sm font-medium text-gray-700 mb-1">Outras Despesas (R$)</label>
                    <input type="number" step="0.01" id="outras-despesas" class="w-full rounded-lg border border-gray-200 px-3 py-2 text-sm focus:border-primary focus:ring-2 focus:ring-primary/20">
                  </div>
                  <div>
                    <label for="valor-frete" class="block text-sm font-medium text-gray-700 mb-1">Valor Frete (R$)</label>
                    <input type="number" step="0.01" id="valor-frete" class="w-full rounded-lg border border-gray-200 px-3 py-2 text-sm focus:border-primary focus:ring-2 focus:ring-primary/20">
                  </div>
                  <div>
                    <label for="valor-ipi" class="block text-sm font-medium text-gray-700 mb-1">Valor IPI (R$)</label>
                    <input type="number" step="0.01" id="valor-ipi" class="w-full rounded-lg border border-gray-200 px-3 py-2 text-sm focus:border-primary focus:ring-2 focus:ring-primary/20">
                  </div>
                  <div>
                    <label for="desconto-unitario" class="block text-sm font-medium text-gray-700 mb-1">Desconto Unitário (R$)</label>
                    <input type="number" step="0.01" id="desconto-unitario" class="w-full rounded-lg border border-gray-200 px-3 py-2 text-sm focus:border-primary focus:ring-2 focus:ring-primary/20">
                  </div>
                  <div>
                    <label for="valor-seguro" class="block text-sm font-medium text-gray-700 mb-1">Valor Seguro (R$)</label>
                    <input type="number" step="0.01" id="valor-seguro" class="w-full rounded-lg border border-gray-200 px-3 py-2 text-sm focus:border-primary focus:ring-2 focus:ring-primary/20">
                  </div>
                  <div>
                    <label for="valor-dolar" class="block text-sm font-medium text-gray-700 mb-1">Valor da NF em Dólar</label>
                    <input type="number" step="0.01" id="valor-dolar" class="w-full rounded-lg border border-gray-200 px-3 py-2 text-sm focus:border-primary focus:ring-2 focus:ring-primary/20" placeholder="2974.55">
                  </div>
                </div>
              </div>
            </div>

            <div class="tab-panel hidden" data-tab-panel="observacoes">
              <div class="space-y-4">
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <label class="inline-flex items-center gap-2 text-sm font-medium text-gray-700">
                    <input type="checkbox" class="rounded border-gray-300 text-primary focus:ring-primary/30">
                    Pagar Frete
                  </label>
                  <label class="inline-flex items-center gap-2 text-sm font-medium text-gray-700">
                    <input type="checkbox" class="rounded border-gray-300 text-primary focus:ring-primary/30">
                    Não Alterar Estoque
                  </label>
                  <label class="inline-flex items-center gap-2 text-sm font-medium text-gray-700">
                    <input type="checkbox" class="rounded border-gray-300 text-primary focus:ring-primary/30">
                    Valor Seguro
                  </label>
                  <label class="inline-flex items-center gap-2 text-sm font-medium text-gray-700">
                    <input type="checkbox" class="rounded border-gray-300 text-primary focus:ring-primary/30">
                    Não escriturar o valor de ICMS
                  </label>
                </div>

                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <div>
                    <label for="condicao-pagamento" class="block text-sm font-medium text-gray-700 mb-1">Condição de Pagamento</label>
                    <input type="text" id="condicao-pagamento" class="w-full rounded-lg border border-gray-200 px-3 py-2 text-sm focus:border-primary focus:ring-2 focus:ring-primary/20" placeholder="30/60/90 dias">
                  </div>
                  <div>
                    <label for="cliente-retorno" class="block text-sm font-medium text-gray-700 mb-1">Cliente para retorno parcial (F2)</label>
                    <input type="text" id="cliente-retorno" class="w-full rounded-lg border border-gray-200 px-3 py-2 text-sm focus:border-primary focus:ring-2 focus:ring-primary/20" placeholder="Pesquisar cliente">
                  </div>
                  <div>
                    <label for="centro-custo" class="block text-sm font-medium text-gray-700 mb-1">Centro de Custo (F2)</label>
                    <input type="text" id="centro-custo" class="w-full rounded-lg border border-gray-200 px-3 py-2 text-sm focus:border-primary focus:ring-2 focus:ring-primary/20" placeholder="01.02.03 - Comercial">
                  </div>
                  <div>
                    <label for="forma-pagamento" class="block text-sm font-medium text-gray-700 mb-1">Forma de Pagamento</label>
                    <input type="text" id="forma-pagamento" class="w-full rounded-lg border border-gray-200 px-3 py-2 text-sm focus:border-primary focus:ring-2 focus:ring-primary/20" placeholder="À Vista">
                  </div>
                </div>

                <div>
                  <label for="observacao" class="block text-sm font-medium text-gray-700 mb-1">Observação</label>
                  <textarea id="observacao" rows="4" class="w-full rounded-lg border border-gray-200 px-3 py-2 text-sm focus:border-primary focus:ring-2 focus:ring-primary/20" placeholder="Informações complementares sobre a operação."></textarea>
                </div>
                <div>
                  <label for="informacoes-complementares" class="block text-sm font-medium text-gray-700 mb-1">Informações Complementares ao Fisco/Contribuinte</label>
                  <textarea id="informacoes-complementares" rows="3" class="w-full rounded-lg border border-gray-200 px-3 py-2 text-sm focus:border-primary focus:ring-2 focus:ring-primary/20" placeholder="Referência à legislação municipal ou mensagens obrigatórias da SEFAZ."></textarea>
                </div>
              </div>
            </div>

            <div class="tab-panel hidden" data-tab-panel="produtos">
              <div class="flex flex-wrap items-center justify-between gap-3">
                <h3 class="text-sm font-semibold text-gray-700">Itens da nota</h3>
                <div class="flex flex-wrap gap-2">
                  <button type="button" class="inline-flex items-center gap-2 rounded-lg border border-gray-200 px-3 py-1.5 text-xs font-semibold text-gray-600 hover:bg-gray-50 transition">
                    <i class="fas fa-plus-circle"></i>
                    Adicionar Produto
                  </button>
                  <button
                    type="button"
                    class="inline-flex items-center gap-2 rounded-lg border border-amber-300 bg-amber-50 px-3 py-1.5 text-xs font-semibold text-amber-700 transition hover:bg-amber-100"
                    data-open-import-modal
                    data-import-context="bonus"
                  >
                    <i class="fas fa-gift"></i>
                    Adicionar Bonificação
                  </button>
                  <button type="button" class="inline-flex items-center gap-2 rounded-lg border border-gray-200 px-3 py-1.5 text-xs font-semibold text-gray-600 hover:bg-gray-50 transition">
                    <i class="fas fa-exchange-alt"></i>
                    Alterar Fornecedor por Produto
                  </button>
                </div>
              </div>

              <div class="mt-4 overflow-x-auto">
                <table class="min-w-full divide-y divide-gray-200 text-sm">
                  <thead class="bg-gray-50">
                    <tr class="text-[11px] font-semibold uppercase tracking-wide text-gray-600">
                      <th scope="col" class="px-4 py-3 text-left align-top">
                        <div class="flex flex-col gap-1">
                          <div class="flex items-center justify-between gap-1">
                            <span class="text-[11px] font-semibold uppercase tracking-wide text-gray-600 whitespace-nowrap">Item</span>
                            <div class="flex flex-col items-center justify-center gap-px text-gray-400">
                              <button
                                type="button"
                                class="flex h-3.5 w-3.5 items-center justify-center rounded border border-transparent text-gray-400 transition hover:text-primary focus:outline-none focus:ring-1 focus:ring-primary/40"
                                data-main-products-sort="item"
                                data-sort-direction="asc"
                                aria-label="Ordenar crescente pela coluna Item"
                              >
                                <i class="fas fa-sort-up text-[9px]"></i>
                              </button>
                              <button
                                type="button"
                                class="flex h-3.5 w-3.5 items-center justify-center rounded border border-transparent text-gray-400 transition hover:text-primary focus:outline-none focus:ring-1 focus:ring-primary/40"
                                data-main-products-sort="item"
                                data-sort-direction="desc"
                                aria-label="Ordenar decrescente pela coluna Item"
                              >
                                <i class="fas fa-sort-down text-[9px]"></i>
                              </button>
                            </div>
                          </div>
                          <input
                            type="text"
                            placeholder="Filtrar"
                            class="w-full rounded border border-gray-200 bg-white px-2 py-1 text-[10px] font-medium text-gray-600 placeholder:text-gray-400 focus:border-primary focus:outline-none focus:ring-2 focus:ring-primary/20"
                            data-main-products-filter="item"
                          />
                        </div>
                      </th>
                      <th scope="col" class="px-4 py-3 text-left align-top">
                        <div class="flex flex-col gap-1">
                          <div class="flex items-center justify-between gap-1">
                            <span class="text-[11px] font-semibold uppercase tracking-wide text-gray-600 whitespace-nowrap">Código</span>
                            <div class="flex flex-col items-center justify-center gap-px text-gray-400">
                              <button
                                type="button"
                                class="flex h-3.5 w-3.5 items-center justify-center rounded border border-transparent text-gray-400 transition hover:text-primary focus:outline-none focus:ring-1 focus:ring-primary/40"
                                data-main-products-sort="code"
                                data-sort-direction="asc"
                                aria-label="Ordenar crescente pela coluna Código"
                              >
                                <i class="fas fa-sort-up text-[9px]"></i>
                              </button>
                              <button
                                type="button"
                                class="flex h-3.5 w-3.5 items-center justify-center rounded border border-transparent text-gray-400 transition hover:text-primary focus:outline-none focus:ring-1 focus:ring-primary/40"
                                data-main-products-sort="code"
                                data-sort-direction="desc"
                                aria-label="Ordenar decrescente pela coluna Código"
                              >
                                <i class="fas fa-sort-down text-[9px]"></i>
                              </button>
                            </div>
                          </div>
                          <input
                            type="text"
                            placeholder="Filtrar"
                            class="w-full rounded border border-gray-200 bg-white px-2 py-1 text-[10px] font-medium text-gray-600 placeholder:text-gray-400 focus:border-primary focus:outline-none focus:ring-2 focus:ring-primary/20"
                            data-main-products-filter="code"
                          />
                        </div>
                      </th>
                      <th scope="col" class="px-4 py-3 text-left align-top">
                        <div class="flex flex-col gap-1">
                          <div class="flex items-center justify-between gap-1">
                            <span class="text-[11px] font-semibold uppercase tracking-wide text-gray-600 whitespace-nowrap">Descrição</span>
                            <div class="flex flex-col items-center justify-center gap-px text-gray-400">
                              <button
                                type="button"
                                class="flex h-3.5 w-3.5 items-center justify-center rounded border border-transparent text-gray-400 transition hover:text-primary focus:outline-none focus:ring-1 focus:ring-primary/40"
                                data-main-products-sort="description"
                                data-sort-direction="asc"
                                aria-label="Ordenar crescente pela coluna Descrição"
                              >
                                <i class="fas fa-sort-up text-[9px]"></i>
                              </button>
                              <button
                                type="button"
                                class="flex h-3.5 w-3.5 items-center justify-center rounded border border-transparent text-gray-400 transition hover:text-primary focus:outline-none focus:ring-1 focus:ring-primary/40"
                                data-main-products-sort="description"
                                data-sort-direction="desc"
                                aria-label="Ordenar decrescente pela coluna Descrição"
                              >
                                <i class="fas fa-sort-down text-[9px]"></i>
                              </button>
                            </div>
                          </div>
                          <input
                            type="text"
                            placeholder="Filtrar"
                            class="w-full rounded border border-gray-200 bg-white px-2 py-1 text-[10px] font-medium text-gray-600 placeholder:text-gray-400 focus:border-primary focus:outline-none focus:ring-2 focus:ring-primary/20"
                            data-main-products-filter="description"
                          />
                        </div>
                      </th>
                      <th scope="col" class="px-4 py-3 text-right align-top">
                        <div class="flex flex-col items-end gap-1">
                          <div class="flex w-full items-center justify-end gap-1">
                            <span class="text-right text-[11px] font-semibold uppercase tracking-wide text-gray-600 whitespace-nowrap">Qtde.</span>
                            <div class="flex flex-col items-center justify-center gap-px text-gray-400">
                              <button
                                type="button"
                                class="flex h-3.5 w-3.5 items-center justify-center rounded border border-transparent text-gray-400 transition hover:text-primary focus:outline-none focus:ring-1 focus:ring-primary/40"
                                data-main-products-sort="quantity"
                                data-sort-direction="asc"
                                aria-label="Ordenar crescente pela coluna Qtde."
                              >
                                <i class="fas fa-sort-up text-[9px]"></i>
                              </button>
                              <button
                                type="button"
                                class="flex h-3.5 w-3.5 items-center justify-center rounded border border-transparent text-gray-400 transition hover:text-primary focus:outline-none focus:ring-1 focus:ring-primary/40"
                                data-main-products-sort="quantity"
                                data-sort-direction="desc"
                                aria-label="Ordenar decrescente pela coluna Qtde."
                              >
                                <i class="fas fa-sort-down text-[9px]"></i>
                              </button>
                            </div>
                          </div>
                          <input
                            type="text"
                            placeholder="Filtrar"
                            class="w-full rounded border border-gray-200 bg-white px-2 py-1 text-right text-[10px] font-medium text-gray-600 placeholder:text-gray-400 focus:border-primary focus:outline-none focus:ring-2 focus:ring-primary/20"
                            data-main-products-filter="quantity"
                          />
                        </div>
                      </th>
                      <th scope="col" class="px-4 py-3 text-right align-top">
                        <div class="flex flex-col items-end gap-1">
                          <div class="flex w-full items-center justify-end gap-1">
                            <span class="text-right text-[11px] font-semibold uppercase tracking-wide text-gray-600 whitespace-nowrap">Multiplicador/Divisor</span>
                            <div class="flex flex-col items-center justify-center gap-px text-gray-400">
                              <button
                                type="button"
                                class="flex h-3.5 w-3.5 items-center justify-center rounded border border-transparent text-gray-400 transition hover:text-primary focus:outline-none focus:ring-1 focus:ring-primary/40"
                                data-main-products-sort="conversion"
                                data-sort-direction="asc"
                                aria-label="Ordenar crescente pela coluna Multiplicador/Divisor"
                              >
                                <i class="fas fa-sort-up text-[9px]"></i>
                              </button>
                              <button
                                type="button"
                                class="flex h-3.5 w-3.5 items-center justify-center rounded border border-transparent text-gray-400 transition hover:text-primary focus:outline-none focus:ring-1 focus:ring-primary/40"
                                data-main-products-sort="conversion"
                                data-sort-direction="desc"
                                aria-label="Ordenar decrescente pela coluna Multiplicador/Divisor"
                              >
                                <i class="fas fa-sort-down text-[9px]"></i>
                              </button>
                            </div>
                          </div>
                          <input
                            type="text"
                            placeholder="Filtrar"
                            class="w-full rounded border border-gray-200 bg-white px-2 py-1 text-right text-[10px] font-medium text-gray-600 placeholder:text-gray-400 focus:border-primary focus:outline-none focus:ring-2 focus:ring-primary/20"
                            data-main-products-filter="conversion"
                          />
                        </div>
                      </th>
                      <th scope="col" class="px-4 py-3 text-left align-top">
                        <div class="flex flex-col gap-1">
                          <div class="flex items-center justify-between gap-1">
                            <span class="text-[11px] font-semibold uppercase tracking-wide text-gray-600 whitespace-nowrap">Unidade</span>
                            <div class="flex flex-col items-center justify-center gap-px text-gray-400">
                              <button
                                type="button"
                                class="flex h-3.5 w-3.5 items-center justify-center rounded border border-transparent text-gray-400 transition hover:text-primary focus:outline-none focus:ring-1 focus:ring-primary/40"
                                data-main-products-sort="unit"
                                data-sort-direction="asc"
                                aria-label="Ordenar crescente pela coluna Unidade"
                              >
                                <i class="fas fa-sort-up text-[9px]"></i>
                              </button>
                              <button
                                type="button"
                                class="flex h-3.5 w-3.5 items-center justify-center rounded border border-transparent text-gray-400 transition hover:text-primary focus:outline-none focus:ring-1 focus:ring-primary/40"
                                data-main-products-sort="unit"
                                data-sort-direction="desc"
                                aria-label="Ordenar decrescente pela coluna Unidade"
                              >
                                <i class="fas fa-sort-down text-[9px]"></i>
                              </button>
                            </div>
                          </div>
                          <input
                            type="text"
                            placeholder="Filtrar"
                            class="w-full rounded border border-gray-200 bg-white px-2 py-1 text-[10px] font-medium text-gray-600 placeholder:text-gray-400 focus:border-primary focus:outline-none focus:ring-2 focus:ring-primary/20"
                            data-main-products-filter="unit"
                          />
                        </div>
                      </th>
                      <th scope="col" class="px-4 py-3 text-right align-top">
                        <div class="flex flex-col items-end gap-1">
                          <div class="flex w-full items-center justify-end gap-1">
                            <span class="text-right text-[11px] font-semibold uppercase tracking-wide text-gray-600 whitespace-nowrap">Estoque de entrada</span>
                            <div class="flex flex-col items-center justify-center gap-px text-gray-400">
                              <button
                                type="button"
                                class="flex h-3.5 w-3.5 items-center justify-center rounded border border-transparent text-gray-400 transition hover:text-primary focus:outline-none focus:ring-1 focus:ring-primary/40"
                                data-main-products-sort="entryStock"
                                data-sort-direction="asc"
                                aria-label="Ordenar crescente pela coluna Estoque de entrada"
                              >
                                <i class="fas fa-sort-up text-[9px]"></i>
                              </button>
                              <button
                                type="button"
                                class="flex h-3.5 w-3.5 items-center justify-center rounded border border-transparent text-gray-400 transition hover:text-primary focus:outline-none focus:ring-1 focus:ring-primary/40"
                                data-main-products-sort="entryStock"
                                data-sort-direction="desc"
                                aria-label="Ordenar decrescente pela coluna Estoque de entrada"
                              >
                                <i class="fas fa-sort-down text-[9px]"></i>
                              </button>
                            </div>
                          </div>
                          <input
                            type="text"
                            placeholder="Filtrar"
                            class="w-full rounded border border-gray-200 bg-white px-2 py-1 text-right text-[10px] font-medium text-gray-600 placeholder:text-gray-400 focus:border-primary focus:outline-none focus:ring-2 focus:ring-primary/20"
                            data-main-products-filter="entryStock"
                          />
                        </div>
                      </th>
                      <th scope="col" class="px-4 py-3 text-right align-top">
                        <div class="flex flex-col items-end gap-1">
                          <div class="flex w-full items-center justify-end gap-1">
                            <span class="text-right text-[11px] font-semibold uppercase tracking-wide text-gray-600 whitespace-nowrap">Custo calculado (R$)</span>
                            <div class="flex flex-col items-center justify-center gap-px text-gray-400">
                              <button
                                type="button"
                                class="flex h-3.5 w-3.5 items-center justify-center rounded border border-transparent text-gray-400 transition hover:text-primary focus:outline-none focus:ring-1 focus:ring-primary/40"
                                data-main-products-sort="cost"
                                data-sort-direction="asc"
                                aria-label="Ordenar crescente pela coluna Custo calculado (R$)"
                              >
                                <i class="fas fa-sort-up text-[9px]"></i>
                              </button>
                              <button
                                type="button"
                                class="flex h-3.5 w-3.5 items-center justify-center rounded border border-transparent text-gray-400 transition hover:text-primary focus:outline-none focus:ring-1 focus:ring-primary/40"
                                data-main-products-sort="cost"
                                data-sort-direction="desc"
                                aria-label="Ordenar decrescente pela coluna Custo calculado (R$)"
                              >
                                <i class="fas fa-sort-down text-[9px]"></i>
                              </button>
                            </div>
                          </div>
                          <input
                            type="text"
                            placeholder="Filtrar"
                            class="w-full rounded border border-gray-200 bg-white px-2 py-1 text-right text-[10px] font-medium text-gray-600 placeholder:text-gray-400 focus:border-primary focus:outline-none focus:ring-2 focus:ring-primary/20"
                            data-main-products-filter="cost"
                          />
                        </div>
                      </th>
                      <th scope="col" class="px-4 py-3 text-right align-top">
                        <div class="flex flex-col items-end gap-1">
                          <div class="flex w-full items-center justify-end gap-1">
                            <span class="text-right text-[11px] font-semibold uppercase tracking-wide text-gray-600 whitespace-nowrap">Unitário (R$)</span>
                            <div class="flex flex-col items-center justify-center gap-px text-gray-400">
                              <button
                                type="button"
                                class="flex h-3.5 w-3.5 items-center justify-center rounded border border-transparent text-gray-400 transition hover:text-primary focus:outline-none focus:ring-1 focus:ring-primary/40"
                                data-main-products-sort="unitPrice"
                                data-sort-direction="asc"
                                aria-label="Ordenar crescente pela coluna Unitário (R$)"
                              >
                                <i class="fas fa-sort-up text-[9px]"></i>
                              </button>
                              <button
                                type="button"
                                class="flex h-3.5 w-3.5 items-center justify-center rounded border border-transparent text-gray-400 transition hover:text-primary focus:outline-none focus:ring-1 focus:ring-primary/40"
                                data-main-products-sort="unitPrice"
                                data-sort-direction="desc"
                                aria-label="Ordenar decrescente pela coluna Unitário (R$)"
                              >
                                <i class="fas fa-sort-down text-[9px]"></i>
                              </button>
                            </div>
                          </div>
                          <input
                            type="text"
                            placeholder="Filtrar"
                            class="w-full rounded border border-gray-200 bg-white px-2 py-1 text-right text-[10px] font-medium text-gray-600 placeholder:text-gray-400 focus:border-primary focus:outline-none focus:ring-2 focus:ring-primary/20"
                            data-main-products-filter="unitPrice"
                          />
                        </div>
                      </th>
                      <th scope="col" class="px-4 py-3 text-right align-top">
                        <div class="flex flex-col items-end gap-1">
                          <div class="flex w-full items-center justify-end gap-1">
                            <span class="text-right text-[11px] font-semibold uppercase tracking-wide text-gray-600 whitespace-nowrap">Desc (%)</span>
                            <div class="flex flex-col items-center justify-center gap-px text-gray-400">
                              <button
                                type="button"
                                class="flex h-3.5 w-3.5 items-center justify-center rounded border border-transparent text-gray-400 transition hover:text-primary focus:outline-none focus:ring-1 focus:ring-primary/40"
                                data-main-products-sort="discount"
                                data-sort-direction="asc"
                                aria-label="Ordenar crescente pela coluna Desc (%)"
                              >
                                <i class="fas fa-sort-up text-[9px]"></i>
                              </button>
                              <button
                                type="button"
                                class="flex h-3.5 w-3.5 items-center justify-center rounded border border-transparent text-gray-400 transition hover:text-primary focus:outline-none focus:ring-1 focus:ring-primary/40"
                                data-main-products-sort="discount"
                                data-sort-direction="desc"
                                aria-label="Ordenar decrescente pela coluna Desc (%)"
                              >
                                <i class="fas fa-sort-down text-[9px]"></i>
                              </button>
                            </div>
                          </div>
                          <input
                            type="text"
                            placeholder="Filtrar"
                            class="w-full rounded border border-gray-200 bg-white px-2 py-1 text-right text-[10px] font-medium text-gray-600 placeholder:text-gray-400 focus:border-primary focus:outline-none focus:ring-2 focus:ring-primary/20"
                            data-main-products-filter="discount"
                          />
                        </div>
                      </th>
                    </tr>
                  </thead>
                  <tbody class="divide-y divide-gray-100 bg-white" data-nfe-products-body>
                    <tr class="hidden" data-nfe-products-empty>
                      <td class="px-4 py-3 text-center text-gray-500" colspan="10">
                        Nenhum produto importado do XML.
                      </td>
                    </tr>
                    <tr class="hidden" data-nfe-products-filtered-empty>
                      <td class="px-4 py-3 text-center text-gray-500" colspan="10">
                        Nenhum produto encontrado com os filtros aplicados.
                      </td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>

            <div class="tab-panel hidden" data-tab-panel="transportadora">
              <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                  <label for="transportadora-cnpj" class="block text-sm font-medium text-gray-700 mb-1">CNPJ</label>
                  <input type="text" id="transportadora-cnpj" class="w-full rounded-lg border border-gray-200 px-3 py-2 text-sm focus:border-primary focus:ring-2 focus:ring-primary/20" placeholder="12.345.678/0001-99">
                </div>
                <div>
                  <label for="transportadora-ie" class="block text-sm font-medium text-gray-700 mb-1">IE – Transportadora</label>
                  <input type="text" id="transportadora-ie" class="w-full rounded-lg border border-gray-200 px-3 py-2 text-sm focus:border-primary focus:ring-2 focus:ring-primary/20" placeholder="111.222.333.444">
                </div>
                <div>
                  <label for="transportadora-uf" class="block text-sm font-medium text-gray-700 mb-1">UF – Transportadora</label>
                  <select id="transportadora-uf" class="w-full rounded-lg border border-gray-200 px-3 py-2 text-sm focus:border-primary focus:ring-2 focus:ring-primary/20">
                    <option value="">Selecione</option>
                    <option value="AC">AC - Acre</option>
                    <option value="AL">AL - Alagoas</option>
                    <option value="AP">AP - Amapá</option>
                    <option value="AM">AM - Amazonas</option>
                    <option value="BA">BA - Bahia</option>
                    <option value="CE">CE - Ceará</option>
                    <option value="DF">DF - Distrito Federal</option>
                    <option value="ES">ES - Espírito Santo</option>
                    <option value="GO">GO - Goiás</option>
                    <option value="MA">MA - Maranhão</option>
                    <option value="MT">MT - Mato Grosso</option>
                    <option value="MS">MS - Mato Grosso do Sul</option>
                    <option value="MG">MG - Minas Gerais</option>
                    <option value="PA">PA - Pará</option>
                    <option value="PB">PB - Paraíba</option>
                    <option value="PR">PR - Paraná</option>
                    <option value="PE">PE - Pernambuco</option>
                    <option value="PI">PI - Piauí</option>
                    <option value="RJ">RJ - Rio de Janeiro</option>
                    <option value="RN">RN - Rio Grande do Norte</option>
                    <option value="RS">RS - Rio Grande do Sul</option>
                    <option value="RO">RO - Rondônia</option>
                    <option value="RR">RR - Roraima</option>
                    <option value="SC">SC - Santa Catarina</option>
                    <option value="SP">SP - São Paulo</option>
                    <option value="SE">SE - Sergipe</option>
                    <option value="TO">TO - Tocantins</option>
                  </select>
                </div>
                <div>
                  <label for="transportadora-placa" class="block text-sm font-medium text-gray-700 mb-1">Placa – Transportadora</label>
                  <input type="text" id="transportadora-placa" class="w-full rounded-lg border border-gray-200 px-3 py-2 text-sm focus:border-primary focus:ring-2 focus:ring-primary/20" placeholder="RIO1A23">
                </div>
                <div>
                  <label for="transportadora-uf-placa" class="block text-sm font-medium text-gray-700 mb-1">UF Placa – Transportadora</label>
                  <select id="transportadora-uf-placa" class="w-full rounded-lg border border-gray-200 px-3 py-2 text-sm focus:border-primary focus:ring-2 focus:ring-primary/20">
                    <option value="">Selecione</option>
                    <option value="AC">AC</option>
                    <option value="AL">AL</option>
                    <option value="AP">AP</option>
                    <option value="AM">AM</option>
                    <option value="BA">BA</option>
                    <option value="CE">CE</option>
                    <option value="DF">DF</option>
                    <option value="ES">ES</option>
                    <option value="GO">GO</option>
                    <option value="MA">MA</option>
                    <option value="MT">MT</option>
                    <option value="MS">MS</option>
                    <option value="MG">MG</option>
                    <option value="PA">PA</option>
                    <option value="PB">PB</option>
                    <option value="PR">PR</option>
                    <option value="PE">PE</option>
                    <option value="PI">PI</option>
                    <option value="RJ">RJ</option>
                    <option value="RN">RN</option>
                    <option value="RS">RS</option>
                    <option value="RO">RO</option>
                    <option value="RR">RR</option>
                    <option value="SC">SC</option>
                    <option value="SP">SP</option>
                    <option value="SE">SE</option>
                    <option value="TO">TO</option>
                  </select>
                </div>
                <div>
                  <label for="peso-bruto" class="block text-sm font-medium text-gray-700 mb-1">Peso Bruto</label>
                  <input type="number" step="0.001" id="peso-bruto" class="w-full rounded-lg border border-gray-200 px-3 py-2 text-sm focus:border-primary focus:ring-2 focus:ring-primary/20" placeholder="185.750">
                </div>
                <div>
                  <label for="peso-liquido" class="block text-sm font-medium text-gray-700 mb-1">Peso Líquido</label>
                  <input type="number" step="0.001" id="peso-liquido" class="w-full rounded-lg border border-gray-200 px-3 py-2 text-sm focus:border-primary focus:ring-2 focus:ring-primary/20" placeholder="172.300">
                </div>
                <div>
                  <label for="modalidade-frete" class="block text-sm font-medium text-gray-700 mb-1">Modalidade do Frete (modFrete)</label>
                  <select id="modalidade-frete" class="w-full rounded-lg border border-gray-200 px-3 py-2 text-sm focus:border-primary focus:ring-2 focus:ring-primary/20">
                    <option value="0" selected>0 – Por conta do emitente</option>
                    <option value="1">1 – Por conta do destinatário/remetente</option>
                    <option value="2">2 – Por conta de terceiros</option>
                    <option value="3">3 – Transporte próprio por conta do remetente</option>
                    <option value="4">4 – Transporte próprio por conta do destinatário</option>
                    <option value="9">9 – Sem frete</option>
                  </select>
                </div>
                <div class="md:col-span-2">
                  <label for="transportadora-razao" class="block text-sm font-medium text-gray-700 mb-1">Razão Social / Nome</label>
                  <input type="text" id="transportadora-razao" class="w-full rounded-lg border border-gray-200 px-3 py-2 text-sm focus:border-primary focus:ring-2 focus:ring-primary/20" placeholder="Transportes RodoVia Ltda">
                </div>
              </div>
            </div>

            <div class="tab-panel hidden" data-tab-panel="duplicatas">
              <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                  <label for="conta-contabil" class="block text-sm font-medium text-gray-700 mb-1">Conta Contábil (F2)*</label>
                  <input type="text" id="conta-contabil" class="w-full rounded-lg border border-gray-200 px-3 py-2 text-sm focus:border-primary focus:ring-2 focus:ring-primary/20" placeholder="1.1.3.01 - Fornecedores Nacionais" required>
                </div>
                <div>
                  <label for="forma-pagamento-duplicata" class="block text-sm font-medium text-gray-700 mb-1">Forma de Pagamento</label>
                  <select id="forma-pagamento-duplicata" class="w-full rounded-lg border border-gray-200 px-3 py-2 text-sm focus:border-primary focus:ring-2 focus:ring-primary/20">
                    <option value="boleto">Boleto</option>
                    <option value="transferencia">Transferência</option>
                    <option value="pix">PIX</option>
                    <option value="dinheiro">Dinheiro</option>
                  </select>
                </div>
                <div>
                  <label for="conta-corrente" class="block text-sm font-medium text-gray-700 mb-1">Conta Corrente* </label>
                  <select id="conta-corrente" class="w-full rounded-lg border border-gray-200 px-3 py-2 text-sm focus:border-primary focus:ring-2 focus:ring-primary/20" required>
                    <option value="">Selecione</option>
                    <option value="001-12345-6">Banco do Brasil 001 - Ag. 1234 - C/C 56789-0</option>
                    <option value="104-98765-4">Caixa 104 - Ag. 2222 - C/C 33333-3</option>
                  </select>
                </div>
                <div>
                  <label class="inline-flex items-center gap-2 text-sm font-medium text-gray-700 mt-7">
                    <input type="checkbox" class="rounded border-gray-300 text-primary focus:ring-primary/30">
                    Considerar Inativos
                  </label>
                </div>
                <div>
                  <label for="duplicata-data-emissao" class="block text-sm font-medium text-gray-700 mb-1">Data Emissão</label>
                  <input type="date" id="duplicata-data-emissao" class="w-full rounded-lg border border-gray-200 bg-gray-50 px-3 py-2 text-sm text-gray-500" value="2024-07-05" readonly>
                </div>
                <div>
                  <label for="numero-doc-bancario" class="block text-sm font-medium text-gray-700 mb-1">Nº Doc. Bancário</label>
                  <input type="text" id="numero-doc-bancario" class="w-full rounded-lg border border-gray-200 px-3 py-2 text-sm focus:border-primary focus:ring-2 focus:ring-primary/20" placeholder="0001234567">
                </div>
                <div>
                  <label for="parcelas" class="block text-sm font-medium text-gray-700 mb-1">Parcelas*</label>
                  <input type="number" id="parcelas" class="w-full rounded-lg border border-gray-200 px-3 py-2 text-sm focus:border-primary focus:ring-2 focus:ring-primary/20" min="1" value="3" required>
                </div>
                <div>
                  <label for="dias-vencimento" class="block text-sm font-medium text-gray-700 mb-1">Dias Vencimento Inicial</label>
                  <input type="number" id="dias-vencimento" class="w-full rounded-lg border border-gray-200 px-3 py-2 text-sm focus:border-primary focus:ring-2 focus:ring-primary/20" placeholder="30">
                </div>
                <div>
                  <label for="vencimento-inicial" class="block text-sm font-medium text-gray-700 mb-1">Vencimento Inicial</label>
                  <input type="date" id="vencimento-inicial" class="w-full rounded-lg border border-gray-200 px-3 py-2 text-sm focus:border-primary focus:ring-2 focus:ring-primary/20">
                </div>
                <div>
                  <label for="tipo-dias" class="block text-sm font-medium text-gray-700 mb-1">Tipo dias</label>
                  <select id="tipo-dias" class="w-full rounded-lg border border-gray-200 px-3 py-2 text-sm focus:border-primary focus:ring-2 focus:ring-primary/20">
                    <option value="dias" selected>Nº de dias</option>
                    <option value="data">Data fixa</option>
                  </select>
                </div>
                <div>
                  <label for="dias" class="block text-sm font-medium text-gray-700 mb-1">Dias</label>
                  <input type="number" id="dias" class="w-full rounded-lg border border-gray-200 px-3 py-2 text-sm focus:border-primary focus:ring-2 focus:ring-primary/20" placeholder="30">
                </div>
                <div>
                  <label class="inline-flex items-center gap-2 text-sm font-medium text-gray-700 mt-7">
                    <input type="checkbox" class="rounded border-gray-300 text-primary focus:ring-primary/30">
                    Previsão
                  </label>
                </div>
              </div>

              <div class="mt-6 flex flex-wrap items-center gap-3">
                <button
                  type="button"
                  class="inline-flex items-center gap-2 rounded-lg bg-primary px-4 py-2 text-sm font-semibold text-white shadow-sm hover:bg-primary/90 transition"
                  data-nfe-duplicatas-generate
                >
                  <i class="fas fa-calculator"></i>
                  Gerar
                </button>
              </div>

              <div class="mt-4 overflow-x-auto">
                <table class="min-w-full divide-y divide-gray-200 text-sm">
                  <thead class="bg-gray-50">
                    <tr>
                      <th class="px-4 py-3 text-left font-semibold text-gray-700">Parcela</th>
                      <th class="px-4 py-3 text-left font-semibold text-gray-700">Dias</th>
                      <th class="px-4 py-3 text-left font-semibold text-gray-700">Vencimento Inicial</th>
                      <th class="px-4 py-3 text-right font-semibold text-gray-700">Valor (R$)</th>
                      <th class="px-4 py-3 text-left font-semibold text-gray-700">Observação</th>
                      <th class="px-4 py-3 text-left font-semibold text-gray-700">Conta Contábil</th>
                      <th class="px-4 py-3 text-left font-semibold text-gray-700">Código Conta Contábil</th>
                      <th class="px-4 py-3 text-left font-semibold text-gray-700">Conta Corrente</th>
                    </tr>
                  </thead>
                  <tbody class="divide-y divide-gray-100 bg-white" data-nfe-duplicatas-body>
                    <tr class="hidden" data-nfe-duplicatas-empty>
                      <td class="px-4 py-3 text-center text-gray-500" colspan="8">
                        Nenhuma duplicata foi informada no XML.
                      </td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>

            <div class="tab-panel hidden" data-tab-panel="documentos">
              <div class="flex flex-wrap items-center justify-between gap-3">
                <h3 class="text-sm font-semibold text-gray-700">Documentos vinculados</h3>
                <button type="button" class="inline-flex items-center gap-2 rounded-lg bg-primary px-3 py-1.5 text-xs font-semibold text-white shadow-sm hover:bg-primary/90 transition">
                  <i class="fas fa-link"></i>
                  Adicionar NF
                </button>
              </div>

              <div class="mt-4 overflow-x-auto">
                <table class="min-w-full divide-y divide-gray-200 text-sm">
                  <thead class="bg-gray-50">
                    <tr>
                      <th class="px-4 py-3 text-left font-semibold text-gray-700">Tipo</th>
                      <th class="px-4 py-3 text-left font-semibold text-gray-700">Modelo</th>
                      <th class="px-4 py-3 text-left font-semibold text-gray-700">Número da Nota</th>
                      <th class="px-4 py-3 text-left font-semibold text-gray-700">Chave de Acesso</th>
                      <th class="px-4 py-3 text-left font-semibold text-gray-700">Data Emissão</th>
                    </tr>
                  </thead>
                  <tbody class="divide-y divide-gray-100 bg-white" data-nfe-documents-body>
                    <tr class="hidden" data-nfe-documents-empty>
                      <td class="px-4 py-3 text-center text-gray-500" colspan="5">
                        Nenhum documento vinculado pelo XML.
                      </td>
                    </tr>
                  </tbody>
                </table>
              </div>

              <div class="mt-4 flex flex-wrap gap-2 text-xs text-gray-500">
                <button type="button" class="inline-flex items-center gap-1 rounded border border-gray-200 px-2.5 py-1 font-medium hover:bg-gray-50">
                  <i class="fas fa-file-excel"></i>
                  Excel
                </button>
                <button type="button" class="inline-flex items-center gap-1 rounded border border-gray-200 px-2.5 py-1 font-medium hover:bg-gray-50">
                  <i class="fas fa-file-pdf"></i>
                  PDF
                </button>
                <button type="button" class="inline-flex items-center gap-1 rounded border border-gray-200 px-2.5 py-1 font-medium hover:bg-gray-50">
                  <i class="fas fa-table"></i>
                  Layout
                </button>
                <button type="button" class="inline-flex items-center gap-1 rounded border border-gray-200 px-2.5 py-1 font-medium hover:bg-gray-50">
                  <i class="fas fa-expand"></i>
                  Tela Cheia
                </button>
              </div>
            </div>
          </div>
        </section>

        <div class="flex flex-col-reverse gap-3 md:flex-row md:items-center md:justify-between">
          <button
            type="button"
            data-delete-entry
            class="inline-flex items-center gap-2 self-start rounded-lg border border-red-200 px-4 py-2 text-sm font-semibold text-red-600 transition hover:bg-red-50 hidden"
          >
            <i class="fas fa-trash" data-delete-entry-icon></i>
            <span data-delete-entry-text>Excluir nota</span>
          </button>

          <div class="flex flex-col gap-3 md:flex-row md:items-center md:justify-end">
            <button type="button" data-save-draft class="inline-flex items-center gap-2 rounded-lg border border-gray-200 px-4 py-2 text-sm font-medium text-gray-600 hover:bg-gray-50 transition">
              <i class="fas fa-file-archive"></i>
              Salvar rascunho
            </button>
            <button type="button" data-clear-import class="inline-flex items-center gap-2 rounded-lg border border-gray-200 px-4 py-2 text-sm font-medium text-gray-600 hover:bg-gray-50 transition">
              <i class="fas fa-eraser"></i>
              Limpar
            </button>
            <button
              type="button"
              data-register-entry
              class="inline-flex items-center gap-2 rounded-lg bg-primary px-4 py-2 text-sm font-semibold text-white shadow-sm transition hover:bg-primary/90"
            >
              <i class="fas fa-save" data-register-entry-icon></i>
              <span data-register-entry-text>Registrar entrada da NF-e</span>
            </button>
          </div>
        </div>
      </div>
    </div>
  </main>

  <div id="nfe-code-lookup-modal" class="fixed inset-0 z-[999] hidden">
    <div class="absolute inset-0 bg-gray-900/60 backdrop-blur-sm" data-close-code-modal></div>
    <div class="relative mx-auto flex min-h-full w-full items-start justify-center px-3 py-6 sm:items-center">
      <div
        data-code-modal-card
        class="relative flex w-full max-w-[1280px] transform-gpu flex-col overflow-hidden rounded-2xl bg-white shadow-2xl opacity-0 transition-all duration-200 ease-out scale-95 max-h-[90vh]"
      >
        <header class="flex flex-col gap-2.5 border-b border-gray-100 px-4 py-3 sm:flex-row sm:items-start sm:justify-between">
          <div class="space-y-1.5">
            <span class="inline-flex items-center gap-1.5 rounded-full bg-primary/10 px-2 py-0.5 text-[10px] font-semibold uppercase tracking-wide text-primary">
              <i class="fas fa-file-circle-check"></i>
              Notas cadastradas
            </span>
            <h2 class="text-lg font-semibold text-gray-900">Selecionar nota existente</h2>
            <p class="text-[11px] text-gray-600">
              Escolha a empresa e localize notas cadastradas ou aprovadas para reutilizar os dados no preenchimento atual.
            </p>
          </div>
          <button
            type="button"
            class="inline-flex items-center justify-center rounded-full border border-gray-200 p-1.5 text-gray-500 transition hover:bg-gray-50 hover:text-gray-700"
            data-close-code-modal
          >
            <span class="sr-only">Fechar modal</span>
            <i class="fas fa-times"></i>
          </button>
        </header>

        <div class="flex flex-col gap-3 border-b border-gray-100 px-4 py-3 sm:flex-row sm:items-center sm:justify-between">
          <div class="flex flex-col gap-1">
            <label for="nfe-code-company-filter" class="text-xs font-semibold uppercase tracking-wide text-gray-600">Empresa</label>
            <select
              id="nfe-code-company-filter"
              data-code-company
              class="w-full min-w-[220px] rounded-lg border border-gray-200 px-3 py-2 text-sm text-gray-700 focus:border-primary focus:ring-2 focus:ring-primary/20"
            >
              <option value="">Selecione uma empresa</option>
            </select>
          </div>
          <p class="text-[11px] text-gray-500">
            Os filtros por coluna podem ser combinados. Clique no cabeçalho para ordenar.
          </p>
        </div>

        <div class="flex-1 overflow-y-auto px-4 py-4">
          <div class="overflow-x-auto">
            <table class="min-w-full divide-y divide-gray-200 text-sm">
              <thead class="bg-gray-50">
                <tr class="text-[11px] font-semibold uppercase tracking-wide text-gray-600">
                  <th scope="col" class="px-4 py-3 text-left align-top" data-code-sort-header="code">
                    <div class="flex flex-col gap-1">
                      <div class="flex items-center justify-between gap-1">
                        <span class="whitespace-nowrap">Código</span>
                        <div class="flex flex-col items-center justify-center gap-px text-gray-400">
                          <button
                            type="button"
                            class="flex h-3.5 w-3.5 items-center justify-center rounded border border-transparent text-gray-400 transition hover:text-primary focus:outline-none focus:ring-1 focus:ring-primary/40"
                            data-code-lookup-sort="code"
                            data-sort-direction="asc"
                            aria-label="Ordenar crescente pela coluna Código"
                          >
                            <i class="fas fa-sort-up text-[9px]"></i>
                          </button>
                          <button
                            type="button"
                            class="flex h-3.5 w-3.5 items-center justify-center rounded border border-transparent text-gray-400 transition hover:text-primary focus:outline-none focus:ring-1 focus:ring-primary/40"
                            data-code-lookup-sort="code"
                            data-sort-direction="desc"
                            aria-label="Ordenar decrescente pela coluna Código"
                          >
                            <i class="fas fa-sort-down text-[9px]"></i>
                          </button>
                        </div>
                      </div>
                      <input
                        type="text"
                        placeholder="Filtrar"
                        class="w-full rounded border border-gray-200 bg-white px-2 py-1 text-[10px] font-medium text-gray-600 placeholder:text-gray-400 focus:border-primary focus:outline-none focus:ring-2 focus:ring-primary/20"
                        data-code-lookup-filter="code"
                      >
                    </div>
                  </th>
                  <th scope="col" class="px-4 py-3 text-left align-top" data-code-sort-header="accessKey">
                    <div class="flex flex-col gap-1">
                      <div class="flex items-center justify-between gap-1">
                        <span class="whitespace-nowrap">Chave de Acesso</span>
                        <div class="flex flex-col items-center justify-center gap-px text-gray-400">
                          <button
                            type="button"
                            class="flex h-3.5 w-3.5 items-center justify-center rounded border border-transparent text-gray-400 transition hover:text-primary focus:outline-none focus:ring-1 focus:ring-primary/40"
                            data-code-lookup-sort="accessKey"
                            data-sort-direction="asc"
                            aria-label="Ordenar crescente pela coluna Chave de Acesso"
                          >
                            <i class="fas fa-sort-up text-[9px]"></i>
                          </button>
                          <button
                            type="button"
                            class="flex h-3.5 w-3.5 items-center justify-center rounded border border-transparent text-gray-400 transition hover:text-primary focus:outline-none focus:ring-1 focus:ring-primary/40"
                            data-code-lookup-sort="accessKey"
                            data-sort-direction="desc"
                            aria-label="Ordenar decrescente pela coluna Chave de Acesso"
                          >
                            <i class="fas fa-sort-down text-[9px]"></i>
                          </button>
                        </div>
                      </div>
                      <input
                        type="text"
                        placeholder="Filtrar"
                        class="w-full rounded border border-gray-200 bg-white px-2 py-1 text-[10px] font-medium text-gray-600 placeholder:text-gray-400 focus:border-primary focus:outline-none focus:ring-2 focus:ring-primary/20"
                        data-code-lookup-filter="accessKey"
                      >
                    </div>
                  </th>
                  <th scope="col" class="px-4 py-3 text-left align-top" data-code-sort-header="number">
                    <div class="flex flex-col gap-1">
                      <div class="flex items-center justify-between gap-1">
                        <span class="whitespace-nowrap">NF</span>
                        <div class="flex flex-col items-center justify-center gap-px text-gray-400">
                          <button
                            type="button"
                            class="flex h-3.5 w-3.5 items-center justify-center rounded border border-transparent text-gray-400 transition hover:text-primary focus:outline-none focus:ring-1 focus:ring-primary/40"
                            data-code-lookup-sort="number"
                            data-sort-direction="asc"
                            aria-label="Ordenar crescente pela coluna NF"
                          >
                            <i class="fas fa-sort-up text-[9px]"></i>
                          </button>
                          <button
                            type="button"
                            class="flex h-3.5 w-3.5 items-center justify-center rounded border border-transparent text-gray-400 transition hover:text-primary focus:outline-none focus:ring-1 focus:ring-primary/40"
                            data-code-lookup-sort="number"
                            data-sort-direction="desc"
                            aria-label="Ordenar decrescente pela coluna NF"
                          >
                            <i class="fas fa-sort-down text-[9px]"></i>
                          </button>
                        </div>
                      </div>
                      <input
                        type="text"
                        placeholder="Filtrar"
                        class="w-full rounded border border-gray-200 bg-white px-2 py-1 text-[10px] font-medium text-gray-600 placeholder:text-gray-400 focus:border-primary focus:outline-none focus:ring-2 focus:ring-primary/20"
                        data-code-lookup-filter="number"
                      >
                    </div>
                  </th>
                  <th scope="col" class="px-4 py-3 text-left align-top" data-code-sort-header="supplier">
                    <div class="flex flex-col gap-1">
                      <div class="flex items-center justify-between gap-1">
                        <span class="whitespace-nowrap">Fornecedor</span>
                        <div class="flex flex-col items-center justify-center gap-px text-gray-400">
                          <button
                            type="button"
                            class="flex h-3.5 w-3.5 items-center justify-center rounded border border-transparent text-gray-400 transition hover:text-primary focus:outline-none focus:ring-1 focus:ring-primary/40"
                            data-code-lookup-sort="supplier"
                            data-sort-direction="asc"
                            aria-label="Ordenar crescente pela coluna Fornecedor"
                          >
                            <i class="fas fa-sort-up text-[9px]"></i>
                          </button>
                          <button
                            type="button"
                            class="flex h-3.5 w-3.5 items-center justify-center rounded border border-transparent text-gray-400 transition hover:text-primary focus:outline-none focus:ring-1 focus:ring-primary/40"
                            data-code-lookup-sort="supplier"
                            data-sort-direction="desc"
                            aria-label="Ordenar decrescente pela coluna Fornecedor"
                          >
                            <i class="fas fa-sort-down text-[9px]"></i>
                          </button>
                        </div>
                      </div>
                      <input
                        type="text"
                        placeholder="Filtrar"
                        class="w-full rounded border border-gray-200 bg-white px-2 py-1 text-[10px] font-medium text-gray-600 placeholder:text-gray-400 focus:border-primary focus:outline-none focus:ring-2 focus:ring-primary/20"
                        data-code-lookup-filter="supplier"
                      >
                    </div>
                  </th>
                  <th scope="col" class="px-4 py-3 text-right align-top" data-code-sort-header="total">
                    <div class="flex flex-col items-end gap-1">
                      <div class="flex w-full items-center justify-end gap-1">
                        <span class="whitespace-nowrap">Valor da Nota (R$)</span>
                        <div class="flex flex-col items-center justify-center gap-px text-gray-400">
                          <button
                            type="button"
                            class="flex h-3.5 w-3.5 items-center justify-center rounded border border-transparent text-gray-400 transition hover:text-primary focus:outline-none focus:ring-1 focus:ring-primary/40"
                            data-code-lookup-sort="total"
                            data-sort-direction="asc"
                            aria-label="Ordenar crescente pelo valor da nota"
                          >
                            <i class="fas fa-sort-up text-[9px]"></i>
                          </button>
                          <button
                            type="button"
                            class="flex h-3.5 w-3.5 items-center justify-center rounded border border-transparent text-gray-400 transition hover:text-primary focus:outline-none focus:ring-1 focus:ring-primary/40"
                            data-code-lookup-sort="total"
                            data-sort-direction="desc"
                            aria-label="Ordenar decrescente pelo valor da nota"
                          >
                            <i class="fas fa-sort-down text-[9px]"></i>
                          </button>
                        </div>
                      </div>
                      <input
                        type="text"
                        placeholder="Filtrar"
                        class="w-full rounded border border-gray-200 bg-white px-2 py-1 text-right text-[10px] font-medium text-gray-600 placeholder:text-gray-400 focus:border-primary focus:outline-none focus:ring-2 focus:ring-primary/20"
                        data-code-lookup-filter="total"
                      >
                    </div>
                  </th>
                  <th scope="col" class="px-4 py-3 text-left align-top" data-code-sort-header="issueDate">
                    <div class="flex flex-col gap-1">
                      <div class="flex items-center justify-between gap-1">
                        <span class="whitespace-nowrap">Data Emissão</span>
                        <div class="flex flex-col items-center justify-center gap-px text-gray-400">
                          <button
                            type="button"
                            class="flex h-3.5 w-3.5 items-center justify-center rounded border border-transparent text-gray-400 transition hover:text-primary focus:outline-none focus:ring-1 focus:ring-primary/40"
                            data-code-lookup-sort="issueDate"
                            data-sort-direction="asc"
                            aria-label="Ordenar crescente pela data de emissão"
                          >
                            <i class="fas fa-sort-up text-[9px]"></i>
                          </button>
                          <button
                            type="button"
                            class="flex h-3.5 w-3.5 items-center justify-center rounded border border-transparent text-gray-400 transition hover:text-primary focus:outline-none focus:ring-1 focus:ring-primary/40"
                            data-code-lookup-sort="issueDate"
                            data-sort-direction="desc"
                            aria-label="Ordenar decrescente pela data de emissão"
                          >
                            <i class="fas fa-sort-down text-[9px]"></i>
                          </button>
                        </div>
                      </div>
                      <input
                        type="text"
                        placeholder="Filtrar"
                        class="w-full rounded border border-gray-200 bg-white px-2 py-1 text-[10px] font-medium text-gray-600 placeholder:text-gray-400 focus:border-primary focus:outline-none focus:ring-2 focus:ring-primary/20"
                        data-code-lookup-filter="issueDate"
                      >
                    </div>
                  </th>
                  <th scope="col" class="px-4 py-3 text-left align-top" data-code-sort-header="entryDate">
                    <div class="flex flex-col gap-1">
                      <div class="flex items-center justify-between gap-1">
                        <span class="whitespace-nowrap">Data Entrada</span>
                        <div class="flex flex-col items-center justify-center gap-px text-gray-400">
                          <button
                            type="button"
                            class="flex h-3.5 w-3.5 items-center justify-center rounded border border-transparent text-gray-400 transition hover:text-primary focus:outline-none focus:ring-1 focus:ring-primary/40"
                            data-code-lookup-sort="entryDate"
                            data-sort-direction="asc"
                            aria-label="Ordenar crescente pela data de entrada"
                          >
                            <i class="fas fa-sort-up text-[9px]"></i>
                          </button>
                          <button
                            type="button"
                            class="flex h-3.5 w-3.5 items-center justify-center rounded border border-transparent text-gray-400 transition hover:text-primary focus:outline-none focus:ring-1 focus:ring-primary/40"
                            data-code-lookup-sort="entryDate"
                            data-sort-direction="desc"
                            aria-label="Ordenar decrescente pela data de entrada"
                          >
                            <i class="fas fa-sort-down text-[9px]"></i>
                          </button>
                        </div>
                      </div>
                      <input
                        type="text"
                        placeholder="Filtrar"
                        class="w-full rounded border border-gray-200 bg-white px-2 py-1 text-[10px] font-medium text-gray-600 placeholder:text-gray-400 focus:border-primary focus:outline-none focus:ring-2 focus:ring-primary/20"
                        data-code-lookup-filter="entryDate"
                      >
                    </div>
                  </th>
                  <th scope="col" class="px-4 py-3 text-left align-top" data-code-sort-header="status">
                    <div class="flex flex-col gap-1">
                      <div class="flex items-center justify-between gap-1">
                        <span class="whitespace-nowrap">Situação</span>
                        <div class="flex flex-col items-center justify-center gap-px text-gray-400">
                          <button
                            type="button"
                            class="flex h-3.5 w-3.5 items-center justify-center rounded border border-transparent text-gray-400 transition hover:text-primary focus:outline-none focus:ring-1 focus:ring-primary/40"
                            data-code-lookup-sort="status"
                            data-sort-direction="asc"
                            aria-label="Ordenar crescente pela situação"
                          >
                            <i class="fas fa-sort-up text-[9px]"></i>
                          </button>
                          <button
                            type="button"
                            class="flex h-3.5 w-3.5 items-center justify-center rounded border border-transparent text-gray-400 transition hover:text-primary focus:outline-none focus:ring-1 focus:ring-primary/40"
                            data-code-lookup-sort="status"
                            data-sort-direction="desc"
                            aria-label="Ordenar decrescente pela situação"
                          >
                            <i class="fas fa-sort-down text-[9px]"></i>
                          </button>
                        </div>
                      </div>
                      <input
                        type="text"
                        placeholder="Filtrar"
                        class="w-full rounded border border-gray-200 bg-white px-2 py-1 text-[10px] font-medium text-gray-600 placeholder:text-gray-400 focus:border-primary focus:outline-none focus:ring-2 focus:ring-primary/20"
                        data-code-lookup-filter="status"
                      >
                    </div>
                  </th>
                </tr>
              </thead>
              <tbody class="divide-y divide-gray-100 bg-white" data-code-table-body>
                <tr class="hidden" data-code-loading>
                  <td class="px-4 py-6 text-center text-gray-500" colspan="8">
                    <i class="fas fa-spinner-third fa-spin mr-2"></i>
                    Carregando notas cadastradas...
                  </td>
                </tr>
                <tr class="hidden" data-code-error>
                  <td class="px-4 py-6 text-center text-rose-600" colspan="8">
                    Não foi possível carregar as notas cadastradas para a empresa selecionada.
                  </td>
                </tr>
                <tr class="hidden" data-code-empty>
                  <td class="px-4 py-6 text-center text-gray-500" colspan="8">
                    Nenhuma nota encontrada para a empresa selecionada.
                  </td>
                </tr>
                <tr class="hidden" data-code-filtered-empty>
                  <td class="px-4 py-6 text-center text-gray-500" colspan="8">
                    Nenhuma nota corresponde aos filtros informados.
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>

        <footer class="flex flex-col gap-2 border-t border-gray-100 px-4 py-3 text-[11px] text-gray-500 sm:flex-row sm:items-center sm:justify-between">
          <p>
            Clique em uma linha para carregar a nota. Notas em rascunho aparecem como <span class="font-semibold text-amber-600">Cadastrada</span> e notas aprovadas como <span class="font-semibold text-emerald-600">Aprovada</span>.
          </p>
          <button
            type="button"
            class="inline-flex items-center gap-1.5 rounded-lg border border-gray-200 px-3 py-1.5 font-semibold text-gray-600 transition hover:bg-gray-50"
            data-close-code-modal
          >
            Fechar
          </button>
        </footer>
      </div>
    </div>
  </div>

  <div
    id="price-adjust-modal"
    class="fixed inset-0 z-[1000] hidden"
    aria-hidden="true"
  >
    <div class="absolute inset-0 bg-gray-900/60 backdrop-blur-sm" data-close-price-modal></div>
    <div class="relative mx-auto flex min-h-full w-full items-start justify-center px-3 py-6 sm:items-center">
      <div
        data-price-modal-card
        class="relative flex w-full max-w-[1400px] transform-gpu flex-col overflow-hidden rounded-2xl bg-white shadow-2xl transition-all duration-200 ease-out opacity-0 scale-95 text-[11px] leading-snug max-h-[90vh]"
      >
        <header class="flex flex-col gap-3 border-b border-gray-100 px-5 py-4 sm:flex-row sm:items-start sm:justify-between">
          <div class="space-y-1.5">
            <span class="inline-flex items-center gap-1.5 rounded-full bg-primary/10 px-2 py-0.5 text-[10px] font-semibold uppercase tracking-wide text-primary">
              <i class="fas fa-tags"></i>
              Ajuste de preços
            </span>
            <h2 class="text-lg font-semibold text-gray-900">Atualizar preços dos produtos da NF-e</h2>
            <p class="text-[10px] text-gray-600">
              Revise os custos calculados, defina markup ou mantenha o preço de venda atual antes de aplicar as alterações aos produtos selecionados.
            </p>
          </div>
          <div class="flex items-center gap-2">
            <button
              type="button"
              data-price-use-markup
              class="inline-flex items-center gap-1.5 rounded-full border border-gray-200 px-3 py-1 text-[10px] font-semibold text-gray-600 transition hover:bg-gray-50"
              aria-pressed="false"
            >
              <i class="fas fa-percentage"></i>
              Usar markup
            </button>
            <label class="inline-flex items-center gap-2 rounded-full border border-gray-200 px-3 py-1 text-[10px] font-semibold text-gray-600">
              <input type="checkbox" class="h-3.5 w-3.5 rounded border-gray-300 text-primary focus:ring-primary" data-price-maintain-markup>
              Manter markup
            </label>
            <button
              type="button"
              class="inline-flex items-center justify-center rounded-full border border-gray-200 p-2 text-gray-500 transition hover:bg-gray-50 hover:text-gray-700"
              data-close-price-modal
              aria-label="Fechar ajuste de preços"
            >
              <i class="fas fa-times"></i>
            </button>
          </div>
        </header>

        <div class="flex flex-col gap-4 px-5 pt-4">
          <div class="flex flex-col gap-3 rounded-xl border border-gray-100 bg-gray-50 p-3 sm:flex-row sm:items-end sm:justify-between">
            <div class="flex flex-wrap items-end gap-3">
              <div class="flex flex-col">
                <label for="price-adjust-cost-percent" class="text-[10px] font-semibold uppercase tracking-wide text-gray-500">Alterar custo %</label>
                <input
                  id="price-adjust-cost-percent"
                  data-price-cost-percent
                  type="text"
                  inputmode="decimal"
                  class="w-24 rounded border border-gray-200 bg-white px-2 py-1 text-right text-[11px] font-semibold text-gray-700 focus:border-primary focus:outline-none focus:ring-1 focus:ring-primary/30"
                  placeholder="0,00"
                />
              </div>
              <div class="flex items-center gap-2" role="group" aria-label="Modo de ajuste">
                <button
                  type="button"
                  class="inline-flex items-center gap-1 rounded border border-gray-200 bg-white px-3 py-1 text-[10px] font-semibold text-gray-600 transition hover:bg-gray-100"
                  data-price-cost-mode="add"
                  aria-pressed="true"
                >
                  Somar
                </button>
                <button
                  type="button"
                  class="inline-flex items-center gap-1 rounded border border-gray-200 bg-white px-3 py-1 text-[10px] font-semibold text-gray-600 transition hover:bg-gray-100"
                  data-price-cost-mode="subtract"
                  aria-pressed="false"
                >
                  Subtrair
                </button>
              </div>
              <button
                type="button"
                data-price-generate
                class="inline-flex items-center gap-1 rounded-lg bg-primary px-3 py-1.5 text-[10px] font-semibold text-white shadow-sm transition hover:bg-primary/90"
              >
                <i class="fas fa-calculator"></i>
                Gerar
              </button>
            </div>
            <p class="text-[10px] text-gray-500">
              Informe o percentual para atualizar o custo novo dos produtos selecionados. Percentual 0 restaura o valor calculado originalmente.
            </p>
          </div>
        </div>

        <div class="flex-1 overflow-hidden px-5 pb-4">
          <div class="flex h-full flex-col overflow-hidden rounded-xl border border-gray-100">
            <div class="overflow-auto">
              <table class="min-w-full divide-y divide-gray-100 text-[11px]" data-price-table>
                <thead class="bg-gray-50 text-[10px] uppercase tracking-wide text-gray-500">
                  <tr class="text-left">
                    <th class="px-3 py-2 text-center">
                      <input type="checkbox" class="h-3.5 w-3.5 rounded border-gray-300 text-primary focus:ring-primary" data-price-select-all />
                    </th>
                    <th class="px-3 py-2">Código</th>
                    <th class="px-3 py-2">Descrição</th>
                    <th class="px-3 py-2 text-right">Custo anterior</th>
                    <th class="px-3 py-2 text-right">Custo novo</th>
                    <th class="px-3 py-2 text-right">Markup (%)</th>
                    <th class="px-3 py-2 text-right">Venda novo</th>
                    <th class="px-3 py-2 text-right">Venda anterior</th>
                    <th class="px-3 py-2 text-right">Estoque entrada</th>
                    <th class="px-3 py-2 text-right">Estoque atual</th>
                    <th class="px-3 py-2 text-right">Estoque anterior</th>
                    <th class="px-3 py-2 text-center">Regra de imposto</th>
                  </tr>
                  <tr class="bg-white text-[10px] text-gray-500">
                    <th class="px-3 py-2"></th>
                    <th class="px-3 py-2">
                      <input type="text" data-price-filter="code" placeholder="Filtrar" class="w-full rounded border border-gray-200 bg-white px-2 py-1 text-[10px] text-gray-600 focus:border-primary focus:outline-none focus:ring-1 focus:ring-primary/20" />
                    </th>
                    <th class="px-3 py-2">
                      <input type="text" data-price-filter="description" placeholder="Filtrar" class="w-full rounded border border-gray-200 bg-white px-2 py-1 text-[10px] text-gray-600 focus:border-primary focus:outline-none focus:ring-1 focus:ring-primary/20" />
                    </th>
                    <th class="px-3 py-2">
                      <input type="text" data-price-filter="costPrevious" placeholder="Filtrar" class="w-full rounded border border-gray-200 bg-white px-2 py-1 text-[10px] text-gray-600 focus:border-primary focus:outline-none focus:ring-1 focus:ring-primary/20" />
                    </th>
                    <th class="px-3 py-2">
                      <input type="text" data-price-filter="costNew" placeholder="Filtrar" class="w-full rounded border border-gray-200 bg-white px-2 py-1 text-[10px] text-gray-600 focus:border-primary focus:outline-none focus:ring-1 focus:ring-primary/20" />
                    </th>
                    <th class="px-3 py-2">
                      <input type="text" data-price-filter="markup" placeholder="Filtrar" class="w-full rounded border border-gray-200 bg-white px-2 py-1 text-[10px] text-gray-600 focus:border-primary focus:outline-none focus:ring-1 focus:ring-primary/20" />
                    </th>
                    <th class="px-3 py-2">
                      <input type="text" data-price-filter="saleNew" placeholder="Filtrar" class="w-full rounded border border-gray-200 bg-white px-2 py-1 text-[10px] text-gray-600 focus:border-primary focus:outline-none focus:ring-1 focus:ring-primary/20" />
                    </th>
                    <th class="px-3 py-2">
                      <input type="text" data-price-filter="salePrevious" placeholder="Filtrar" class="w-full rounded border border-gray-200 bg-white px-2 py-1 text-[10px] text-gray-600 focus:border-primary focus:outline-none focus:ring-1 focus:ring-primary/20" />
                    </th>
                    <th class="px-3 py-2">
                      <input type="text" data-price-filter="entryStock" placeholder="Filtrar" class="w-full rounded border border-gray-200 bg-white px-2 py-1 text-[10px] text-gray-600 focus:border-primary focus:outline-none focus:ring-1 focus:ring-primary/20" />
                    </th>
                    <th class="px-3 py-2">
                      <input type="text" data-price-filter="currentStock" placeholder="Filtrar" class="w-full rounded border border-gray-200 bg-white px-2 py-1 text-[10px] text-gray-600 focus:border-primary focus:outline-none focus:ring-1 focus:ring-primary/20" />
                    </th>
                    <th class="px-3 py-2">
                      <input type="text" data-price-filter="previousStock" placeholder="Filtrar" class="w-full rounded border border-gray-200 bg-white px-2 py-1 text-[10px] text-gray-600 focus:border-primary focus:outline-none focus:ring-1 focus:ring-primary/20" />
                    </th>
                    <th class="px-3 py-2"></th>
                  </tr>
                </thead>
                <tbody class="divide-y divide-gray-100 bg-white" data-price-table-body>
                  <tr data-price-empty>
                    <td colspan="12" class="px-4 py-4 text-center text-[11px] text-gray-500">
                      Nenhum produto disponível para ajuste de preço.
                    </td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>

        <footer class="flex flex-col gap-3 border-t border-gray-100 px-5 py-4 sm:flex-row sm:items-center sm:justify-between">
          <div class="flex items-center gap-3 text-[11px]">
            <button type="button" data-price-mark-all class="inline-flex items-center gap-1 rounded border border-gray-200 px-3 py-1 font-semibold text-gray-600 transition hover:bg-gray-50">
              Marcar todos
            </button>
            <button type="button" data-price-unmark-all class="inline-flex items-center gap-1 rounded border border-gray-200 px-3 py-1 font-semibold text-gray-600 transition hover:bg-gray-50">
              Desmarcar todos
            </button>
          </div>
          <div class="flex items-center gap-2">
            <button
              type="button"
              data-price-cancel
              class="inline-flex items-center gap-2 rounded-lg border border-gray-200 px-4 py-2 text-[11px] font-semibold text-gray-600 transition hover:bg-gray-50"
            >
              Cancelar
            </button>
            <button
              type="button"
              data-price-update
              class="inline-flex items-center gap-2 rounded-lg bg-primary px-4 py-2 text-[11px] font-semibold text-white shadow-sm transition hover:bg-primary/90"
            >
              <i class="fas fa-rotate" data-price-update-icon></i>
              <span data-price-update-text>Atualizar</span>
            </button>
          </div>
        </footer>
      </div>
    </div>
  </div>

  <div id="import-xml-modal" class="fixed inset-0 z-[999] hidden">
    <div class="absolute inset-0 bg-gray-900/60 backdrop-blur-sm" data-close-import-modal></div>
    <div class="relative mx-auto flex min-h-full w-full items-start justify-center px-3 py-6 sm:items-center">
      <div data-import-modal-card class="relative flex w-full max-w-[1352px] transform-gpu flex-col overflow-hidden rounded-2xl bg-white shadow-2xl opacity-0 transition-all duration-200 ease-out scale-95 max-h-[90vh] min-h-0 text-[12px] leading-[1.35]">
        <header class="flex flex-col gap-2.5 border-b border-gray-100 px-4 py-3 sm:flex-row sm:items-start sm:justify-between">
          <div>
            <span class="inline-flex items-center gap-1.5 rounded-full bg-primary/10 px-2 py-0.5 text-[10px] font-semibold uppercase tracking-wide text-primary">
              <i class="fas fa-file-import"></i>
              Importação de NF-e
            </span>
            <h2 class="mt-1.5 text-lg font-semibold text-gray-900">Importar XML autorizado na SEFAZ</h2>
            <p class="mt-1 max-w-3xl text-[11px] text-gray-600">Utilize um XML emitido conforme o Manual de Orientação do Contribuinte 4.0 ou informe a chave de acesso válida (44 dígitos) para recuperar automaticamente dados oficiais da NF-e, NFC-e ou NFS-e.</p>
          </div>
          <button type="button" data-close-import-modal class="inline-flex items-center justify-center rounded-full border border-gray-200 p-1.5 text-gray-500 transition hover:bg-gray-50 hover:text-gray-700">
            <span class="sr-only">Fechar modal</span>
            <i class="fas fa-times"></i>
          </button>
        </header>

        <nav class="flex flex-wrap gap-2 border-b border-gray-100 px-4 pt-2.5">
          <button type="button" data-import-tab="pending" class="import-tab-button active">Notas Pendentes</button>
          <button type="button" data-import-tab="xml" class="import-tab-button">Importar XML</button>
        </nav>

        <div class="flex-1 overflow-y-auto px-4 py-4">
          <div data-import-tab-panel="pending" class="space-y-3.5">
            <section class="rounded-xl border border-gray-200 bg-white shadow-sm">
              <header class="flex flex-col gap-1.5 border-b border-gray-100 bg-gray-50 px-4 py-3">
                <h3 class="text-[12px] font-semibold text-gray-900">Consultar notas autorizadas</h3>
                <p class="text-[11px] text-gray-600">
                  Escolha a empresa e o período para gerar um DFe com as notas autorizadas na SEFAZ.
                </p>
              </header>
              <form class="flex flex-col gap-3 px-4 py-3 md:flex-row md:items-end md:gap-4" data-pending-filters>
                <div class="md:flex-1">
                  <label class="text-[10px] font-semibold uppercase tracking-wide text-gray-500" for="pending-company-select">
                    Empresa
                  </label>
                  <select
                    id="pending-company-select"
                    class="mt-1 w-full rounded-lg border border-gray-200 bg-white px-3 py-2 text-[11px] font-medium text-gray-700 focus:border-primary focus:outline-none focus:ring-2 focus:ring-primary/20"
                    data-pending-company
                  >
                    <option value="">Carregando empresas...</option>
                  </select>
                </div>
                <div class="flex flex-col gap-3 sm:flex-row sm:items-end md:w-auto md:flex-1 md:justify-end">
                  <div class="sm:w-44 md:w-48">
                    <label class="text-[10px] font-semibold uppercase tracking-wide text-gray-500" for="pending-period-start">
                      Período inicial
                    </label>
                    <input
                      type="date"
                      id="pending-period-start"
                      class="mt-1 w-full rounded-lg border border-gray-200 bg-white px-3 py-2 text-[11px] font-medium text-gray-700 focus:border-primary focus:outline-none focus:ring-2 focus:ring-primary/20"
                      data-pending-period-start
                    >
                  </div>
                  <div class="sm:w-44 md:w-48">
                    <label class="text-[10px] font-semibold uppercase tracking-wide text-gray-500" for="pending-period-end">
                      Período final
                    </label>
                    <input
                      type="date"
                      id="pending-period-end"
                      class="mt-1 w-full rounded-lg border border-gray-200 bg-white px-3 py-2 text-[11px] font-medium text-gray-700 focus:border-primary focus:outline-none focus:ring-2 focus:ring-primary/20"
                      data-pending-period-end
                    >
                  </div>
                  <div class="sm:self-end">
                    <button
                      type="button"
                      class="inline-flex w-full items-center justify-center gap-2 rounded-lg bg-primary px-4 py-2 text-[11px] font-semibold uppercase tracking-wide text-white shadow-sm transition hover:bg-primary/90 focus:outline-none focus:ring-2 focus:ring-primary/30"
                      data-pending-generate
                    >
                      <i class="fas fa-sync"></i>
                      Gerar
                    </button>
                  </div>
                </div>
              </form>
            </section>

            <section class="rounded-xl border border-gray-200 bg-white shadow-sm">
              <header class="flex flex-col gap-1 border-b border-gray-100 px-4 py-3 sm:flex-row sm:items-center sm:justify-between">
                <div>
                  <h4 class="text-[12px] font-semibold text-gray-900">Notas pendentes de tratamento</h4>
                  <p class="text-[11px] text-gray-600">
                    Utilize as ações para imprimir o DANFE ou enviar o XML direto para a aba de importação.
                  </p>
                </div>
                <div class="text-[10px] text-gray-500">
                  Situações possíveis: <span class="font-semibold text-amber-600">Pendente</span>,
                  <span class="font-semibold text-sky-700">Cadastrada</span> e
                  <span class="font-semibold text-emerald-600">Aprovada</span>.
                </div>
              </header>
              <div class="overflow-x-auto">
                <table class="min-w-full divide-y divide-gray-200 text-left text-[11px] text-gray-700" data-pending-table>
                  <thead class="bg-gray-50 text-[10px] uppercase tracking-wide text-gray-500">
                    <tr>
                      <th scope="col" class="whitespace-nowrap px-4 py-2 font-semibold">Danfe</th>
                      <th scope="col" class="whitespace-nowrap px-4 py-2 font-semibold">Entrada</th>
                      <th scope="col" class="whitespace-nowrap px-4 py-2 font-semibold">CNPJ Forn</th>
                      <th scope="col" class="whitespace-nowrap px-4 py-2 font-semibold">Nome Fornecedor</th>
                      <th scope="col" class="whitespace-nowrap px-4 py-2 font-semibold">Data Emissão</th>
                      <th scope="col" class="whitespace-nowrap px-4 py-2 font-semibold">Série</th>
                      <th scope="col" class="whitespace-nowrap px-4 py-2 font-semibold">N° NF</th>
                      <th scope="col" class="whitespace-nowrap px-4 py-2 font-semibold">Valor (R$)</th>
                      <th scope="col" class="whitespace-nowrap px-4 py-2 font-semibold">Chave de Acesso</th>
                      <th scope="col" class="whitespace-nowrap px-4 py-2 font-semibold">Situação SEFAZ</th>
                      <th scope="col" class="whitespace-nowrap px-4 py-2 font-semibold">Situação</th>
                    </tr>
                  </thead>
                  <tbody class="divide-y divide-gray-100 bg-white" data-pending-table-body>
                    <tr data-pending-loading class="hidden">
                      <td colspan="11" class="px-4 py-6 text-center text-gray-500">
                        <i class="fas fa-circle-notch fa-spin mr-2"></i>
                        Consultando notas autorizadas...
                      </td>
                    </tr>
                    <tr data-pending-error class="hidden">
                      <td colspan="11" class="px-4 py-6 text-center text-rose-600">
                        <span data-pending-error-message>Não foi possível carregar as notas autorizadas para o período informado.</span>
                      </td>
                    </tr>
                    <tr data-pending-empty>
                      <td colspan="11" class="px-4 py-6 text-center text-gray-500">
                        Informe os filtros acima e clique em <span class="font-semibold">Gerar</span> para listar as notas.
                      </td>
                    </tr>
                    <tr data-pending-row-template class="hidden">
                      <td class="whitespace-nowrap px-4 py-3 align-top">
                        <button
                          type="button"
                          class="inline-flex items-center gap-1.5 rounded-lg border border-gray-200 px-2.5 py-1.5 text-[10px] font-semibold text-gray-700 transition hover:bg-gray-50"
                          data-pending-danfe
                        >
                          <i class="fas fa-print"></i>
                          Imprimir
                        </button>
                      </td>
                      <td class="whitespace-nowrap px-4 py-3 align-top">
                        <button
                          type="button"
                          class="inline-flex items-center gap-1.5 rounded-lg bg-primary/10 px-2.5 py-1.5 text-[10px] font-semibold text-primary transition hover:bg-primary/20"
                          data-pending-import
                        >
                          <i class="fas fa-file-import"></i>
                          Enviar XML
                        </button>
                      </td>
                      <td class="whitespace-nowrap px-4 py-3 align-top font-mono text-[11px] text-gray-600" data-pending-supplier-document>
                        00.000.000/0000-00
                      </td>
                      <td class="px-4 py-3 align-top">
                        <div class="flex flex-col gap-1 text-[11px]">
                          <span class="font-semibold text-gray-800" data-pending-supplier-name>Fornecedor</span>
                          <button
                            type="button"
                            class="inline-flex items-center gap-1.5 self-start rounded-lg border border-dashed border-gray-300 px-2 py-1 text-[10px] font-medium text-gray-600 transition hover:border-primary/50 hover:text-primary"
                            data-pending-register-supplier
                          >
                            <i class="fas fa-user-plus"></i>
                            Cadastrar fornecedor
                          </button>
                        </div>
                      </td>
                      <td class="whitespace-nowrap px-4 py-3 align-top" data-pending-issue-date>00/00/0000</td>
                      <td class="whitespace-nowrap px-4 py-3 align-top" data-pending-series>0</td>
                      <td class="whitespace-nowrap px-4 py-3 align-top" data-pending-number>0</td>
                      <td class="whitespace-nowrap px-4 py-3 align-top" data-pending-total>0,00</td>
                      <td class="px-4 py-3 align-top font-mono text-[11px] text-gray-600 break-all" data-pending-access-key>
                        00000000000000000000000000000000000000000000
                      </td>
                      <td class="whitespace-nowrap px-4 py-3 align-top" data-pending-sefaz-status>
                        <span class="inline-flex items-center rounded-full bg-sky-100 px-2 py-0.5 text-[10px] font-semibold uppercase tracking-wide text-sky-700">
                          Cadastrada
                        </span>
                      </td>
                      <td class="whitespace-nowrap px-4 py-3 align-top" data-pending-status>
                        <span class="inline-flex items-center rounded-full bg-amber-100 px-2 py-0.5 text-[10px] font-semibold uppercase tracking-wide text-amber-700">
                          Pendente
                        </span>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </section>
          </div>

          <div data-import-tab-panel="xml" class="hidden space-y-3.5">
            <section class="rounded-xl border border-gray-200">
              <header class="flex flex-col gap-2.5 border-b border-gray-100 bg-gray-50 px-4 py-2.5 sm:flex-row sm:items-center sm:justify-between">
                <div class="space-y-0.5">
                  <h3 class="text-[12px] font-semibold text-gray-900">Selecione como deseja importar</h3>
                  <p class="text-[11px] text-gray-600">Utilize uma chave de acesso autorizada, ou faça upload de um XML oficial baixado no Portal Nacional.</p>
                </div>
                <div class="flex flex-col gap-0.5 text-[10px] text-gray-600 sm:flex-row sm:items-center">
                  <span class="inline-flex items-center gap-1 text-primary">
                    <i class="fas fa-shield-check text-[11px]"></i>
                    Validação XSD oficial
                  </span>
                  <span class="inline-flex items-center gap-1 text-emerald-600">
                    <i class="fas fa-file-code text-[11px]"></i>
                    NF-e 4.0 · NFC-e 4.0 · NFS-e ABRASF
                  </span>
                </div>
              </header>
              <div class="grid grid-cols-1 gap-2.5 p-3.5 lg:grid-cols-3">
                <div class="space-y-1.5">
                  <label class="text-[10px] font-semibold uppercase tracking-wide text-gray-500">Tipo de importação</label>
                  <div class="grid grid-cols-2 gap-1.5 text-[10px] font-medium text-gray-600">
                    <label class="inline-flex items-center gap-2 rounded-lg border border-primary/40 bg-primary/10 px-2.5 py-1.5">
                      <input type="radio" name="import-mode" value="access-key" class="h-3 w-3 text-primary focus:ring-primary/40" checked>
                      Chave de acesso
                    </label>
                    <label class="inline-flex items-center gap-2 rounded-lg border border-gray-200 px-2.5 py-1.5 transition hover:border-primary/40 hover:text-primary">
                      <input type="radio" name="import-mode" value="file" class="h-3 w-3 text-primary focus:ring-primary/40">
                      Arquivo XML
                    </label>
                  </div>
                </div>
                <div class="space-y-1.5" data-import-mode-panel="access-key">
                  <label for="import-access-key" class="text-[10px] font-semibold uppercase tracking-wide text-gray-500">Informe a chave</label>
                  <div class="flex gap-1.5">
                    <input type="text" id="import-access-key" maxlength="44" class="w-full rounded-lg border border-gray-200 px-3 py-1.5 text-[12px] focus:border-primary focus:ring-2 focus:ring-primary/20" placeholder="35240730290856000160550010000100011999999999">
                    <button type="button" class="inline-flex items-center gap-1.5 rounded-lg bg-primary px-3 py-1.5 text-[11px] font-semibold text-white shadow-sm transition hover:bg-primary/90">
                      <i class="fas fa-search"></i>
                      Consultar portal
                    </button>
                  </div>
                  <p class="text-[9px] text-gray-500">Consulta automática ao Portal Nacional da NF-e/NFC-e ou NFSe Nacional.</p>
                </div>
                <div class="space-y-1.5 hidden" data-import-mode-panel="file">
                  <label for="import-file-input" class="text-[10px] font-semibold uppercase tracking-wide text-gray-500">Envie o XML</label>
                  <label for="import-file-input" class="flex cursor-pointer flex-col items-center justify-center gap-2 rounded-lg border-2 border-dashed border-gray-300 px-3 py-5 text-center text-[10px] text-gray-500 transition hover:border-primary hover:text-primary">
                    <i class="fas fa-cloud-upload-alt text-lg"></i>
                    <span>Selecione ou arraste o arquivo XML autorizado</span>
                    <input id="import-file-input" type="file" accept=".xml" class="hidden">
                  </label>
                  <p class="text-[9px] text-gray-500">Validação com esquemas oficiais (XSD) e regras de negócio SEFAZ.</p>
                </div>
                <div class="space-y-1.5">
                  <label class="text-[10px] font-semibold uppercase tracking-wide text-gray-500">Ações rápidas</label>
                  <div class="grid grid-cols-1 gap-1.5 text-[10px] font-medium text-gray-600 sm:grid-cols-2">
                    <label class="inline-flex items-center gap-2 rounded-lg border border-gray-200 px-2.5 py-1.5 transition hover:border-primary/40 hover:text-primary">
                      <input type="checkbox" class="h-3 w-3 rounded border-gray-300 text-primary focus:ring-primary/40" checked>
                      Importar automaticamente produtos novos
                    </label>
                    <label class="inline-flex items-center gap-2 rounded-lg border border-gray-200 px-2.5 py-1.5 transition hover:border-primary/40 hover:text-primary">
                      <input type="checkbox" class="h-3 w-3 rounded border-gray-300 text-primary focus:ring-primary/40" checked>
                      Atualizar preços de compra existentes
                    </label>
                  </div>
                </div>
                <div class="lg:col-span-3 grid grid-cols-1 gap-1.5 pt-1 md:grid-cols-2 xl:grid-cols-3" data-import-supplier-insights>
                  <div data-file-feedback class="hidden h-full rounded-lg border px-3 py-2 text-[10px] font-medium leading-snug"></div>
                  <div data-import-supplier-status class="hidden h-full rounded-lg border px-3 py-2 text-[10px] text-gray-600 space-y-1.5 sm:space-y-0">
                    <div class="flex items-start gap-1.5">
                      <i data-supplier-status-icon class="fas fa-circle-info mt-0.5 text-[12px]"></i>
                      <div class="space-y-0.5">
                        <p data-supplier-message class="text-[11px] font-semibold text-gray-700 leading-snug"></p>
                        <p data-supplier-description class="text-[10px] text-gray-600 leading-snug"></p>
                      </div>
                    </div>
                    <div data-supplier-actions class="flex flex-wrap gap-1.5 sm:mt-0"></div>
                  </div>
                  <div data-import-supplier-summary class="hidden h-full rounded-lg border border-gray-200 bg-white px-3 py-2 text-[10px] text-gray-600 space-y-1.5">
                    <p data-supplier-summary-name class="text-[11px] font-semibold text-gray-700 leading-snug"></p>
                    <dl class="grid grid-cols-1 gap-1 sm:grid-cols-2 sm:gap-y-1.5">
                      <div>
                        <dt class="text-[9px] font-semibold uppercase tracking-wide text-gray-500">Documento</dt>
                        <dd data-supplier-summary-document class="text-gray-700 leading-snug"></dd>
                      </div>
                      <div>
                        <dt class="text-[9px] font-semibold uppercase tracking-wide text-gray-500">Inscrição Estadual</dt>
                        <dd data-supplier-summary-ie class="text-gray-700 leading-snug"></dd>
                      </div>
                      <div class="sm:col-span-2">
                        <dt class="text-[9px] font-semibold uppercase tracking-wide text-gray-500">Endereço</dt>
                        <dd data-supplier-summary-address class="text-gray-700 leading-snug"></dd>
                      </div>
                      <div class="sm:col-span-2">
                        <dt class="text-[9px] font-semibold uppercase tracking-wide text-gray-500">Contato</dt>
                        <dd data-supplier-summary-contact class="text-gray-700 leading-snug"></dd>
                      </div>
                    </dl>
                  </div>
                </div>
              </div>
            </section>

            <section class="rounded-xl border border-gray-200">
              <header class="flex flex-col gap-2.5 border-b border-gray-100 bg-gray-50 px-4 py-2.5 sm:flex-row sm:items-center sm:justify-between">
                <div class="space-y-0.5">
                  <h3 class="text-[12px] font-semibold text-gray-900">Dados da nota fiscal</h3>
                  <p class="text-[11px] text-gray-600">Resumo preenchido automaticamente conforme leiaute nacional 4.0 da NF-e.</p>
                </div>
                <div class="text-right text-[10px] text-gray-500">
                  <span class="block font-semibold text-gray-700">MOC 4.0</span>
                  <span>NT 2023.003 · NT 2023.004</span>
                </div>
              </header>
              <div class="grid grid-cols-1 gap-2.5 p-3.5 text-[10px] text-gray-600 lg:grid-cols-4">
                <div class="lg:col-span-2">
                  <label class="text-[10px] font-semibold uppercase tracking-wide text-gray-500">Emitente</label>
                  <div class="mt-1 rounded-lg border border-gray-200 bg-white px-3 py-1.5">
                    <p class="font-semibold text-gray-700" data-import-emitente-nome>Informe a chave ou importe o XML</p>
                    <p data-import-emitente-document>Documento não identificado</p>
                  </div>
                </div>
                <div>
                  <label class="text-[10px] font-semibold uppercase tracking-wide text-gray-500">Chave de acesso</label>
                  <div class="mt-1 rounded-lg border border-gray-200 bg-white px-3 py-1.5">
                    <p class="font-mono text-[12px] text-gray-700" data-import-access-key>------------------------------</p>
                    <p data-import-access-key-details>DV -- · Ambiente não identificado</p>
                  </div>
                </div>
                <div>
                  <label class="text-[10px] font-semibold uppercase tracking-wide text-gray-500">Protocolo</label>
                  <div class="mt-1 rounded-lg border border-gray-200 bg-white px-3 py-1.5">
                    <p data-import-protocol>Protocolo não informado</p>
                    <p data-import-protocol-received>Recebimento não disponível</p>
                  </div>
                </div>
                <div class="lg:col-span-4 grid grid-cols-1 gap-2.5 sm:grid-cols-2 xl:grid-cols-4">
                  <label class="space-y-1">
                    <span class="text-[10px] font-semibold uppercase tracking-wide text-gray-500">NF</span>
                    <input type="text" data-import-summary-field="nf-number" class="rounded-lg border border-gray-200 px-3 py-1.5 text-[12px] text-gray-700" value="" readonly>
                  </label>
                  <label class="space-y-1">
                    <span class="text-[10px] font-semibold uppercase tracking-wide text-gray-500">Série</span>
                    <input type="text" data-import-summary-field="nf-serie" class="rounded-lg border border-gray-200 px-3 py-1.5 text-[12px] text-gray-700" value="" readonly>
                  </label>
                  <label class="space-y-1">
                    <span class="text-[10px] font-semibold uppercase tracking-wide text-gray-500">Emissão</span>
                    <input type="text" data-import-summary-field="nf-emissao" class="rounded-lg border border-gray-200 px-3 py-1.5 text-[12px] text-gray-700" value="" readonly>
                  </label>
                  <label class="space-y-1">
                    <span class="text-[10px] font-semibold uppercase tracking-wide text-gray-500">Entrada</span>
                    <input type="text" data-import-summary-field="nf-entrada" class="rounded-lg border border-gray-200 px-3 py-1.5 text-[12px] text-gray-700" value="" readonly>
                  </label>
                </div>
                <div class="lg:col-span-2">
                  <label class="text-[10px] font-semibold uppercase tracking-wide text-gray-500">Fornecedor</label>
                  <div class="mt-1 rounded-lg border border-gray-200 bg-white px-3 py-1.5">
                    <p class="font-semibold text-gray-700" data-import-supplier-name>Fornecedor não localizado</p>
                    <p data-import-supplier-document>Documento não disponível</p>
                  </div>
                </div>
                <div>
                  <label class="text-[10px] font-semibold uppercase tracking-wide text-gray-500">Valor total</label>
                  <div class="mt-1 rounded-lg border border-gray-200 bg-white px-3 py-1.5 text-right text-gray-700">
                    <p class="text-sm font-semibold" data-import-total>R$ 0,00</p>
                    <p class="text-[10px] text-emerald-600" data-import-total-status>Aguardando importação do XML</p>
                  </div>
                </div>
                <div>
                  <label class="text-[10px] font-semibold uppercase tracking-wide text-gray-500">Destinatário</label>
                  <div class="mt-1 rounded-lg border border-gray-200 bg-white px-3 py-1.5">
                    <p class="font-semibold text-gray-700" data-import-destinatario-nome>Destinatário não identificado</p>
                    <p data-import-destinatario-document>Documento não disponível</p>
                  </div>
                </div>
                <div class="lg:col-span-4 grid grid-cols-1 gap-2.5 sm:grid-cols-2 xl:grid-cols-4">
                  <label class="space-y-1">
                    <span class="text-[10px] font-semibold uppercase tracking-wide text-gray-500">CFOP predominante</span>
                    <input type="text" data-import-summary-field="cfop" class="rounded-lg border border-gray-200 px-3 py-1.5 text-[12px] text-gray-700" value="" readonly>
                  </label>
                  <label class="space-y-1">
                    <span class="text-[10px] font-semibold uppercase tracking-wide text-gray-500">Natureza da operação</span>
                    <input type="text" data-import-summary-field="natureza" class="rounded-lg border border-gray-200 px-3 py-1.5 text-[12px] text-gray-700" value="" readonly>
                  </label>
                  <label class="space-y-1">
                    <span class="text-[10px] font-semibold uppercase tracking-wide text-gray-500">Modalidade frete</span>
                    <input type="text" data-import-summary-field="modalidade-frete" class="rounded-lg border border-gray-200 px-3 py-1.5 text-[12px] text-gray-700" value="" readonly>
                  </label>
                  <label class="space-y-1">
                    <span class="text-[10px] font-semibold uppercase tracking-wide text-gray-500">Indicador IE destinatário</span>
                    <input type="text" data-import-summary-field="indicador-ie" class="rounded-lg border border-gray-200 px-3 py-1.5 text-[12px] text-gray-700" value="" readonly>
                  </label>
                </div>
              </div>
            </section>

            <section class="rounded-xl border border-gray-200">
              <header class="flex flex-col gap-2.5 border-b border-gray-100 bg-gray-50 px-4 py-2.5 sm:flex-row sm:items-center sm:justify-between">
                <div class="space-y-0.5">
                  <h3 class="text-[12px] font-semibold text-gray-900">Produtos importados</h3>
                  <p class="text-[11px] text-gray-600">Itens conforme o XML, com tributos ICMS, ST, IPI, PIS e COFINS.</p>
                </div>
                <div class="flex flex-wrap items-center gap-1.5 text-[10px] text-gray-500">
                  <span class="inline-flex items-center gap-1 rounded-full border border-gray-200 px-2 py-0.5" data-import-xml-label>
                    <i class="fas fa-layer-group text-[11px]"></i>
                    <span data-import-xml-number>XML não importado</span>
                  </span>
                  <button
                    type="button"
                    class="inline-flex items-center gap-1 rounded-full border border-primary px-2 py-0.5 text-[10px] font-semibold text-primary transition hover:bg-primary/10 focus:outline-none focus:ring-2 focus:ring-primary/30 disabled:cursor-not-allowed disabled:opacity-60"
                    data-refresh-import-products
                  >
                    <i class="fas fa-rotate-right text-[11px]" data-refresh-import-products-icon></i>
                    Atualizar lista
                  </button>
                  <span class="inline-flex items-center gap-1 rounded-full border border-sky-200 bg-sky-50 px-2 py-0.5 text-sky-700" data-import-xml-validation>
                    <i class="fas fa-circle-info text-[11px]" data-import-xml-validation-icon></i>
                    <span data-import-xml-validation-text>Aguardando validação fiscal</span>
                  </span>
                </div>
              </header>
              <div class="overflow-x-auto">
                <table class="min-w-full table-auto divide-y divide-gray-200 text-[10px]" data-import-products-table>
                  <thead class="bg-gray-50 text-[9px] uppercase tracking-wide text-gray-500" data-import-products-head></thead>
                  <tbody class="divide-y divide-gray-200 bg-white" data-import-products-body></tbody>
                </table>
              </div>
            </section>
          </div>
          <footer class="flex flex-col gap-3 border-t border-gray-100 bg-gray-50 px-5 py-3 sm:flex-row sm:items-center sm:justify-end">
            <div class="flex w-full flex-col-reverse gap-2 sm:w-auto sm:flex-row sm:items-center">
              <button type="button" data-close-import-modal class="inline-flex items-center justify-center gap-1.5 rounded-lg border border-gray-200 px-4 py-2 text-sm font-semibold text-gray-600 transition hover:bg-gray-100">Cancelar</button>
              <button
                type="button"
                class="inline-flex items-center justify-center gap-1.5 rounded-lg bg-primary px-4 py-2 text-sm font-semibold text-white shadow-sm transition hover:bg-primary/90"
                data-confirm-import
              >
                <i class="fas fa-file-import" data-confirm-import-icon></i>
                <span data-confirm-import-text>Importar</span>
              </button>
            </div>
          </footer>
      </div>
    </div>
  </div>

  <div
    id="product-link-modal"
    class="fixed inset-0 z-[1050] hidden"
    aria-hidden="true"
  >
    <div
      class="absolute inset-0 bg-gray-900/60 backdrop-blur-sm"
      data-close-product-link-modal
      aria-label="Fechar seleção de produto"
    ></div>
    <div class="relative mx-auto flex min-h-full w-full items-center justify-center px-3 py-6">
      <div
        class="relative w-full max-w-xl transform-gpu overflow-hidden rounded-2xl bg-white shadow-xl transition-all duration-200 ease-out"
        data-product-link-card
      >
        <header class="flex items-start justify-between gap-3 border-b border-gray-100 px-5 py-4">
          <div class="space-y-1">
            <h3 class="text-lg font-semibold text-gray-900">Selecionar produto cadastrado</h3>
            <p class="text-[11px] text-gray-600">
              Escolha um produto existente para vincular ao item informado pelo fornecedor.
            </p>
          </div>
          <button
            type="button"
            class="inline-flex items-center justify-center rounded-full border border-gray-200 p-2 text-gray-500 transition hover:bg-gray-50 hover:text-gray-700"
            data-close-product-link-modal
            aria-label="Fechar seleção de produto"
          >
            <i class="fas fa-times"></i>
          </button>
        </header>
        <div class="space-y-4 px-5 py-4">
          <div class="space-y-2 rounded-xl border border-gray-100 bg-gray-50 px-4 py-3">
            <div class="space-y-1">
              <span class="text-[10px] font-semibold uppercase tracking-wide text-gray-500">Produto do fornecedor</span>
              <p class="text-[12px] font-semibold text-gray-800" data-product-link-item>—</p>
            </div>
            <div class="grid grid-cols-1 gap-2 sm:grid-cols-2">
              <div>
                <span class="text-[10px] font-semibold uppercase tracking-wide text-gray-500">Código no fornecedor</span>
                <p class="text-[11px] text-gray-700" data-product-link-code>—</p>
              </div>
              <div>
                <span class="text-[10px] font-semibold uppercase tracking-wide text-gray-500">Fornecedor ativo</span>
                <p class="text-[11px] text-gray-700" data-product-link-supplier>—</p>
              </div>
            </div>
          </div>
          <form class="flex flex-col gap-2 sm:flex-row sm:items-end" data-product-link-form>
            <div class="flex-1">
              <label class="mb-1 block text-[11px] font-semibold uppercase tracking-wide text-gray-600" for="product-link-search">
                Buscar produto cadastrado
              </label>
              <input
                id="product-link-search"
                type="search"
                placeholder="Digite código interno, nome ou GTIN"
                class="w-full rounded-lg border border-gray-200 px-3 py-2 text-sm text-gray-700 placeholder:text-gray-400 focus:border-primary focus:outline-none focus:ring-2 focus:ring-primary/20"
                data-product-link-search
                autocomplete="off"
              />
            </div>
            <button
              type="submit"
              class="inline-flex items-center justify-center gap-2 rounded-lg bg-primary px-4 py-2 text-sm font-semibold text-white shadow-sm transition hover:bg-primary/90 focus:outline-none focus:ring-2 focus:ring-primary/30"
            >
              <i class="fas fa-search"></i>
              Buscar
            </button>
          </form>
          <div class="space-y-2" data-product-link-results-wrapper>
            <div
              class="flex items-center gap-2 rounded-lg border border-sky-100 bg-sky-50 px-3 py-2 text-[11px] text-sky-700 hidden"
              data-product-link-loading
            >
              <i class="fas fa-circle-notch fa-spin text-sky-600"></i>
              <span data-product-link-loading-text>Buscando produtos cadastrados...</span>
            </div>
            <p class="hidden text-[11px] font-medium text-rose-600" data-product-link-error>
              Não foi possível buscar os produtos cadastrados. Tente novamente.
            </p>
            <p class="hidden text-[11px] text-gray-600" data-product-link-empty>
              Informe ao menos três caracteres para localizar um produto cadastrado.
            </p>
            <ul
              class="max-h-64 space-y-2 overflow-y-auto pr-1 text-sm"
              data-product-link-results
            ></ul>
          </div>
        </div>
        <footer class="flex justify-end gap-2 border-t border-gray-100 bg-gray-50 px-5 py-3">
          <button
            type="button"
            class="inline-flex items-center justify-center gap-1.5 rounded-lg border border-gray-200 px-3 py-2 text-sm font-semibold text-gray-600 transition hover:bg-gray-100"
            data-close-product-link-modal
          >
            Cancelar
          </button>
        </footer>
      </div>
    </div>
  </div>

  <div
    id="product-registration-iframe-modal"
    class="fixed inset-0 z-[1000] hidden"
    aria-hidden="true"
  >
    <div
      class="absolute inset-0 bg-gray-900/70 backdrop-blur-sm"
      data-close-product-modal
      aria-label="Fechar cadastro de produto"
    ></div>
    <div class="relative mx-auto flex min-h-full w-full items-start justify-center px-3 py-6 sm:items-center">
      <div
        class="relative flex w-full max-w-[1352px] transform-gpu flex-col overflow-hidden rounded-2xl bg-white shadow-2xl transition-all duration-200 ease-out max-h-[90vh] min-h-0 text-[12px] leading-[1.35]"
        data-product-frame-shell
      >
        <header class="flex flex-col gap-2 border-b border-gray-100 px-5 py-4 sm:flex-row sm:items-start sm:justify-between">
          <div class="space-y-1">
            <span
              data-product-modal-subtitle
              class="hidden text-[11px] font-semibold uppercase tracking-wide text-primary"
            ></span>
            <h3
              data-product-modal-title
              class="text-lg font-semibold text-gray-900"
            >
              Cadastro de produto
            </h3>
            <p
              data-product-modal-helper
              class="text-[11px] text-gray-600"
            >
              Os dados do XML autorizado foram enviados automaticamente. Revise e complete as informações antes de salvar.
            </p>
          </div>
          <button
            type="button"
            class="inline-flex items-center justify-center rounded-full border border-gray-200 p-2 text-gray-500 transition hover:bg-gray-50 hover:text-gray-700"
            data-close-product-modal
            aria-label="Fechar cadastro de produto"
          >
            <i class="fas fa-times"></i>
          </button>
        </header>
        <div class="flex-1 overflow-hidden">
          <div
            data-product-frame-loading
            class="flex h-full flex-col items-center justify-center gap-3 bg-gray-50 text-center text-[12px] text-gray-600"
          >
            <i class="fas fa-circle-notch fa-spin text-lg text-primary"></i>
            <p>
              Carregando cadastro de produto...
              <span class="block text-[11px] text-gray-500">Isso pode levar alguns instantes.</span>
            </p>
          </div>
          <iframe
            data-product-frame
            title="Cadastro de produto"
            class="hidden h-full w-full border-0"
            allow="clipboard-write"
          ></iframe>
        </div>
      </div>
    </div>
  </div>

  <div id="admin-footer-placeholder"></div>

  <script>var basePath = '../../';</script>
  <script src="../../scripts/core/config.js"></script>
  <script src="../../scripts/core/ui.js"></script>
  <script src="../../scripts/core/main.js"></script>
  <script src="../../scripts/admin/admin.js"></script>
  <script src="/scripts/common/modal-bridge.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', function () {
      const tabButtons = document.querySelectorAll('.tab-button');
      const tabPanels = document.querySelectorAll('.tab-panel');

      function activateTab(tabId) {
        tabButtons.forEach((button) => {
          const isActive = button.dataset.tab === tabId;
          button.classList.toggle('active', isActive);
          button.classList.toggle('bg-primary/10', isActive);
          button.classList.toggle('text-primary', isActive);
          button.classList.toggle('border', true);
          button.classList.toggle('border-transparent', isActive);
          button.classList.toggle('border-gray-200', !isActive);
          button.classList.toggle('text-gray-600', !isActive);
        });

        tabPanels.forEach((panel) => {
          panel.classList.toggle('hidden', panel.dataset.tabPanel !== tabId);
        });
      }

      tabButtons.forEach((button) => {
        button.classList.add('inline-flex', 'items-center', 'gap-2', 'rounded-lg', 'px-3', 'py-2', 'text-xs', 'font-semibold', 'transition');
        if (!button.classList.contains('active')) {
          button.classList.add('text-gray-600', 'border', 'border-gray-200');
        } else {
          button.classList.add('bg-primary/10', 'text-primary', 'border', 'border-transparent');
        }

        button.addEventListener('click', () => {
          activateTab(button.dataset.tab);
        });
      });

      const codeLookupModal = document.getElementById('nfe-code-lookup-modal');
      const codeLookupModalCard = codeLookupModal?.querySelector('[data-code-modal-card]') || null;
      const codeLookupCloseTriggers = codeLookupModal
        ? codeLookupModal.querySelectorAll('[data-close-code-modal]')
        : [];
      const codeLookupCompanySelect = codeLookupModal?.querySelector('[data-code-company]') || null;
      const codeLookupTableBody = codeLookupModal?.querySelector('[data-code-table-body]') || null;
      const codeLookupEmptyRow = codeLookupModal?.querySelector('[data-code-empty]') || null;
      const codeLookupFilteredEmptyRow = codeLookupModal?.querySelector('[data-code-filtered-empty]') || null;
      const codeLookupLoadingRow = codeLookupModal?.querySelector('[data-code-loading]') || null;
      const codeLookupErrorRow = codeLookupModal?.querySelector('[data-code-error]') || null;
      const codeLookupErrorCell = codeLookupErrorRow?.querySelector('td') || null;

      const importModal = document.getElementById('import-xml-modal');
      if (importModal) {
        const importModalCard = importModal.querySelector('[data-import-modal-card]');
        const openImportModalButtons = document.querySelectorAll('[data-open-import-modal]');
        const closeImportModalButtons = importModal.querySelectorAll('[data-close-import-modal]');
        const importTabButtons = importModal.querySelectorAll('.import-tab-button');
        const importTabPanels = importModal.querySelectorAll('[data-import-tab-panel]');
        const importModeRadios = importModal.querySelectorAll('input[name="import-mode"]');
        const importModePanels = importModal.querySelectorAll('[data-import-mode-panel]');
        const pendingCompanySelect = importModal.querySelector('[data-pending-company]') || null;
        const pendingPeriodStartInput = importModal.querySelector('[data-pending-period-start]') || null;
        const pendingPeriodEndInput = importModal.querySelector('[data-pending-period-end]') || null;
        const pendingFiltersForm = importModal.querySelector('[data-pending-filters]') || null;
        const pendingGenerateButton = importModal.querySelector('[data-pending-generate]') || null;
        const pendingTable = importModal.querySelector('[data-pending-table]') || null;
        const pendingTableBody = importModal.querySelector('[data-pending-table-body]') || null;
        const pendingLoadingRow = importModal.querySelector('[data-pending-loading]') || null;
        const pendingErrorRow = importModal.querySelector('[data-pending-error]') || null;
        const pendingErrorMessage = pendingErrorRow
          ? pendingErrorRow.querySelector('[data-pending-error-message]')
          : null;
        const pendingEmptyRow = importModal.querySelector('[data-pending-empty]') || null;
        const pendingEmptyCell = pendingEmptyRow ? pendingEmptyRow.querySelector('td') : null;
        const pendingRowTemplate = importModal.querySelector('[data-pending-row-template]') || null;
        const defaultPendingEmptyContent = pendingEmptyCell ? pendingEmptyCell.innerHTML : '';
        const defaultPendingErrorText = pendingErrorMessage ? pendingErrorMessage.textContent || '' : '';
        let pendingDocumentsAbortController = null;
        let pendingHasPerformedSearch = false;
        const importFilePanel = importModal.querySelector('[data-import-mode-panel="file"]');
        const importFileInput = document.getElementById('import-file-input');
        const importFileFeedback = importModal.querySelector('[data-file-feedback]');
        const importSupplierStatus = importModal.querySelector('[data-import-supplier-status]');
        const importSupplierMessage = importSupplierStatus ? importSupplierStatus.querySelector('[data-supplier-message]') : null;
        const importSupplierDescription = importSupplierStatus
          ? importSupplierStatus.querySelector('[data-supplier-description]')
          : null;
        const importSupplierActions = importSupplierStatus
          ? importSupplierStatus.querySelector('[data-supplier-actions]')
          : null;
        const importSupplierIcon = importSupplierStatus
          ? importSupplierStatus.querySelector('[data-supplier-status-icon]')
          : null;
        const importSupplierSummary = importModal.querySelector('[data-import-supplier-summary]');
        const importSupplierSummaryName = importSupplierSummary
          ? importSupplierSummary.querySelector('[data-supplier-summary-name]')
          : null;
        const importSupplierSummaryDocument = importSupplierSummary
          ? importSupplierSummary.querySelector('[data-supplier-summary-document]')
          : null;
        const importSupplierSummaryIe = importSupplierSummary
          ? importSupplierSummary.querySelector('[data-supplier-summary-ie]')
          : null;
        const importSupplierSummaryAddress = importSupplierSummary
          ? importSupplierSummary.querySelector('[data-supplier-summary-address]')
          : null;
        const importSupplierSummaryContact = importSupplierSummary
          ? importSupplierSummary.querySelector('[data-supplier-summary-contact]')
          : null;
        const importSummaryEmitenteName = importModal.querySelector('[data-import-emitente-nome]');
        const importSummaryEmitenteDocument = importModal.querySelector('[data-import-emitente-document]');
        const importSummaryAccessKey = importModal.querySelector('[data-import-access-key]');
        const importSummaryAccessKeyDetails = importModal.querySelector('[data-import-access-key-details]');
        const importSummaryProtocol = importModal.querySelector('[data-import-protocol]');
        const importSummaryProtocolReceived = importModal.querySelector('[data-import-protocol-received]');
        const importSummarySupplierName = importModal.querySelector('[data-import-supplier-name]');
        const importSummarySupplierDocument = importModal.querySelector('[data-import-supplier-document]');
        const importSummaryTotal = importModal.querySelector('[data-import-total]');
        const importSummaryTotalStatus = importModal.querySelector('[data-import-total-status]');
        const importSummaryDestName = importModal.querySelector('[data-import-destinatario-nome]');
        const importSummaryDestDocument = importModal.querySelector('[data-import-destinatario-document]');
        const importXmlLabelWrapper = importModal.querySelector('[data-import-xml-label]');
        const importXmlNumber = importModal.querySelector('[data-import-xml-number]');
        const importXmlValidationBadge = importModal.querySelector('[data-import-xml-validation]');
        const importXmlValidationText = importModal.querySelector('[data-import-xml-validation-text]');
        const importXmlValidationIcon = importModal.querySelector('[data-import-xml-validation-icon]');
        const refreshImportedProductsButton = importModal.querySelector('[data-refresh-import-products]');
        const refreshImportedProductsIcon = refreshImportedProductsButton
          ? refreshImportedProductsButton.querySelector('[data-refresh-import-products-icon]')
          : null;
        const importProductsTableHead = importModal.querySelector('[data-import-products-head]');
        const importProductsTableBody = importModal.querySelector('[data-import-products-body]');
        const importSummaryFields = Array.from(importModal.querySelectorAll('[data-import-summary-field]')).reduce(
          (accumulator, element) => {
            accumulator[element.dataset.importSummaryField] = element;
            return accumulator;
          },
          {}
        );
        const productLinkModal = document.getElementById('product-link-modal');
        const productLinkCard = productLinkModal?.querySelector('[data-product-link-card]') || null;
        const productLinkForm = productLinkModal?.querySelector('[data-product-link-form]') || null;
        const productLinkSearchInput = productLinkModal?.querySelector('[data-product-link-search]') || null;
        const productLinkResults = productLinkModal?.querySelector('[data-product-link-results]') || null;
        const productLinkResultsWrapper = productLinkModal?.querySelector('[data-product-link-results-wrapper]') || null;
        const productLinkLoading = productLinkModal?.querySelector('[data-product-link-loading]') || null;
        const productLinkLoadingText = productLinkModal?.querySelector('[data-product-link-loading-text]') || null;
        const productLinkError = productLinkModal?.querySelector('[data-product-link-error]') || null;
        const productLinkEmpty = productLinkModal?.querySelector('[data-product-link-empty]') || null;
        const productLinkSupplierLabel = productLinkModal?.querySelector('[data-product-link-supplier]') || null;
        const productLinkItemLabel = productLinkModal?.querySelector('[data-product-link-item]') || null;
        const productLinkCodeLabel = productLinkModal?.querySelector('[data-product-link-code]') || null;
        const productLinkCloseTriggers = productLinkModal
          ? productLinkModal.querySelectorAll('[data-close-product-link-modal]')
          : [];
        const productIframeModal = document.getElementById('product-registration-iframe-modal');
        const productIframe = productIframeModal?.querySelector('[data-product-frame]') || null;
        const productIframeLoading =
          productIframeModal?.querySelector('[data-product-frame-loading]') || null;
        const productIframeShell =
          productIframeModal?.querySelector('[data-product-frame-shell]') || null;
        const productIframeTitle = productIframeModal?.querySelector('[data-product-modal-title]') || null;
        const productIframeSubtitle = productIframeModal?.querySelector('[data-product-modal-subtitle]') || null;
        const productIframeHelper = productIframeModal?.querySelector('[data-product-modal-helper]') || null;
        const productIframeCloseTriggers = productIframeModal
          ? productIframeModal.querySelectorAll('[data-close-product-modal]')
          : [];
        const supplierSelect = document.getElementById('nfe-supplier');
        const companySelect = document.getElementById('company');
        const nfeCodeInput = document.getElementById('nfe-code');
        const nfeNumberInput = document.getElementById('nfe-number');
        const nfeSeriesInput = document.getElementById('nfe-series');
        const issueDateInput = document.getElementById('issue-date');
        const entryDateInput = document.getElementById('entry-date');
        const nfeModelSelect = document.getElementById('nfe-model');
        const nfeTypeSelect = document.getElementById('nfe-type');
        const depositSelect = document.getElementById('deposit');
        const importAccessKeyInput = document.getElementById('import-access-key');
        const accessKeyInput = document.getElementById('access-key');
        const totalAmountDisplay = document.querySelector('[data-nfe-total]');
        const supplierCnpjInput = document.getElementById('supplier-cnpj');
        const supplierIeInput = document.getElementById('supplier-ie');
        const supplierUfSelect = document.getElementById('supplier-uf');
        const supplierEmailInput = document.getElementById('supplier-email');
        const supplierAddressInput = document.getElementById('supplier-address');
        const transportCnpjInput = document.getElementById('transportadora-cnpj');
        const transportIeInput = document.getElementById('transportadora-ie');
        const transportUfSelect = document.getElementById('transportadora-uf');
        const transportPlateInput = document.getElementById('transportadora-placa');
        const transportPlateUfSelect = document.getElementById('transportadora-uf-placa');
        const transportNameInput = document.getElementById('transportadora-razao');
        const weightGrossInput = document.getElementById('peso-bruto');
        const weightNetInput = document.getElementById('peso-liquido');
        const freightModeSelect = document.getElementById('modalidade-frete');
        const totalsProductsInput = document.getElementById('valor-produtos');
        const totalsBonificationInput = document.getElementById('valor-bonificacao');
        const totalsIcmsBaseInput = document.getElementById('base-icms');
        const totalsIcmsValueInput = document.getElementById('valor-icms');
        const totalsIcmsStInput = document.getElementById('icms-st');
        const totalsFcpStInput = document.getElementById('valor-fcp-st');
        const totalsDiscountInput = document.getElementById('desconto');
        const totalsOtherInput = document.getElementById('outras-despesas');
        const totalsFreightInput = document.getElementById('valor-frete');
        const totalsIpiInput = document.getElementById('valor-ipi');
        const totalsUnitDiscountInput = document.getElementById('desconto-unitario');
        const totalsInsuranceInput = document.getElementById('valor-seguro');
        const totalsDollarInput = document.getElementById('valor-dolar');
        const duplicataEmissionInput = document.getElementById('duplicata-data-emissao');
        const duplicataCountInput = document.getElementById('parcelas');
        const duplicataFirstDueInput = document.getElementById('vencimento-inicial');
        const duplicataDaysInput = document.getElementById('dias');
        const duplicataInitialDaysInput = document.getElementById('dias-vencimento');
        const duplicataDaysTypeSelect = document.getElementById('tipo-dias');
        const duplicataGenerateButton = document.querySelector('[data-nfe-duplicatas-generate]');
        const bankAccountSelect = document.getElementById('conta-corrente');
        const accountingAccountInput = document.getElementById('conta-contabil');
        const paymentConditionInput = document.getElementById('condicao-pagamento');
        const paymentFormInput = document.getElementById('forma-pagamento');
        const observationInput = document.getElementById('observacao');
        const complementaryInfoInput = document.getElementById('informacoes-complementares');
        const clearImportButton = document.querySelector('[data-clear-import]');
        const deleteEntryButton = document.querySelector('[data-delete-entry]');
        const saveDraftButton = document.querySelector('[data-save-draft]');
        const registerEntryButton = document.querySelector('[data-register-entry]');
        const registerEntryIcon = registerEntryButton?.querySelector('[data-register-entry-icon]') || null;
        const registerEntryText = registerEntryButton?.querySelector('[data-register-entry-text]') || null;
        const deleteEntryIcon = deleteEntryButton?.querySelector('[data-delete-entry-icon]') || null;
        const deleteEntryText = deleteEntryButton?.querySelector('[data-delete-entry-text]') || null;
        const priceAdjustmentButton = document.querySelector('[data-open-price-modal]');
        const priceModal = document.getElementById('price-adjust-modal');
        const priceModalCard = priceModal?.querySelector('[data-price-modal-card]') || null;
        const priceModalCloseButtons = priceModal ? priceModal.querySelectorAll('[data-close-price-modal]') : [];
        const priceUseMarkupButton = priceModal?.querySelector('[data-price-use-markup]') || null;
        const priceMaintainMarkupToggle = priceModal?.querySelector('[data-price-maintain-markup]') || null;
        const priceCostPercentInput = priceModal?.querySelector('[data-price-cost-percent]') || null;
        const priceCostModeButtons = priceModal ? priceModal.querySelectorAll('[data-price-cost-mode]') : [];
        const priceGenerateButton = priceModal?.querySelector('[data-price-generate]') || null;
        const priceSelectAllCheckbox = priceModal?.querySelector('[data-price-select-all]') || null;
        const priceTableBody = priceModal?.querySelector('[data-price-table-body]') || null;
        const priceEmptyRow = priceModal?.querySelector('[data-price-empty]') || null;
        const priceMarkAllButton = priceModal?.querySelector('[data-price-mark-all]') || null;
        const priceUnmarkAllButton = priceModal?.querySelector('[data-price-unmark-all]') || null;
        const priceCancelButton = priceModal?.querySelector('[data-price-cancel]') || null;
        const priceUpdateButton = priceModal?.querySelector('[data-price-update]') || null;
        const priceUpdateButtonIcon = priceUpdateButton?.querySelector('[data-price-update-icon]') || priceUpdateButton?.querySelector('i') || null;
        const priceUpdateButtonText = priceUpdateButton?.querySelector('[data-price-update-text]') || null;
        const priceFilterInputs = new Map();
        let updatePriceButtonAvailability = () => {};
        let closePriceAdjustmentModal = () => {};
        const priceAdjustmentState = {
          items: [],
          filters: {},
          usarMarkup: false,
          maintainMarkup: false,
          costMode: 'add',
          isOpen: false,
          isProcessing: false,
        };
        const statusBadge = document.querySelector('[data-nfe-status-badge]');
        const documentsTableBody = document.querySelector('[data-nfe-documents-body]');
        const documentsEmptyRow = document.querySelector('[data-nfe-documents-empty]');
        const mainProductsTableBody = document.querySelector('[data-nfe-products-body]');
        const mainProductsEmptyRow = document.querySelector('[data-nfe-products-empty]');
        const mainProductsFilteredEmptyRow = document.querySelector('[data-nfe-products-filtered-empty]');
        const mainProductTableState = { items: [], filters: {}, sort: { key: '', direction: 'asc' } };
        const mainProductTableFilterInputs = new Map();
        const mainProductSortButtons = new Map();
        const mainProductSortHeaders = new Map();
        const duplicatasTableBody = document.querySelector('[data-nfe-duplicatas-body]');
        const duplicatasEmptyRow = document.querySelector('[data-nfe-duplicatas-empty]');
        const MODAL_FOCUSABLE_SELECTORS =
          'a[href], button:not([disabled]), textarea, input, select, [tabindex]:not([tabindex="-1"])';
        let previouslyFocusedElement = null;
        let productModalPreviousFocus = null;
        let productLinkPreviousFocus = null;
        let productLinkActiveItem = null;
        let productLinkSearchAbortController = null;
        let productLinkIsLinking = false;
        const codeLookupTableState = { items: [], filters: {}, sort: { key: '', direction: 'asc' } };
        const codeLookupFilterInputs = new Map();
        const codeLookupSortButtons = new Map();
        const codeLookupSortHeaders = new Map();
        const codeLookupCache = new Map();
        let codeLookupPreviousFocus = null;
        let codeLookupIsOpen = false;
        let codeLookupIsLoading = false;
        let codeLookupLastError = null;
        let codeLookupLastCompanyId = '';
        let isLoadingDraftDetails = false;
        const apiBaseUrl =
          typeof API_CONFIG !== 'undefined' && API_CONFIG?.BASE_URL
            ? API_CONFIG.BASE_URL.replace(/\/+$/, '')
            : '/api';
        const pendingDocumentsEndpoint = `${apiBaseUrl}/purchase/nfe/drafts/dfe`;
        const companiesEndpoint = `${apiBaseUrl}/stores`;
        const suppliersEndpoint = `${apiBaseUrl}/suppliers`;
        const bankAccountsEndpoint = `${apiBaseUrl}/bank-accounts`;
        const depositsEndpoint = `${apiBaseUrl}/deposits`;
        const nfeDraftsEndpoint = `${apiBaseUrl}/purchase/nfe/drafts`;

        const notify = (message, type = 'info') => {
          if (typeof window.showToast === 'function') {
            window.showToast(message, type);
          } else if (type === 'error') {
            console.error(message);
          } else {
            console.log(message);
          }
        };

        const handleAuthError = () => {
          notify('Sessão expirada. Faça login novamente para continuar.', 'error');
        };

        const getToken = () => {
          try {
            const raw = localStorage.getItem('loggedInUser');
            if (!raw) return '';
            const parsed = JSON.parse(raw);
            return parsed?.token || '';
          } catch (error) {
            console.warn('Não foi possível recuperar o token de autenticação.', error);
            return '';
          }
        };

        const buildAuthHeaders = () => {
          const headers = new Headers({ Accept: 'application/json' });
          const token = getToken();
          if (token) {
            headers.set('Authorization', `Bearer ${token}`);
          }
          return headers;
        };

        const supplierRegistry = {
          loaded: false,
          loadingPromise: null,
          byDocument: new Map(),
          lastLoadedAt: 0,
          error: null,
        };

        const companyRegistry = {
          cache: [],
          loading: null,
          index: new Map(),
          lastLoadedAt: 0,
          error: null,
        };

        const bankAccountsRegistry = {
          cache: new Map(),
          loading: new Map(),
          index: new Map(),
          lastLoadedAt: 0,
          error: null,
        };

        const depositRegistry = {
          cache: new Map(),
          loading: new Map(),
          index: new Map(),
          lastLoadedAt: 0,
          error: null,
        };

        let lastSupplierData = null;
        let lastSupplierRecord = null;
        let pendingSupplierId = '';
        let pendingSupplierDocument = '';
        let lastNfeData = null;
        const IMPORT_CONTEXT_FULL = 'full';
        const IMPORT_CONTEXT_BONUS = 'bonus';
        let importModalContext = IMPORT_CONTEXT_FULL;
        let pendingBonusData = null;
        let pendingCompanyId = '';
        let pendingCompanyDocumentDigits = '';
        let pendingBankAccountId = '';
        let pendingDepositId = '';
        let currentDraftId = '';
        let currentDraftCode = '';
        let currentDraftStatus = 'draft';
        let isSavingDraft = false;
        let isApprovingDraft = false;
        let isDeletingDraft = false;
        let isFormLocked = false;
        let updateStatusBadgeDisplay = () => {};
        let updateDeleteButtonState = () => {};
        const PRODUCT_DRAFT_STORAGE_KEY = 'nfeImportProductDraft';
        const productLookupCache = new Map();
        const productLookupPromises = new Map();
        const supplierReferenceLookupCache = new Map();
        const supplierReferenceLookupPromises = new Map();
        let productValidationSequence = 0;
        const productSupplierLinkCache = new Set();
        const productSupplierLinkPromises = new Map();
        const supplierFactorUpdatePromises = new Map();
        const FACTOR_COMPARISON_TOLERANCE = 0.0005;
        let supplierLinkErrorNotified = false;
        let isRefreshingImportedProducts = false;

        const STATUS_CLASS_MAP = {
          success: ['border-emerald-200', 'bg-emerald-50', 'text-emerald-800'],
          warning: ['border-amber-200', 'bg-amber-50', 'text-amber-800'],
          error: ['border-rose-200', 'bg-rose-50', 'text-rose-800'],
          info: ['border-sky-200', 'bg-sky-50', 'text-sky-800'],
        };

        const STATUS_ICONS = {
          success: 'fas fa-circle-check',
          warning: 'fas fa-triangle-exclamation',
          error: 'fas fa-circle-exclamation',
          info: 'fas fa-circle-info',
        };

        const VALIDATION_BADGE_STYLES = {
          success: ['border-emerald-200', 'bg-emerald-50', 'text-emerald-700'],
          warning: ['border-amber-200', 'bg-amber-50', 'text-amber-700'],
          error: ['border-rose-200', 'bg-rose-50', 'text-rose-700'],
          info: ['border-sky-200', 'bg-sky-50', 'text-sky-700'],
        };

        const VALIDATION_ICONS = {
          success: 'fas fa-check',
          warning: 'fas fa-triangle-exclamation',
          error: 'fas fa-circle-exclamation',
          info: 'fas fa-circle-info',
        };

        const ALL_STATUS_CLASSES = Array.from(new Set(Object.values(STATUS_CLASS_MAP).flat()));
        const ALL_VALIDATION_CLASSES = Array.from(new Set(Object.values(VALIDATION_BADGE_STYLES).flat()));

        const SUPPLIER_ACTION_VARIANTS = {
          primary: [
            'border-primary',
            'bg-primary',
            'text-white',
            'hover:bg-primary/90',
            'focus:ring-primary/40',
          ],
          secondary: [
            'border-gray-200',
            'text-gray-700',
            'hover:border-primary/40',
            'hover:text-primary',
            'focus:ring-primary/20',
          ],
        };

        const SUPPLIER_STATUS_LAYOUT_CLASSES = [
          'flex',
          'flex-col',
          'sm:flex',
          'sm:flex-row',
          'sm:items-start',
          'sm:justify-between',
          'sm:gap-3',
        ];

        const toggleSupplierStatusLayout = (isActive) => {
          if (!importSupplierStatus) return;
          if (isActive) {
            importSupplierStatus.classList.add(...SUPPLIER_STATUS_LAYOUT_CLASSES);
          } else {
            importSupplierStatus.classList.remove(...SUPPLIER_STATUS_LAYOUT_CLASSES);
          }
        };

        const digitsOnly = (value) => String(value ?? '').replace(/\D+/g, '');

        const resetProductLookupCaches = () => {
          productLookupCache.clear();
          productLookupPromises.clear();
          supplierReferenceLookupCache.clear();
          supplierReferenceLookupPromises.clear();
        };

        const setRefreshImportedProductsButtonState = (isLoading) => {
          if (!refreshImportedProductsButton) return;
          const shouldDisable = Boolean(isLoading);
          refreshImportedProductsButton.disabled = shouldDisable;
          refreshImportedProductsButton.classList.toggle('opacity-60', shouldDisable);
          refreshImportedProductsButton.classList.toggle('cursor-not-allowed', shouldDisable);
          if (shouldDisable) {
            refreshImportedProductsButton.setAttribute('aria-busy', 'true');
          } else {
            refreshImportedProductsButton.removeAttribute('aria-busy');
          }
          if (refreshImportedProductsIcon) {
            refreshImportedProductsIcon.classList.toggle('fa-spin', shouldDisable);
          }
        };

        const refreshImportedProductsList = async () => {
          if (isRefreshingImportedProducts) {
            return;
          }
          const hasItems = Array.isArray(lastNfeData?.items) && lastNfeData.items.length > 0;
          if (!hasItems) {
            notify('Importe um XML autorizado para atualizar a lista de produtos.', 'warning');
            return;
          }

          isRefreshingImportedProducts = true;
          setRefreshImportedProductsButtonState(true);

          const itemsBeforeRefresh = Array.isArray(lastNfeData.items) ? lastNfeData.items : [];
          const previousUnmatchedCount = itemsBeforeRefresh.filter(
            (item) => item?.validationStatus === 'not-found'
          ).length;

          try {
            resetProductLookupCaches();
            await validateImportedProducts(lastNfeData);

            const updatedItems = Array.isArray(lastNfeData?.items) ? lastNfeData.items : [];
            const currentUnmatchedCount = updatedItems.filter(
              (item) => item?.validationStatus === 'not-found'
            ).length;

            const successMessage =
              currentUnmatchedCount < previousUnmatchedCount
                ? 'Lista atualizada e novos produtos foram vinculados.'
                : 'Lista de produtos importados atualizada.';
            notify(successMessage, 'success');
          } catch (error) {
            console.error('Erro ao atualizar a lista de produtos importados:', error);
            notify('Não foi possível atualizar a lista de produtos importados. Tente novamente.', 'error');
          } finally {
            setRefreshImportedProductsButtonState(false);
            isRefreshingImportedProducts = false;
          }
        };

        const normalizeBarcodeForComparison = (value) => {
          const digits = digitsOnly(value);
          if (!digits) return '';
          if (/^0+$/.test(digits)) return '';
          return digits;
        };

        const normalizeGtin = (value) => normalizeBarcodeForComparison(value);

        const formatGtinDisplay = (value) => {
          const raw = String(value ?? '').trim();
          if (!raw) return 'SEM GTIN';
          if (/sem\s*gtin/i.test(raw)) return 'SEM GTIN';
          const digits = digitsOnly(raw);
          if (!digits || /^0+$/.test(digits)) return 'SEM GTIN';
          return raw;
        };

        const parseNumber = (value) => {
          if (value === null || typeof value === 'undefined') return null;
          const raw = String(value).trim();
          if (!raw) return null;
          const normalized = raw.replace(',', '.');
          const numeric = Number.parseFloat(normalized);
          return Number.isFinite(numeric) ? numeric : null;
        };

        const formatDecimal = (value, options = {}) => {
          const { minimumFractionDigits = 3, maximumFractionDigits = minimumFractionDigits } = options;
          const numericValue = Number.isFinite(value) ? value : parseNumber(value);
          const finalValue = Number.isFinite(numericValue) ? numericValue : 0;
          return finalValue.toLocaleString('pt-BR', {
            minimumFractionDigits,
            maximumFractionDigits,
          });
        };

        const formatQuantity = (value) => formatDecimal(value, { minimumFractionDigits: 3, maximumFractionDigits: 3 });

        const formatMoneyValue = (value) => formatDecimal(value, { minimumFractionDigits: 2, maximumFractionDigits: 2 });

        const formatPercentValue = (value) => formatDecimal(value, { minimumFractionDigits: 2, maximumFractionDigits: 2 });

        const toNumeric = (value) => (Number.isFinite(value) ? value : parseNumber(value));

        const sumFiniteValues = (values) =>
          values.reduce(
            (accumulator, current) =>
              Number.isFinite(current) ? accumulator + current : accumulator,
            0
          );

        const calculateEntryStockQuantity = (item) => {
          if (!item || typeof item !== 'object') return null;

          const quantityValue = toNumeric(item.quantity);
          let conversionFactor = toNumeric(item.conversion);

          if (!Number.isFinite(conversionFactor) || conversionFactor <= 0) {
            const multiplierValue = toNumeric(item.conversionMultiplier);
            const dividerValue = toNumeric(item.conversionDivider);

            if (
              Number.isFinite(multiplierValue) &&
              multiplierValue > 0 &&
              Number.isFinite(dividerValue) &&
              dividerValue > 0
            ) {
              conversionFactor = multiplierValue / dividerValue;
            } else if (Number.isFinite(multiplierValue) && multiplierValue > 0) {
              conversionFactor = multiplierValue;
            } else if (Number.isFinite(dividerValue) && dividerValue > 0) {
              conversionFactor = 1 / dividerValue;
            }
          }

          if (Number.isFinite(quantityValue) && Number.isFinite(conversionFactor) && conversionFactor > 0) {
            return quantityValue * conversionFactor;
          }

          const qTribValue = toNumeric(item.qTrib);
          if (Number.isFinite(qTribValue)) {
            return qTribValue;
          }

          return Number.isFinite(quantityValue) ? quantityValue : null;
        };

        const ensureItemCostWithTaxes = (item, options = {}) => {
          if (!item || typeof item !== 'object') return item;

          const hasExplicitSkip = Object.prototype.hasOwnProperty.call(
            options,
            'skipTaxComputation'
          );
          const skipTaxComputation = hasExplicitSkip
            ? Boolean(options.skipTaxComputation)
            : Boolean(item?.skipTaxComputation);

          item.skipTaxComputation = skipTaxComputation;
          const shouldForceZeroCost = Boolean(item.forceBonificationZeroCost);

          const quantityValue = toNumeric(item.quantity);
          const unitPriceValue = toNumeric(item.unitPrice);
          const totalValue = toNumeric(item.total);
          const discountValueRaw = toNumeric(item.discount);

          const grossAmount = Number.isFinite(quantityValue) && Number.isFinite(unitPriceValue)
            ? quantityValue * unitPriceValue
            : Number.isFinite(totalValue)
            ? totalValue
            : null;

          const baseTotal = Number.isFinite(totalValue)
            ? totalValue
            : Number.isFinite(grossAmount)
            ? grossAmount
            : null;

          let discountValue = Number.isFinite(discountValueRaw) ? Math.max(discountValueRaw, 0) : 0;
          if (Number.isFinite(baseTotal)) {
            discountValue = Math.min(discountValue, Math.max(baseTotal, 0));
          }

          if (Number.isFinite(grossAmount) && grossAmount > 0) {
            item.discountPercent = Number.isFinite(discountValue)
              ? (discountValue / grossAmount) * 100
              : 0;
          } else if (!Number.isFinite(discountValue) || discountValue <= 0) {
            item.discountPercent = 0;
          }

          const netBaseTotal = Number.isFinite(baseTotal)
            ? Math.max(baseTotal - (Number.isFinite(discountValue) ? discountValue : 0), 0)
            : null;

          const taxesTotal = sumFiniteValues([
            toNumeric(item.icmsStValue),
            toNumeric(item.ipiValue),
            toNumeric(item.iiValue),
            toNumeric(item.fcpValue),
            toNumeric(item.fcpStValue),
            toNumeric(item.fcpStRetainedValue),
          ]);

          const rawAdditionalsTotal = sumFiniteValues([toNumeric(item.freight), toNumeric(item.other)]);
          const additionalsTotal = Math.abs(rawAdditionalsTotal) <= 0.000001 ? 0 : rawAdditionalsTotal;

          const entryStockQuantity = calculateEntryStockQuantity(item);
          const effectiveQuantity =
            Number.isFinite(entryStockQuantity) && entryStockQuantity > 0
              ? entryStockQuantity
              : Number.isFinite(quantityValue) && quantityValue > 0
              ? quantityValue
              : null;

          if (shouldForceZeroCost) {
            const quantityForCostCandidates = [
              entryStockQuantity,
              effectiveQuantity,
              quantityValue,
            ];
            const quantityForCost = quantityForCostCandidates.find(
              (candidate) => Number.isFinite(candidate) && candidate > 0
            ) || null;

            item.discount = 0;
            item.discountPercent = 0;
            item.entryStockQuantity =
              Number.isFinite(entryStockQuantity) && entryStockQuantity >= 0 ? entryStockQuantity : null;
            item.netProductValue = 0;
            item.taxesTotal = 0;
            item.additionalsTotal = 0;
            item.totalWithTaxes = 0;
            item.unitCostWithTaxes = Number.isFinite(quantityForCost) && quantityForCost > 0 ? 0 : null;

            return item;
          }

          if (skipTaxComputation) {
            const preservedTotal = Number.isFinite(totalValue)
              ? totalValue
              : Number.isFinite(netBaseTotal)
              ? netBaseTotal
              : Number.isFinite(grossAmount)
              ? grossAmount
              : null;

            const effectiveTotal = Number.isFinite(preservedTotal) ? preservedTotal : null;

            const quantityForCostCandidates = [
              entryStockQuantity,
              effectiveQuantity,
              quantityValue,
            ];
            const quantityForCost = quantityForCostCandidates.find(
              (candidate) => Number.isFinite(candidate) && candidate > 0
            ) || null;

            const computedUnitCost =
              Number.isFinite(effectiveTotal) && Number.isFinite(quantityForCost) && quantityForCost > 0
                ? effectiveTotal / quantityForCost
                : null;

            const shouldPrioritizeComputedCost =
              Number.isFinite(entryStockQuantity) && entryStockQuantity > 0;

            const unitCost = shouldPrioritizeComputedCost
              ? Number.isFinite(computedUnitCost) && computedUnitCost >= 0
                ? computedUnitCost
                : Number.isFinite(unitPriceValue) && unitPriceValue >= 0
                ? unitPriceValue
                : null
              : Number.isFinite(unitPriceValue) && unitPriceValue >= 0
              ? unitPriceValue
              : Number.isFinite(computedUnitCost) && computedUnitCost >= 0
              ? computedUnitCost
              : null;

            item.discount = Number.isFinite(discountValue) ? discountValue : 0;
            item.entryStockQuantity =
              Number.isFinite(entryStockQuantity) && entryStockQuantity >= 0 ? entryStockQuantity : null;
            item.netProductValue =
              Number.isFinite(netBaseTotal) && netBaseTotal >= 0
                ? netBaseTotal
                : Number.isFinite(effectiveTotal) && effectiveTotal >= 0
                ? effectiveTotal
                : null;
            item.taxesTotal = Number.isFinite(taxesTotal) ? taxesTotal : 0;
            item.additionalsTotal = additionalsTotal;
            item.totalWithTaxes = Number.isFinite(effectiveTotal) && effectiveTotal >= 0 ? effectiveTotal : null;
            item.unitCostWithTaxes = Number.isFinite(unitCost) && unitCost >= 0 ? unitCost : null;

            return item;
          }

          const totalWithTaxes =
            (Number.isFinite(netBaseTotal) ? netBaseTotal : 0) + taxesTotal + additionalsTotal;

          const unitCostWithTaxes =
            Number.isFinite(effectiveQuantity) && effectiveQuantity > 0
              ? totalWithTaxes / effectiveQuantity
              : null;

          item.discount = Number.isFinite(discountValue) ? discountValue : 0;
          item.entryStockQuantity =
            Number.isFinite(entryStockQuantity) && entryStockQuantity >= 0 ? entryStockQuantity : null;
          item.netProductValue =
            Number.isFinite(netBaseTotal) && netBaseTotal >= 0 ? netBaseTotal : null;
          item.taxesTotal = taxesTotal;
          item.additionalsTotal = additionalsTotal;
          item.totalWithTaxes =
            Number.isFinite(netBaseTotal) || taxesTotal || additionalsTotal ? totalWithTaxes : null;
          item.unitCostWithTaxes =
            Number.isFinite(unitCostWithTaxes) && unitCostWithTaxes >= 0 ? unitCostWithTaxes : null;

          return item;
        };

        const alignItemsWithTotals = (items, totals, options = {}) => {
          if (!Array.isArray(items) || !items.length) return;

          const { skipTaxComputation = false } = options;

          if (skipTaxComputation) {
            items.forEach((item) => {
              if (typeof ensureConversionDefaults === 'function') {
                ensureConversionDefaults(item);
              }
              ensureItemCostWithTaxes(item, options);
            });
            return;
          }

          const distributionEntries = items.map((item) => {
            const candidates = [
              toNumeric(item.netProductValue),
              toNumeric(item.total),
              toNumeric(item.entryStockQuantity),
              toNumeric(item.quantity),
            ];
            const base = candidates.find((value) => Number.isFinite(value) && value > 0) || 1;
            return { item, base };
          });

          const distributeByBase = (amount, applyShare) => {
            if (!Number.isFinite(amount) || !items.length || Math.abs(amount) <= 0.00001) {
              return;
            }

            const totalBase = distributionEntries.reduce(
              (accumulator, entry) =>
                accumulator + (Number.isFinite(entry.base) && entry.base > 0 ? entry.base : 0),
              0
            );

            let allocated = 0;
            distributionEntries.forEach((entry, index) => {
              const ratio =
                totalBase > 0
                  ? entry.base / totalBase
                  : 1 / distributionEntries.length;
              let share = amount * ratio;
              if (index === distributionEntries.length - 1) {
                share = amount - allocated;
              } else {
                allocated += share;
              }
              applyShare(entry.item, share);
            });
          };

          const setFieldValue = (item, field, value) => {
            const sanitized = Math.abs(value) <= 0.000001 ? 0 : value;
            item[field] = sanitized;
          };

          const addToField = (item, field, delta) => {
            const current = toNumeric(item[field]);
            const next = (Number.isFinite(current) ? current : 0) + delta;
            setFieldValue(item, field, next);
          };

          const adjustNonNegativeField = (field, targetValue) => {
            if (!Number.isFinite(targetValue)) return;
            const sanitizedTarget = targetValue > 0 ? targetValue : 0;
            const currentSum = sumFiniteValues(
              items.map((item) => {
                const value = toNumeric(item[field]);
                return Number.isFinite(value) && value > 0 ? value : 0;
              })
            );

            if (currentSum > 0) {
              const ratio = sanitizedTarget / currentSum;
              items.forEach((item) => {
                const value = toNumeric(item[field]);
                const current = Number.isFinite(value) && value > 0 ? value : 0;
                setFieldValue(item, field, current * ratio);
              });
            } else if (sanitizedTarget > 0) {
              distributeByBase(sanitizedTarget, (item, share) => addToField(item, field, share));
            } else {
              items.forEach((item) => {
                if (item[field]) {
                  setFieldValue(item, field, 0);
                }
              });
            }
          };

          const totalsNormalized = {
            discount: toNumeric(totals?.discount),
            freight: toNumeric(totals?.freight),
            other: toNumeric(totals?.other),
            insurance: toNumeric(totals?.insurance),
            ipi: toNumeric(totals?.ipi),
            icmsSt: toNumeric(totals?.icmsSt),
            fcp: toNumeric(totals?.fcp),
            fcpSt: toNumeric(totals?.fcpSt),
            fcpStRet: toNumeric(totals?.fcpStRet),
            ii: toNumeric(totals?.ii),
            products: toNumeric(totals?.products),
            totalValue: toNumeric(totals?.totalValue),
          };

          const discountTarget = Number.isFinite(totalsNormalized.discount)
            ? Math.max(totalsNormalized.discount, 0)
            : null;
          if (discountTarget !== null) {
            const currentDiscountSum = sumFiniteValues(
              items.map((item) => {
                const value = toNumeric(item.discount);
                return Number.isFinite(value) && value > 0 ? value : 0;
              })
            );

            if (currentDiscountSum > 0) {
              const ratio = discountTarget / currentDiscountSum;
              items.forEach((item) => {
                const value = toNumeric(item.discount);
                const current = Number.isFinite(value) && value > 0 ? value : 0;
                setFieldValue(item, 'discount', current * ratio);
              });
            } else if (discountTarget > 0) {
              distributeByBase(discountTarget, (item, share) => addToField(item, 'discount', share));
            } else {
              items.forEach((item) => {
                if (item.discount) {
                  setFieldValue(item, 'discount', 0);
                }
              });
            }
          }

          adjustNonNegativeField('freight', totalsNormalized.freight);

          const targetOther =
            (Number.isFinite(totalsNormalized.other) ? totalsNormalized.other : 0) +
            (Number.isFinite(totalsNormalized.insurance) ? totalsNormalized.insurance : 0);
          const currentOther = sumFiniteValues(items.map((item) => toNumeric(item.other)));
          distributeByBase(targetOther - currentOther, (item, share) => addToField(item, 'other', share));

          adjustNonNegativeField('ipiValue', totalsNormalized.ipi);
          adjustNonNegativeField('icmsStValue', totalsNormalized.icmsSt);
          adjustNonNegativeField('fcpValue', totalsNormalized.fcp);
          adjustNonNegativeField('fcpStValue', totalsNormalized.fcpSt);
          adjustNonNegativeField('fcpStRetainedValue', totalsNormalized.fcpStRet);
          adjustNonNegativeField('iiValue', totalsNormalized.ii);

          items.forEach((item) => ensureItemCostWithTaxes(item, options));

          const declaredCharges = [
            totalsNormalized.freight,
            totalsNormalized.other,
            totalsNormalized.insurance,
            totalsNormalized.ipi,
            totalsNormalized.icmsSt,
            totalsNormalized.fcp,
            totalsNormalized.fcpSt,
            totalsNormalized.fcpStRet,
            totalsNormalized.ii,
          ];

          const hasDeclaredCharges = declaredCharges.some(
            (value) => Number.isFinite(value) && Math.abs(value) > 0.000001
          );

          const totalsMatchProducts =
            Number.isFinite(totalsNormalized.totalValue) &&
            Number.isFinite(totalsNormalized.products) &&
            Math.abs(totalsNormalized.totalValue - totalsNormalized.products) <= 0.0005;

          if (
            Number.isFinite(totalsNormalized.totalValue) &&
            !totalsMatchProducts
          ) {
            let aggregatedTotal = sumFiniteValues(
              items.map((item) => toNumeric(item.totalWithTaxes))
            );
            let remainder = totalsNormalized.totalValue - aggregatedTotal;

            if (Math.abs(remainder) > 0.05) {
              distributeByBase(remainder, (item, share) => addToField(item, 'other', share));
              items.forEach((item) => ensureItemCostWithTaxes(item));
              aggregatedTotal = sumFiniteValues(items.map((item) => toNumeric(item.totalWithTaxes)));
              remainder = totalsNormalized.totalValue - aggregatedTotal;
            }

            if (Math.abs(remainder) > 0.0005) {
              const lastItem = items[items.length - 1];
              if (lastItem) {
                addToField(lastItem, 'other', remainder);
                ensureItemCostWithTaxes(lastItem);
              }
            }
          } else if (
            Number.isFinite(totalsNormalized.totalValue) &&
            !hasDeclaredCharges &&
            Number.isFinite(totalsNormalized.products) &&
            Math.abs(totalsNormalized.totalValue - totalsNormalized.products) > 0.0005
          ) {
            console.warn(
              '[NF-e] Valor total informado (vNF) difere do somatório dos produtos (vProd) sem custos adicionais declarados.',
              {
                totalValue: totalsNormalized.totalValue,
                productsTotal: totalsNormalized.products,
              }
            );
          }
        };

        const INTERNAL_CODE_PREFIX = 'SKU-';

        const normalizeSupplierProductCode = (value) => {
          if (value === null || value === undefined) return '';
          if (typeof value === 'string') return value.trim();
          if (typeof value === 'number' && Number.isFinite(value)) return String(value);
          return String(value).trim();
        };

        const canonicalSupplierProductCode = (value) =>
          normalizeSupplierProductCode(value).toUpperCase();

        const canonicalSupplierName = (value) => {
          if (typeof value === 'string') {
            const normalized = value
              .normalize('NFD')
              .replace(/[\u0300-\u036f]/g, '')
              .replace(/\s+/g, ' ')
              .trim();
            return normalized ? normalized.toUpperCase() : '';
          }
          if (typeof value === 'number' && Number.isFinite(value)) {
            return String(value).toUpperCase();
          }
          return '';
        };

        const CFOP_SALE_WITHOUT_ST_CODES = new Set(['5101', '5102', '6101', '6102', '7101', '7102']);
        const CFOP_SALE_WITH_ST_CODES = new Set(['5401', '5403', '5405', '6401', '6403', '6405']);
        const DEFAULT_BONUS_CFOPS = ['5910', '6910', '7910'];
        const OPTIONAL_BONUS_CFOPS = ['5949', '6949'];

        const normalizeCfopCode = (value) => {
          if (value === null || value === undefined) return '';
          const raw = String(value).trim();
          if (!raw) return '';
          const digits = raw.replace(/\D+/g, '');
          if (!digits) return '';
          if (digits.length === 3) return `0${digits}`;
          if (digits.length >= 4) return digits.slice(0, 4);
          return digits.padStart(4, '0');
        };

        const isTruthyConfigValue = (value) => {
          if (typeof value === 'string') {
            const normalized = value.trim().toLowerCase();
            return ['1', 'true', 'yes', 'y', 'sim'].includes(normalized);
          }
          return Boolean(value);
        };

        const resolveConfiguredBonusCfops = () => {
          const bonusSet = new Set(DEFAULT_BONUS_CFOPS.map((code) => normalizeCfopCode(code)).filter(Boolean));
          const sources = [];

          if (typeof window !== 'undefined') {
            if (window.NF_IMPORT_CONFIG) sources.push(window.NF_IMPORT_CONFIG);
            if (window.NF_IMPORT_SETTINGS) sources.push(window.NF_IMPORT_SETTINGS);
            if (window.APP_CONFIG) {
              sources.push(window.APP_CONFIG);
              if (window.APP_CONFIG.nfImport) {
                sources.push(window.APP_CONFIG.nfImport);
              }
            }
          }

          if (typeof document !== 'undefined' && document.body && document.body.dataset) {
            sources.push(document.body.dataset);
          }

          sources.forEach((source) => {
            if (!source || typeof source !== 'object') return;
            const explicit = source.bonusCfops || source.bonusCFOPs;
            if (Array.isArray(explicit)) {
              explicit.forEach((entry) => {
                const normalized = normalizeCfopCode(entry);
                if (normalized) {
                  bonusSet.add(normalized);
                }
              });
            }
            const optionalList = source.optionalBonusCfops || source.optionalBonusCFOPs;
            if (Array.isArray(optionalList)) {
              optionalList.forEach((entry) => {
                const normalized = normalizeCfopCode(entry);
                if (normalized) {
                  bonusSet.add(normalized);
                }
              });
            }
          });

          OPTIONAL_BONUS_CFOPS.forEach((code) => {
            const normalizedCode = normalizeCfopCode(code);
            if (!normalizedCode) return;
            const shouldInclude = sources.some((source) => {
              if (!source || typeof source !== 'object') return false;
              const directKeys = [
                `accept${code}AsBonus`,
                `accept${code}`,
                `allow${code}Bonus`,
                `aceitar${code}Bonificacao`,
                `aceita${code}Bonificacao`,
                `acceptBonus${code}`,
                `bonus${code}`,
              ];
              if (directKeys.some((key) => isTruthyConfigValue(source[key]))) {
                return true;
              }
              if (
                isTruthyConfigValue(source.acceptOptionalBonusCfops) ||
                isTruthyConfigValue(source.acceptOptionalBonusCFOPs) ||
                isTruthyConfigValue(source.aceitarCfopsBonificacaoOpcionais)
              ) {
                return true;
              }
              const optionalList = source.optionalBonusCfops || source.optionalBonusCFOPs;
              if (Array.isArray(optionalList)) {
                return optionalList.some((entry) => normalizeCfopCode(entry) === normalizedCode);
              }
              return false;
            });
            if (shouldInclude) {
              bonusSet.add(normalizedCode);
            }
          });

          return bonusSet;
        };

        const classifyCfopForBonification = (cfopCode, bonusSet) => {
          if (!cfopCode) return 'indefinido';
          if (bonusSet.has(cfopCode)) return 'bonificacao';
          if (CFOP_SALE_WITHOUT_ST_CODES.has(cfopCode)) return 'venda-sem-st';
          if (CFOP_SALE_WITH_ST_CODES.has(cfopCode)) return 'venda-com-st';
          return 'indefinido';
        };

        const buildBonificationGroupKey = (item) => {
          if (!item || typeof item !== 'object') return '';
          const parts = [];
          const supplierCode = canonicalSupplierProductCode(item.supplierCode);
          if (supplierCode) {
            parts.push(`SUP:${supplierCode}`);
          }
          const candidateBarcodes = Array.isArray(item.barcodeCandidates) ? item.barcodeCandidates : [];
          const normalizedBarcode =
            candidateBarcodes.find((code) => code) ||
            normalizeBarcodeForComparison(item.barcodeDisplay) ||
            normalizeBarcodeForComparison(item.ean) ||
            normalizeBarcodeForComparison(item.eanTrib);
          if (normalizedBarcode) {
            parts.push(`GTIN:${normalizedBarcode}`);
          }
          const description = typeof item.description === 'string' ? item.description.trim().toUpperCase() : '';
          if (description) {
            parts.push(`DESC:${description}`);
          }
          const ncm = typeof item.ncm === 'string' ? item.ncm.trim() : '';
          if (ncm) {
            parts.push(`NCM:${ncm}`);
          }
          if (!parts.length && Number.isFinite(item?.index)) {
            parts.push(`INDEX:${item.index}`);
          }
          return parts.join('||');
        };

        const compareByOriginalIndex = (a, b) => {
          const indexA = Number.isFinite(a?.index) ? a.index : 0;
          const indexB = Number.isFinite(b?.index) ? b.index : 0;
          return indexA - indexB;
        };

        const resolveEntryStockForBonification = (item) => {
          if (!item || typeof item !== 'object') return 0;
          const direct = toNumeric(item.entryStockQuantity);
          if (Number.isFinite(direct)) return direct;
          const computed = calculateEntryStockQuantity(item);
          if (Number.isFinite(computed)) return computed;
          const quantityValue = toNumeric(item.quantity);
          return Number.isFinite(quantityValue) ? quantityValue : 0;
        };

        const sumBonificationValues = (items, extractor) => {
          if (!Array.isArray(items) || !items.length) return 0;
          return items.reduce((total, current) => {
            const rawValue = typeof extractor === 'function' ? extractor(current) : current;
            const numericValue = toNumeric(rawValue);
            return Number.isFinite(numericValue) ? total + numericValue : total;
          }, 0);
        };

        const BONIFICATION_FINANCIAL_FIELDS = [
          'total',
          'netProductValue',
          'taxesTotal',
          'additionalsTotal',
          'totalWithTaxes',
        ];

        const captureItemFinancialSnapshot = (item) => {
          if (!item || typeof item !== 'object') return null;
          const snapshot = {};
          let hasValue = false;
          BONIFICATION_FINANCIAL_FIELDS.forEach((field) => {
            const value = toNumeric(item[field]);
            if (Number.isFinite(value)) {
              snapshot[field] = value;
              hasValue = true;
            }
          });
          return hasValue ? snapshot : null;
        };

        const sumBonusFinancialSnapshots = (items) => {
          if (!Array.isArray(items) || !items.length) return null;
          const totals = {};
          let hasValue = false;
          BONIFICATION_FINANCIAL_FIELDS.forEach((field) => {
            const fieldSum = sumBonificationValues(items, (entry) => {
              const info = entry?.bonificationInfo;
              if (info && typeof info === 'object' && info.originalTotals && typeof info.originalTotals === 'object') {
                return info.originalTotals[field];
              }
              return entry ? entry[field] : null;
            });
            if (Number.isFinite(fieldSum) && Math.abs(fieldSum) > 0.000001) {
              totals[field] = fieldSum;
              hasValue = true;
            }
          });
          return hasValue ? totals : null;
        };

        const BONIFICATION_VALUE_PRIORITY_FIELDS = ['total', 'netProductValue', 'totalWithTaxes'];

        const extractBonificationAmount = (source) => {
          if (!source || typeof source !== 'object') return null;
          for (const field of BONIFICATION_VALUE_PRIORITY_FIELDS) {
            const value = toNumeric(source[field]);
            if (Number.isFinite(value)) {
              return value;
            }
          }
          return null;
        };

        const computeBonificationTotal = (items) => {
          if (!Array.isArray(items) || !items.length) return null;

          let total = 0;
          let hasBonification = false;

          items.forEach((item) => {
            if (!item || typeof item !== 'object') return;
            const info = item.bonificationInfo;
            if (!info || typeof info !== 'object') return;

            let value = extractBonificationAmount(info.bonusTotals);
            if (!Number.isFinite(value)) {
              value = extractBonificationAmount(info.originalTotals);
            }
            if (!Number.isFinite(value) && item.forceBonificationZeroCost) {
              value = extractBonificationAmount(item);
            }

            if (Number.isFinite(value)) {
              total += value;
              hasBonification = true;
            }
          });

          if (hasBonification) {
            return total;
          }

          const hasItems = items.some((entry) => entry && typeof entry === 'object');
          return hasItems ? 0 : null;
        };

        const mergeBonificationGroupIntoBase = (group) => {
          if (!group || !group.sales.length || !group.bonuses.length) {
            return null;
          }

          const base = group.sales[0];
          const additionalSales = group.sales.slice(1);
          const regularQuantity = toNumeric(base.quantity) || 0;
          const regularEntryStock = resolveEntryStockForBonification(base);
          const bonusQuantity = sumBonificationValues(group.bonuses, (item) => item?.quantity);
          const bonusEntryStock = sumBonificationValues(group.bonuses, (item) =>
            resolveEntryStockForBonification(item)
          );

          const combinedQuantity = regularQuantity + bonusQuantity;
          if (Number.isFinite(combinedQuantity)) {
            base.quantity = combinedQuantity;
          }

          const combinedEntryStock = regularEntryStock + bonusEntryStock;
          if (Number.isFinite(combinedEntryStock)) {
            base.entryStockQuantity = combinedEntryStock;
          }

          const regularTotals = captureItemFinancialSnapshot(base);
          const bonusTotals = sumBonusFinancialSnapshots(group.bonuses);

          const regularCfops = Array.from(
            new Set(
              [base.cfop, ...additionalSales.map((item) => item?.cfop)]
                .map((code) => normalizeCfopCode(code))
                .filter(Boolean)
            )
          );
          const bonusCfops = Array.from(
            new Set(group.bonuses.map((item) => normalizeCfopCode(item?.cfop)).filter(Boolean))
          );

          base.bonificationInfo = {
            hasBonification: true,
            regularQuantity,
            bonusQuantity,
            combinedQuantity: Number.isFinite(combinedQuantity) ? combinedQuantity : regularQuantity,
            regularEntryStock,
            bonusEntryStock,
            combinedEntryStock: Number.isFinite(combinedEntryStock)
              ? combinedEntryStock
              : regularEntryStock,
            regularCfops,
            bonusCfops,
            regularTotals,
            bonusTotals,
          };
          base.cfopClassification = 'venda-bonificada';
          base.hasBonificationMerge = true;

          ensureItemCostWithTaxes(base, { skipTaxComputation: base?.skipTaxComputation });

          return base;
        };

        const mergeItemsWithBonification = (items) => {
          if (!Array.isArray(items) || !items.length) return Array.isArray(items) ? items : [];

          const bonusCfopsSet = resolveConfiguredBonusCfops();
          const unknownCfops = new Set();
          const groupsMap = new Map();

          items.forEach((item) => {
            const normalizedCfop = normalizeCfopCode(item?.cfop);
            if (normalizedCfop) {
              item.cfop = normalizedCfop;
            }
            const classification = classifyCfopForBonification(normalizedCfop, bonusCfopsSet);
            item.cfopClassification = classification;
            if (
              classification === 'indefinido' &&
              normalizedCfop &&
              !CFOP_SALE_WITHOUT_ST_CODES.has(normalizedCfop) &&
              !CFOP_SALE_WITH_ST_CODES.has(normalizedCfop) &&
              !bonusCfopsSet.has(normalizedCfop)
            ) {
              unknownCfops.add(normalizedCfop);
            }

            item.forceBonificationZeroCost = false;
            ensureItemCostWithTaxes(item, { skipTaxComputation: item?.skipTaxComputation });

            if (classification === 'bonificacao') {
              const info =
                item.bonificationInfo && typeof item.bonificationInfo === 'object'
                  ? { ...item.bonificationInfo }
                  : {};
              const originalTotals = captureItemFinancialSnapshot(item);
              if (originalTotals) {
                info.originalTotals = originalTotals;
              }
              item.bonificationInfo = info;
              item.forceBonificationZeroCost = true;
              ensureItemCostWithTaxes(item, { skipTaxComputation: item?.skipTaxComputation });
            }

            const key = buildBonificationGroupKey(item) ||
              `INDEX:${Number.isFinite(item?.index) ? item.index : groupsMap.size}`;
            let group = groupsMap.get(key);
            if (!group) {
              group = { key, items: [], bonuses: [], sales: [], others: [], orderIndex: 0, mergedBase: null };
              groupsMap.set(key, group);
            }
            group.items.push(item);
            if (classification === 'bonificacao') {
              group.bonuses.push(item);
            } else if (
              classification === 'venda-sem-st' ||
              classification === 'venda-com-st' ||
              classification === 'venda-bonificada'
            ) {
              group.sales.push(item);
            } else {
              group.others.push(item);
            }
          });

          const orderedGroups = Array.from(groupsMap.values()).map((group) => {
            group.items.sort(compareByOriginalIndex);
            group.sales.sort(compareByOriginalIndex);
            group.bonuses.sort(compareByOriginalIndex);
            group.others.sort(compareByOriginalIndex);
            group.orderIndex =
              group.items.length && Number.isFinite(group.items[0]?.index) ? group.items[0].index : 0;
            if (group.sales.length && group.bonuses.length) {
              group.mergedBase = mergeBonificationGroupIntoBase(group);
            }
            return group;
          });

          orderedGroups.sort((a, b) => a.orderIndex - b.orderIndex);

          const mergedItems = [];

          orderedGroups.forEach((group) => {
            if (group.sales.length && group.bonuses.length && group.mergedBase) {
              const mergedSet = new Set(group.bonuses);
              group.items.forEach((item) => {
                if (mergedSet.has(item)) return;
                if (item === group.mergedBase) {
                  mergedItems.push(group.mergedBase);
                } else {
                  mergedItems.push(item);
                }
              });
            } else {
              if (!group.sales.length && group.bonuses.length) {
                group.bonuses.forEach((bonusItem) => {
                  if (!bonusItem || typeof bonusItem !== 'object') return;
                  const info =
                    bonusItem.bonificationInfo && typeof bonusItem.bonificationInfo === 'object'
                      ? bonusItem.bonificationInfo
                      : {};
                  info.hasBonification = true;
                  if (!Number.isFinite(info.bonusQuantity)) {
                    const bonusQuantityValue = toNumeric(bonusItem.quantity);
                    info.bonusQuantity = Number.isFinite(bonusQuantityValue)
                      ? bonusQuantityValue
                      : null;
                  }
                  if (!Number.isFinite(info.regularQuantity)) {
                    info.regularQuantity = 0;
                  }
                  if (!Number.isFinite(info.bonusEntryStock)) {
                    const bonusEntryStockValue = resolveEntryStockForBonification(bonusItem);
                    info.bonusEntryStock = Number.isFinite(bonusEntryStockValue)
                      ? bonusEntryStockValue
                      : null;
                  }
                  if (!Number.isFinite(info.combinedQuantity)) {
                    info.combinedQuantity = Number.isFinite(info.bonusQuantity)
                      ? info.bonusQuantity
                      : null;
                  }
                  if (!Number.isFinite(info.combinedEntryStock)) {
                    info.combinedEntryStock = Number.isFinite(info.bonusEntryStock)
                      ? info.bonusEntryStock
                      : null;
                  }
                  const bonusCfop = normalizeCfopCode(bonusItem?.cfop);
                  const bonusCfops = Array.isArray(info.bonusCfops) ? info.bonusCfops.slice() : [];
                  if (bonusCfop) {
                    bonusCfops.push(bonusCfop);
                  }
                  info.bonusCfops = Array.from(new Set(bonusCfops));
                  info.regularCfops = Array.isArray(info.regularCfops)
                    ? Array.from(new Set(info.regularCfops))
                    : [];
                  bonusItem.bonificationInfo = info;
                });
              }
              mergedItems.push(...group.items);
            }
          });

          if (unknownCfops.size) {
            const codesList = Array.from(unknownCfops).sort().join(', ');
            notify(
              `CFOP(s) sem classificação no mapa de bonificação: ${codesList}. Esses itens foram tratados como indefinidos.`,
              'warning'
            );
          }

          return mergedItems;
        };

        const buildDocumentReferenceFingerprint = (reference) => {
          if (!reference || typeof reference !== 'object') return '';
          const accessKeyDigits = digitsOnly(reference.accessKey);
          if (accessKeyDigits) {
            return `accessKey:${accessKeyDigits}`;
          }

          const parts = [
            reference.type,
            reference.model,
            reference.series,
            reference.number,
            reference.emissionDate,
            reference.issuerUf,
            digitsOnly(reference.document),
          ]
            .map((value) => String(value ?? '').trim().toLowerCase())
            .filter(Boolean);

          return parts.join('|');
        };

        const createBonusDocumentReference = (bonusData) => {
          if (!bonusData || typeof bonusData !== 'object') return null;
          const ide = bonusData.ide || {};
          const emitter = bonusData.emit || {};
          const emitterAddress = emitter.address || {};
          const emissionInfo = normalizeDate(ide.emissionDate);

          const reference = {
            type: 'NF-e de bonificação',
            model: ide.model || '55',
            number: ide.number || '',
            series: ide.serie || '',
            emissionDate: emissionInfo.dateInput || ide.emissionDate || '',
            issuerUf: emitterAddress.state || '',
            document: emitter.document || '',
          };

          const accessKeyDigits = digitsOnly(bonusData.accessKey);
          if (accessKeyDigits) {
            reference.accessKey = accessKeyDigits;
          }

          return reference;
        };

        const mergeBonusItemsIntoCurrentNote = (bonusData) => {
          if (!bonusData) return false;
          const bonusItems = Array.isArray(bonusData.items) ? bonusData.items : [];
          if (!bonusItems.length) {
            return false;
          }

          const baseData =
            lastNfeData || {
              items: [],
              totals: bonusData.totals || {},
              duplicates: [],
              ide: bonusData.ide || {},
              emit: bonusData.emit || null,
              dest: bonusData.dest || null,
              payments: Array.isArray(bonusData.payments) ? bonusData.payments : [],
              references: Array.isArray(bonusData.references) ? bonusData.references : [],
              paymentConditionHint: bonusData.paymentConditionHint || '',
              selectedCompanyId: bonusData.selectedCompanyId || '',
              selectedBankAccountId: bonusData.selectedBankAccountId || '',
              selectedDepositId: bonusData.selectedDepositId || '',
            };

          const existingItems = Array.isArray(baseData.items) ? baseData.items : [];
          const combinedItems = mergeItemsWithBonification([...existingItems, ...bonusItems]);

          combinedItems.forEach((item, index) => {
            if (item && typeof item === 'object') {
              item.index = index;
            }
          });

          baseData.items = combinedItems;
          if (!Array.isArray(baseData.duplicates)) {
            baseData.duplicates = [];
          }
          if (!baseData.totals) {
            baseData.totals = {};
          }
          if (!baseData.ide) {
            baseData.ide = {};
          }
          if (!baseData.payments) {
            baseData.payments = [];
          }
          if (!baseData.references) {
            baseData.references = [];
          }

          const mergedBonificationTotal = computeBonificationTotal(combinedItems);
          baseData.totals.bonification = Number.isFinite(mergedBonificationTotal)
            ? mergedBonificationTotal
            : null;

          const existingReferences = Array.isArray(baseData.references)
            ? baseData.references.slice()
            : [];
          const seenReferences = new Set(
            existingReferences.map((reference) => buildDocumentReferenceFingerprint(reference)).filter(Boolean)
          );

          const bonusReferences = Array.isArray(bonusData.references) ? bonusData.references : [];
          bonusReferences.forEach((reference) => {
            if (!reference || typeof reference !== 'object') return;
            const fingerprint = buildDocumentReferenceFingerprint(reference);
            if (fingerprint && seenReferences.has(fingerprint)) return;
            seenReferences.add(fingerprint);
            existingReferences.push({ ...reference });
          });

          const bonusReference = createBonusDocumentReference(bonusData);
          if (bonusReference) {
            const fingerprint = buildDocumentReferenceFingerprint(bonusReference);
            if (!fingerprint || !seenReferences.has(fingerprint)) {
              if (fingerprint) {
                seenReferences.add(fingerprint);
              }
              existingReferences.push(bonusReference);
            }
          }

          baseData.references = existingReferences;

          lastNfeData = baseData;
          renderMainProductsFromNfe(combinedItems);
          renderDocumentsFromNfe(existingReferences);
          return true;
        };

        const resolveActiveSupplierInfo = (nfeData) => {
          const result = { name: '', document: '' };
          const pickName = (...values) => values.find((entry) => typeof entry === 'string' && entry.trim());

          if (lastSupplierRecord) {
            result.name =
              pickName(
                lastSupplierRecord.legalName,
                lastSupplierRecord.fantasyName,
                lastSupplierRecord.name,
                lastSupplierRecord.razaoSocial
              ) || '';
            result.document = digitsOnly(lastSupplierRecord.cnpj || lastSupplierRecord.document || '');
          }

          const xmlSource = lastSupplierData || nfeData?.emit || null;
          if (!result.name && xmlSource) {
            result.name =
              pickName(xmlSource.name, xmlSource.fantasyName, xmlSource.legalName, xmlSource.razaoSocial) || '';
          }
          if (!result.document && xmlSource) {
            result.document = digitsOnly(xmlSource.document);
          }

          if (
            !result.name &&
            supplierSelect &&
            supplierSelect.selectedOptions &&
            supplierSelect.selectedOptions.length
          ) {
            const option = supplierSelect.selectedOptions[0];
            const optionName =
              (option.dataset && option.dataset.supplierName) || option.textContent || '';
            if (optionName) {
              result.name = optionName.trim();
            }
            if (!result.document && option.dataset && option.dataset.supplierDocument) {
              result.document = digitsOnly(option.dataset.supplierDocument);
            }
          }

          return result;
        };

        const extractAccountingAccountFromDuplicate = (duplicate) => {
          if (!duplicate || typeof duplicate !== 'object') return null;
          const rawId = duplicate.accountingAccountId || duplicate.accountingAccount || '';
          const code = duplicate.accountingAccountCode || '';
          const name = duplicate.accountingAccountName || '';
          if (rawId || code || name) {
            return {
              id: rawId ? String(rawId) : null,
              code,
              name,
            };
          }
          return null;
        };

        const resolveSupplierAccountingAccount = () => {
          const account = lastSupplierRecord?.otherInfo?.accountingAccount;
          if (account && (account.code || account.name)) {
            return {
              id: account._id ? String(account._id) : null,
              code: account.code || '',
              name: account.name || '',
            };
          }

          const duplicates = Array.isArray(lastNfeData?.duplicates) ? lastNfeData.duplicates : [];
          for (const duplicate of duplicates) {
            const extracted = extractAccountingAccountFromDuplicate(duplicate);
            if (extracted) {
              return extracted;
            }
          }

          const selectionAccountLabel = lastNfeData?.selection?.accountingAccount;
          if (selectionAccountLabel) {
            const label = String(selectionAccountLabel).trim();
            if (label) {
              return { id: null, code: '', name: label };
            }
          }

          return null;
        };

        const applyAccountingAccountToDuplicate = (
          duplicate,
          account,
          { preserveExisting = false } = {}
        ) => {
          if (!duplicate || typeof duplicate !== 'object') return;
          if (account && (account.id || account.code || account.name)) {
            duplicate.accountingAccountId = account.id ? String(account.id) : '';
            duplicate.accountingAccountCode = account.code || '';
            duplicate.accountingAccountName = account.name || '';
            return;
          }

          if (preserveExisting) {
            return;
          }

          duplicate.accountingAccountId = '';
          duplicate.accountingAccountCode = '';
          duplicate.accountingAccountName = '';
        };

        const formatAccountingAccountValue = (account) => {
          if (!account) return '';
          if (account.code && account.name) {
            return `${account.code} - ${account.name}`;
          }
          return account.code || account.name || '';
        };

        const setBankAccountPlaceholder = (message, { disabled = true } = {}) => {
          if (!bankAccountSelect) return;
          bankAccountSelect.innerHTML = '';
          const option = document.createElement('option');
          option.value = '';
          option.textContent = message;
          bankAccountSelect.appendChild(option);
          bankAccountSelect.disabled = Boolean(disabled);
        };

        const registerBankAccounts = (accounts = []) => {
          if (!Array.isArray(accounts)) return [];
          accounts.forEach((account) => {
            if (!account || !account._id) return;
            bankAccountsRegistry.index.set(String(account._id), account);
          });
          return accounts;
        };

        const buildBankAccountLabel = (account) => {
          if (!account || typeof account !== 'object') return 'Conta corrente';

          const normalize = (value) => (typeof value === 'string' ? value.trim() : '');
          const alias = normalize(account.alias);
          const bankName = normalize(account.bankName);
          const bankCode = normalize(account.bankCode);
          const agency = normalize(account.agency);
          const accountNumber = normalize(account.accountNumber);
          const accountDigit = normalize(account.accountDigit);

          const numberDisplay = accountNumber
            ? `${accountNumber}${accountDigit ? `-${accountDigit}` : ''}`
            : '';

          const parts = [];
          if (alias) parts.push(alias);

          const bankParts = [];
          if (bankCode) bankParts.push(`Banco ${bankCode}`);
          if (bankName) bankParts.push(bankName);
          if (bankParts.length) {
            parts.push(bankParts.join(' · '));
          }

          const accountParts = [];
          if (agency) accountParts.push(`Ag. ${agency}`);
          if (numberDisplay) accountParts.push(`C/C ${numberDisplay}`);
          if (accountParts.length) {
            parts.push(accountParts.join(' · '));
          }

          return parts.join(' • ') || bankName || bankCode || alias || 'Conta corrente';
        };

        const setBankAccountOptions = (accounts = [], { placeholder = null } = {}) => {
          if (!bankAccountSelect) return;

          bankAccountSelect.innerHTML = '';
          const defaultOption = document.createElement('option');
          defaultOption.value = '';
          defaultOption.textContent =
            placeholder ||
            (Array.isArray(accounts) && accounts.length
              ? 'Selecione a conta corrente'
              : 'Nenhuma conta corrente cadastrada');
          bankAccountSelect.appendChild(defaultOption);

          if (Array.isArray(accounts)) {
            accounts.forEach((account) => {
              if (!account || !account._id) return;
              const option = document.createElement('option');
              option.value = String(account._id);
              option.textContent = buildBankAccountLabel(account);
              bankAccountSelect.appendChild(option);
            });
          }

          bankAccountSelect.disabled = !accounts || !accounts.length;
        };

        const setBankAccountSelectValue = (value) => {
          if (!bankAccountSelect) return false;
          const normalized = value ? String(value) : '';
          if (!normalized) {
            bankAccountSelect.value = '';
            return true;
          }
          const options = Array.from(bankAccountSelect.options || []);
          const match = options.find((option) => option.value === normalized);
          if (match) {
            bankAccountSelect.value = normalized;
            return true;
          }
          return false;
        };

        const getBankAccountOptionsSnapshot = () => {
          if (!bankAccountSelect) return [];
          return Array.from(bankAccountSelect.options || []).map((option) => ({
            value: option.value || '',
            label: option.textContent || '',
            disabled: option.disabled,
            selected: option.selected,
          }));
        };

        const populateDuplicateBankAccountSelect = (
          selectElement,
          desiredValue = '',
          optionsSnapshot = null
        ) => {
          if (!(selectElement instanceof HTMLSelectElement)) return;

          const snapshot = Array.isArray(optionsSnapshot)
            ? optionsSnapshot
            : getBankAccountOptionsSnapshot();

          selectElement.innerHTML = '';

          if (!snapshot.length) {
            const option = document.createElement('option');
            option.value = '';
            option.textContent = 'Nenhuma conta corrente cadastrada';
            selectElement.appendChild(option);
            selectElement.disabled = true;
            return;
          }

          const normalizedDesired = desiredValue ? String(desiredValue) : '';
          let hasMatch = false;

          snapshot.forEach((optionData, index) => {
            const option = document.createElement('option');
            option.value = optionData.value || '';
            option.textContent = optionData.label || '';
            option.disabled = Boolean(optionData.disabled);
            if (normalizedDesired) {
              if (option.value === normalizedDesired && !option.disabled) {
                option.selected = true;
                hasMatch = true;
              }
            } else if (!hasMatch && optionData.selected) {
              option.selected = true;
              hasMatch = true;
            }
            if (!hasMatch && index === 0 && !option.disabled && !option.value) {
              option.selected = true;
            }
            selectElement.appendChild(option);
          });

          if (normalizedDesired && !hasMatch) {
            const registeredAccount = findBankAccountById(normalizedDesired);
            const fallbackOption = document.createElement('option');
            fallbackOption.value = normalizedDesired;
            fallbackOption.textContent = registeredAccount
              ? buildBankAccountLabel(registeredAccount)
              : `Conta ${normalizedDesired}`;
            fallbackOption.selected = true;
            selectElement.appendChild(fallbackOption);
            hasMatch = true;
          }

          if (!hasMatch) {
            const [firstOption] = selectElement.options;
            if (firstOption) {
              firstOption.selected = true;
            }
          }

          const hasUsableOptions = Array.from(selectElement.options).some(
            (option) => !option.disabled && Boolean(option.value)
          );
          selectElement.disabled = !hasUsableOptions;
        };

        const findBankAccountById = (id) => {
          if (!id) return null;
          const normalized = String(id);
          return bankAccountsRegistry.index.get(normalized) || null;
        };

        const resolveSelectedBankAccount = (data = null) => {
          const directSelection = bankAccountSelect ? bankAccountSelect.value : '';
          if (directSelection) {
            return findBankAccountById(directSelection);
          }
          const fallbackId = data?.selectedBankAccountId || pendingBankAccountId || '';
          if (fallbackId) {
            return findBankAccountById(fallbackId);
          }
          return null;
        };

        const loadBankAccountsForCompany = async (companyId = '') => {
          if (!bankAccountsEndpoint) return [];
          const cacheKey = companyId ? String(companyId) : '__all__';

          if (bankAccountsRegistry.cache.has(cacheKey)) {
            const cached = bankAccountsRegistry.cache.get(cacheKey) || [];
            registerBankAccounts(cached);
            return cached;
          }

          if (bankAccountsRegistry.loading.has(cacheKey)) {
            try {
              await bankAccountsRegistry.loading.get(cacheKey);
            } catch (error) {
              console.error('Falha anterior ao carregar contas correntes:', error);
            }
            const cached = bankAccountsRegistry.cache.get(cacheKey) || [];
            registerBankAccounts(cached);
            return cached;
          }

          const query = companyId ? `?company=${encodeURIComponent(companyId)}` : '';
          const requestPromise = (async () => {
            bankAccountsRegistry.error = null;
            try {
              const response = await fetch(`${bankAccountsEndpoint}${query}`, {
                headers: buildAuthHeaders(),
              });

              let payload = null;
              try {
                payload = await response.json();
              } catch (error) {
                payload = null;
              }

              if (response.status === 401 || response.status === 403) {
                handleAuthError();
              }

              if (!response.ok) {
                const message =
                  (payload && (payload.message || payload.error)) ||
                  'Não foi possível carregar as contas correntes.';
                const error = new Error(message);
                error.status = response.status;
                throw error;
              }

              const accounts = Array.isArray(payload?.accounts) ? payload.accounts : [];
              registerBankAccounts(accounts);
              bankAccountsRegistry.cache.set(cacheKey, accounts);
              bankAccountsRegistry.lastLoadedAt = Date.now();
              return accounts;
            } catch (error) {
              bankAccountsRegistry.error = error;
              throw error;
            }
          })();

          bankAccountsRegistry.loading.set(cacheKey, requestPromise);

          try {
            return await requestPromise;
          } finally {
            bankAccountsRegistry.loading.delete(cacheKey);
          }
        };

        const syncBankAccountWithDuplicates = () => {
          if (!lastNfeData) return;
          const duplicates = Array.isArray(lastNfeData.duplicates) ? lastNfeData.duplicates : [];
          const selectedId = bankAccountSelect ? bankAccountSelect.value : '';
          const normalizedSelected = selectedId ? String(selectedId) : '';
          lastNfeData.selectedBankAccountId = normalizedSelected || pendingBankAccountId || '';

          if (!duplicates.length) {
            renderDuplicatasFromNfe(duplicates, lastNfeData);
            return;
          }

          duplicates.forEach((duplicate) => {
            if (!duplicate || typeof duplicate !== 'object') return;
            if (duplicate.bankAccountIsManual) return;
            duplicate.bankAccount = normalizedSelected ? String(normalizedSelected) : null;
          });

          renderDuplicatasFromNfe(duplicates, lastNfeData);
        };

        const refreshBankAccountOptions = async ({ preserveSelection = true } = {}) => {
          if (!bankAccountSelect) return;

          const companyId = companySelect ? companySelect.value : '';
          if (!companyId) {
            pendingBankAccountId = '';
            setBankAccountPlaceholder('Selecione uma empresa para listar as contas correntes');
            if (lastNfeData && Array.isArray(lastNfeData.duplicates)) {
              lastNfeData.duplicates.forEach((duplicate) => {
                if (!duplicate || typeof duplicate !== 'object') return;
                duplicate.bankAccount = null;
                duplicate.bankAccountIsManual = false;
              });
              lastNfeData.selectedBankAccountId = '';
              renderDuplicatasFromNfe(lastNfeData.duplicates, lastNfeData);
            }
            return;
          }

          setBankAccountPlaceholder('Carregando contas correntes...', { disabled: true });

          try {
            const accounts = await loadBankAccountsForCompany(companyId);
            setBankAccountOptions(accounts);

            let desiredValue = '';
            if (preserveSelection && lastNfeData && lastNfeData.selectedBankAccountId) {
              desiredValue = String(lastNfeData.selectedBankAccountId);
            }
            if (!desiredValue && pendingBankAccountId) {
              desiredValue = pendingBankAccountId;
            }

            if (desiredValue) {
              const applied = setBankAccountSelectValue(desiredValue);
              if (!applied) {
                pendingBankAccountId = desiredValue;
                bankAccountSelect.value = '';
              } else if (pendingBankAccountId === desiredValue) {
                pendingBankAccountId = '';
              }
            } else {
              pendingBankAccountId = '';
              bankAccountSelect.value = '';
            }
          } catch (error) {
            console.error('Erro ao carregar contas correntes:', error);
            notify(
              error?.message || 'Não foi possível carregar as contas correntes da empresa selecionada.',
              'error'
            );
            setBankAccountPlaceholder('Erro ao carregar contas correntes');
            pendingBankAccountId = '';
          }

          bankAccountSelect.disabled = bankAccountSelect.options.length <= 1;
          syncBankAccountWithDuplicates();
        };

        const setDepositPlaceholder = (message, { disabled = true } = {}) => {
          if (!depositSelect) return;
          depositSelect.innerHTML = '';
          const option = document.createElement('option');
          option.value = '';
          option.textContent = message;
          depositSelect.appendChild(option);
          depositSelect.disabled = Boolean(disabled);
        };

        const registerCompanies = (companies = []) => {
          if (!Array.isArray(companies)) return [];
          companies.forEach((company) => {
            if (!company || !company._id) return;
            companyRegistry.index.set(String(company._id), company);
          });
          return companies;
        };

        const formatCompanyDocument = (value) => {
          const digits = digitsOnly(value);
          if (digits.length === 14) {
            return digits.replace(/(\d{2})(\d{3})(\d{3})(\d{4})(\d{2})/, '$1.$2.$3/$4-$5');
          }
          if (digits.length === 11) {
            return digits.replace(/(\d{3})(\d{3})(\d{3})(\d{2})/, '$1.$2.$3-$4');
          }
          return digits;
        };

        const buildCompanyLabel = (company) => {
          if (!company || typeof company !== 'object') return 'Empresa';
          const normalize = (value) => (typeof value === 'string' ? value.trim() : '');
          const name =
            normalize(company.nomeFantasia) ||
            normalize(company.nome) ||
            normalize(company.razaoSocial) ||
            normalize(company.fantasyName) ||
            normalize(company.razonSocial) ||
            '';
          const documentValue =
            company?.cnpj ||
            company?.documento ||
            company?.document ||
            company?.cpfCnpj ||
            company?.taxId ||
            '';
          const formattedDocument = formatCompanyDocument(documentValue);
          if (name && formattedDocument) {
            return `${name} • ${formattedDocument}`;
          }
          if (name) return name;
          if (formattedDocument) return formattedDocument;
          return 'Empresa';
        };

        const setCodeLookupCompanyPlaceholder = (message, { disabled = true } = {}) => {
          if (!codeLookupCompanySelect) return;
          codeLookupCompanySelect.innerHTML = '';
          const option = document.createElement('option');
          option.value = '';
          option.textContent = message;
          codeLookupCompanySelect.appendChild(option);
          codeLookupCompanySelect.disabled = Boolean(disabled);
        };

        const setCodeLookupCompanyOptions = (companies = [], { placeholder = null } = {}) => {
          if (!codeLookupCompanySelect) return;
          codeLookupCompanySelect.innerHTML = '';
          const defaultOption = document.createElement('option');
          defaultOption.value = '';
          defaultOption.textContent = placeholder || 'Selecione uma empresa';
          codeLookupCompanySelect.appendChild(defaultOption);
          if (Array.isArray(companies)) {
            companies.forEach((company) => {
              if (!company || !company._id) return;
              const option = document.createElement('option');
              option.value = String(company._id);
              option.textContent = buildCompanyLabel(company);
              const documentValue =
                company?.cnpj ||
                company?.documento ||
                company?.document ||
                company?.cpfCnpj ||
                company?.taxId ||
                '';
              const digits = digitsOnly(documentValue);
              if (digits && option.dataset) {
                option.dataset.companyDocument = digits;
              }
              codeLookupCompanySelect.appendChild(option);
            });
          }
          codeLookupCompanySelect.disabled = !companies || !companies.length;
        };

        const setCompanyPlaceholder = (message, { disabled = true } = {}) => {
          if (companySelect) {
            companySelect.innerHTML = '';
            const option = document.createElement('option');
            option.value = '';
            option.textContent = message;
            companySelect.appendChild(option);
            companySelect.disabled = Boolean(disabled);
          }
          if (pendingCompanySelect) {
            pendingCompanySelect.innerHTML = '';
            const option = document.createElement('option');
            option.value = '';
            option.textContent = message;
            pendingCompanySelect.appendChild(option);
            pendingCompanySelect.disabled = Boolean(disabled);
          }
          setCodeLookupCompanyPlaceholder(message, { disabled });
        };

        const setCompanyOptions = (companies = [], { placeholder = null } = {}) => {
          if (companySelect) {
            companySelect.innerHTML = '';
            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.textContent = placeholder || 'Selecione a empresa';
            companySelect.appendChild(defaultOption);
            if (Array.isArray(companies)) {
              companies.forEach((company) => {
                if (!company || !company._id) return;
                const option = document.createElement('option');
                option.value = String(company._id);
                option.textContent = buildCompanyLabel(company);
                const documentValue =
                  company?.cnpj ||
                  company?.documento ||
                  company?.document ||
                  company?.cpfCnpj ||
                  company?.taxId ||
                  '';
                const digits = digitsOnly(documentValue);
                if (digits && option.dataset) {
                  option.dataset.companyDocument = digits;
                }
                companySelect.appendChild(option);
              });
            }
            companySelect.disabled = !companies || !companies.length;
          }
          if (pendingCompanySelect) {
            const previousValue = pendingCompanySelect.value || '';
            let preserveSelection = false;
            pendingCompanySelect.innerHTML = '';
            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.textContent = placeholder || 'Selecione a empresa';
            pendingCompanySelect.appendChild(defaultOption);
            if (Array.isArray(companies)) {
              companies.forEach((company) => {
                if (!company || !company._id) return;
                const option = document.createElement('option');
                option.value = String(company._id);
                option.textContent = buildCompanyLabel(company);
                const documentValue =
                  company?.cnpj ||
                  company?.documento ||
                  company?.document ||
                  company?.cpfCnpj ||
                  company?.taxId ||
                  '';
                const digits = digitsOnly(documentValue);
                if (digits && option.dataset) {
                  option.dataset.companyDocument = digits;
                }
                if (option.value === previousValue) {
                  preserveSelection = true;
                }
                pendingCompanySelect.appendChild(option);
              });
            }
            pendingCompanySelect.disabled = !companies || !companies.length;
            if (preserveSelection) {
              pendingCompanySelect.value = previousValue;
            } else {
              pendingCompanySelect.value = '';
            }
          }
          setCodeLookupCompanyOptions(companies, {
            placeholder: placeholder || 'Selecione a empresa',
          });
        };

        const formatDateToInputValue = (date) => {
          if (!(date instanceof Date) || Number.isNaN(date.getTime())) {
            return '';
          }
          const year = date.getFullYear();
          const month = String(date.getMonth() + 1).padStart(2, '0');
          const day = String(date.getDate()).padStart(2, '0');
          return `${year}-${month}-${day}`;
        };

        const parseDateString = (value) => {
          if (value instanceof Date && !Number.isNaN(value.getTime())) {
            return value;
          }
          if (!value && value !== 0) return null;
          const raw = String(value).trim();
          if (!raw) return null;
          if (/^\d{4}-\d{2}-\d{2}$/.test(raw)) {
            const fromIso = new Date(`${raw}T00:00:00`);
            return Number.isNaN(fromIso.getTime()) ? null : fromIso;
          }
          const parsed = new Date(raw);
          return Number.isNaN(parsed.getTime()) ? null : parsed;
        };

        const parseDateFromInputValue = (value) => {
          if (!value) return null;
          const raw = String(value).trim();
          if (!raw) return null;
          const parsed = new Date(`${raw}T00:00:00`);
          return Number.isNaN(parsed.getTime()) ? null : parsed;
        };

        const formatDateForDisplay = (value) => {
          const date = parseDateString(value);
          if (!date) return '';
          const day = String(date.getDate()).padStart(2, '0');
          const month = String(date.getMonth() + 1).padStart(2, '0');
          const year = String(date.getFullYear());
          return `${day}/${month}/${year}`;
        };

        const formatSupplierDocumentValue = (value) => {
          const digits = digitsOnly(value);
          if (digits.length === 14) {
            return digits.replace(/(\d{2})(\d{3})(\d{3})(\d{4})(\d{2})/, '$1.$2.$3/$4-$5');
          }
          if (digits.length === 11) {
            return digits.replace(/(\d{3})(\d{3})(\d{3})(\d{2})/, '$1.$2.$3-$4');
          }
          return digits || '';
        };

        const pendingStatusStyles = {
          pending: {
            label: 'Pendente',
            classes: ['bg-amber-100', 'text-amber-700'],
          },
          cadastrado: {
            label: 'Cadastrada',
            classes: ['bg-sky-100', 'text-sky-700'],
          },
          cadastrada: {
            label: 'Cadastrada',
            classes: ['bg-sky-100', 'text-sky-700'],
          },
          registered: {
            label: 'Cadastrada',
            classes: ['bg-sky-100', 'text-sky-700'],
          },
          approved: {
            label: 'Aprovada',
            classes: ['bg-emerald-100', 'text-emerald-700'],
          },
          aprovado: {
            label: 'Aprovada',
            classes: ['bg-emerald-100', 'text-emerald-700'],
          },
          aprovada: {
            label: 'Aprovada',
            classes: ['bg-emerald-100', 'text-emerald-700'],
          },
        };

        const sefazStatusStyles = {
          authorized: {
            label: 'Autorizada',
            classes: ['bg-emerald-100', 'text-emerald-700'],
          },
          cancelled: {
            label: 'Cancelada',
            classes: ['bg-rose-100', 'text-rose-700'],
          },
          denied: {
            label: 'Denegada',
            classes: ['bg-amber-200', 'text-amber-800'],
          },
          registered: {
            label: 'Cadastrada',
            classes: ['bg-sky-100', 'text-sky-700'],
          },
        };

        const normalizeSefazStatus = (value) => {
          if (typeof value !== 'string') return 'registered';
          const normalized = value
            .normalize('NFD')
            .replace(/[\u0300-\u036f]/g, '')
            .trim()
            .toLowerCase();
          if (!normalized) return 'registered';

          if (['authorized', 'autorizada', 'autorizado', 'approved', 'aprovada', 'aprovado'].includes(normalized)) {
            return 'authorized';
          }
          if (['cancelled', 'cancelada', 'cancelado', 'canceled'].includes(normalized)) {
            return 'cancelled';
          }
          if (['denied', 'denegada', 'denegado'].includes(normalized)) {
            return 'denied';
          }
          if (
            [
              'registered',
              'registrada',
              'registrado',
              'pending',
              'pendente',
              'cadastrada',
              'cadastrado',
            ].includes(normalized)
          ) {
            return 'registered';
          }

          return sefazStatusStyles[normalized] ? normalized : 'registered';
        };

        const buildPendingSefazStatusBadge = (status) => {
          const normalized = normalizeSefazStatus(status);
          const style = sefazStatusStyles[normalized] || sefazStatusStyles.registered;
          const badge = document.createElement('span');
          badge.classList.add(
            'inline-flex',
            'items-center',
            'rounded-full',
            'px-2',
            'py-0.5',
            'text-[10px]',
            'font-semibold',
            'uppercase',
            'tracking-wide'
          );
          badge.classList.add(...style.classes);
          badge.textContent = style.label;
          return badge;
        };

        const normalizePendingStatus = (value) => {
          if (typeof value !== 'string') return 'pending';
          const normalized = value
            .normalize('NFD')
            .replace(/[\u0300-\u036f]/g, '')
            .trim()
            .toLowerCase();
          if (!normalized) return 'pending';
          if (pendingStatusStyles[normalized]) return normalized;
          if (normalized === 'draft') return 'pending';
          return 'pending';
        };

        const buildPendingStatusBadge = (status) => {
          const normalized = normalizePendingStatus(status);
          const style = pendingStatusStyles[normalized] || pendingStatusStyles.pending;
          const badge = document.createElement('span');
          badge.classList.add(
            'inline-flex',
            'items-center',
            'rounded-full',
            'px-2',
            'py-0.5',
            'text-[10px]',
            'font-semibold',
            'uppercase',
            'tracking-wide'
          );
          badge.classList.add(...style.classes);
          badge.textContent = style.label;
          return badge;
        };

        const validateCompanyCertificate = (companyId) => {
          const normalized = companyId ? String(companyId) : '';
          if (!normalized) {
            return {
              valid: false,
              message: 'Selecione uma empresa para consultar as notas autorizadas.',
            };
          }

          const record = companyRegistry.index.get(normalized) || null;
          if (!record) {
            return {
              valid: false,
              message:
                'Não foi possível localizar a empresa selecionada. Atualize a lista de empresas e tente novamente.',
            };
          }

          const hasCertificate = Boolean(
            (record.certificadoArquivoNome && record.certificadoArquivoNome.trim()) ||
              (record.certificadoFingerprint && record.certificadoFingerprint.trim()) ||
              (record.certificadoValidade && record.certificadoValidade.trim())
          );

          if (!hasCertificate) {
            return {
              valid: false,
              message: 'A empresa selecionada não possui certificado digital cadastrado.',
            };
          }

          const validityDate = parseDateString(record.certificadoValidade);
          if (validityDate) {
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            if (validityDate < today) {
              return {
                valid: false,
                message:
                  'O certificado digital da empresa está vencido. Atualize o certificado para consultar a SEFAZ.',
              };
            }
          }

          return { valid: true, record };
        };

        const setPendingLoading = (isLoading) => {
          if (pendingLoadingRow) {
            pendingLoadingRow.classList.toggle('hidden', !isLoading);
          }
          if (pendingGenerateButton) {
            pendingGenerateButton.disabled = Boolean(isLoading);
            pendingGenerateButton.classList.toggle('cursor-wait', Boolean(isLoading));
            pendingGenerateButton.classList.toggle('opacity-70', Boolean(isLoading));
          }
          if (pendingTable) {
            pendingTable.classList.toggle('opacity-60', Boolean(isLoading));
          }
        };

        const hidePendingFeedback = () => {
          if (pendingErrorRow) {
            pendingErrorRow.classList.add('hidden');
          }
          if (pendingEmptyRow) {
            pendingEmptyRow.classList.add('hidden');
          }
        };

        const showPendingError = (message) => {
          if (pendingErrorMessage) {
            pendingErrorMessage.textContent = message || defaultPendingErrorText || '';
          }
          if (pendingErrorRow) {
            pendingErrorRow.classList.remove('hidden');
          }
          if (pendingEmptyRow) {
            pendingEmptyRow.classList.add('hidden');
          }
        };

        const showPendingEmpty = (message) => {
          if (pendingEmptyCell) {
            pendingEmptyCell.innerHTML = message || defaultPendingEmptyContent || '';
          }
          if (pendingEmptyRow) {
            pendingEmptyRow.classList.remove('hidden');
          }
          if (pendingErrorRow) {
            pendingErrorRow.classList.add('hidden');
          }
        };

        const clearPendingRows = () => {
          if (!pendingTableBody) return;
          const rows = pendingTableBody.querySelectorAll('tr[data-pending-row]');
          rows.forEach((row) => row.remove());
        };

        const renderPendingDocuments = (documents = []) => {
          clearPendingRows();
          if (!Array.isArray(documents) || !documents.length) {
            const emptyMessage = pendingHasPerformedSearch
              ? 'Nenhuma nota autorizada foi encontrada para o período informado.'
              : defaultPendingEmptyContent;
            showPendingEmpty(emptyMessage);
            return;
          }

          if (!pendingRowTemplate || !pendingTableBody) {
            showPendingError('Estrutura da tabela de notas pendentes não foi encontrada.');
            return;
          }

          hidePendingFeedback();

          documents.forEach((document) => {
            const row = pendingRowTemplate.cloneNode(true);
            row.classList.remove('hidden');
            row.removeAttribute('data-pending-row-template');
            row.dataset.pendingRow = 'true';

            const danfeButton = row.querySelector('[data-pending-danfe]');
            if (danfeButton) {
              danfeButton.disabled = true;
              danfeButton.classList.add('opacity-60', 'cursor-not-allowed');
              danfeButton.dataset.pendingDocumentId = document.id || '';
            }

            const importButton = row.querySelector('[data-pending-import]');
            if (importButton) {
              importButton.disabled = true;
              importButton.classList.add('opacity-60', 'cursor-not-allowed');
              importButton.dataset.pendingDocumentId = document.id || '';
            }

            const registerButton = row.querySelector('[data-pending-register-supplier]');
            if (registerButton) {
              const hasSupplierDocument = Boolean(
                document.supplierDocument && document.supplierDocument.length >= 11
              );
              registerButton.classList.toggle('hidden', hasSupplierDocument);
              registerButton.dataset.pendingDocumentId = document.id || '';
            }

            const supplierDocumentCell = row.querySelector('[data-pending-supplier-document]');
            if (supplierDocumentCell) {
              supplierDocumentCell.textContent =
                formatSupplierDocumentValue(document.supplierDocument) || '—';
            }

            const supplierNameElement = row.querySelector('[data-pending-supplier-name]');
            if (supplierNameElement) {
              supplierNameElement.textContent =
                document.supplierName || 'Fornecedor não informado';
            }

            const issueDateCell = row.querySelector('[data-pending-issue-date]');
            if (issueDateCell) {
              issueDateCell.textContent =
                formatDateForDisplay(document.issueDate || document.createdAt) || '—';
            }

            const serieCell = row.querySelector('[data-pending-series]');
            if (serieCell) {
              serieCell.textContent = document.serie || '—';
            }

            const numberCell = row.querySelector('[data-pending-number]');
            if (numberCell) {
              numberCell.textContent = document.number || '—';
            }

            const totalCell = row.querySelector('[data-pending-total]');
            if (totalCell) {
              const numericTotal = Number(document.totalValue);
              totalCell.textContent = Number.isFinite(numericTotal)
                ? formatCurrencyBRL(numericTotal)
                : 'R$ 0,00';
            }

            const accessKeyCell = row.querySelector('[data-pending-access-key]');
            if (accessKeyCell) {
              accessKeyCell.textContent = document.accessKey || '—';
            }

            const sefazStatusCell = row.querySelector('[data-pending-sefaz-status]');
            if (sefazStatusCell) {
              sefazStatusCell.innerHTML = '';
              sefazStatusCell.appendChild(
                buildPendingSefazStatusBadge(document.sefazStatus || 'registered')
              );
            }

            const statusCell = row.querySelector('[data-pending-status]');
            if (statusCell) {
              statusCell.innerHTML = '';
              statusCell.appendChild(buildPendingStatusBadge(document.status));
            }

            pendingTableBody.appendChild(row);
          });
        };

        const requestPendingDocuments = async () => {
          if (!pendingCompanySelect) {
            notify('Não foi possível localizar o seletor de empresas.', 'error');
            return;
          }

          const companyId = pendingCompanySelect.value || '';
          const certificateCheck = validateCompanyCertificate(companyId);
          if (!certificateCheck.valid) {
            showPendingError(certificateCheck.message);
            notify(certificateCheck.message, 'warning');
            return;
          }

          const startRaw = pendingPeriodStartInput ? pendingPeriodStartInput.value : '';
          const endRaw = pendingPeriodEndInput ? pendingPeriodEndInput.value : '';
          const startDate = parseDateFromInputValue(startRaw);
          const endDate = parseDateFromInputValue(endRaw);

          if (startDate && endDate && endDate < startDate) {
            const message = 'O período informado é inválido. Ajuste as datas e tente novamente.';
            showPendingError(message);
            notify(message, 'warning');
            return;
          }

          if (pendingDocumentsAbortController) {
            pendingDocumentsAbortController.abort();
          }
          pendingDocumentsAbortController = new AbortController();

          const params = new URLSearchParams();
          params.set('companyId', companyId);
          if (startRaw) params.set('startDate', startRaw);
          if (endRaw) params.set('endDate', endRaw);

          setPendingLoading(true);
          hidePendingFeedback();
          clearPendingRows();

          try {
            const response = await fetch(`${pendingDocumentsEndpoint}?${params.toString()}`, {
              headers: buildAuthHeaders(),
              signal: pendingDocumentsAbortController.signal,
            });

            let payload = null;
            try {
              payload = await response.json();
            } catch (error) {
              payload = null;
            }

            if (!response.ok) {
              const message =
                (payload && (payload.message || payload.error)) ||
                'Não foi possível consultar as notas autorizadas. Tente novamente em instantes.';
              showPendingError(message);
              notify(message, response.status >= 500 ? 'error' : 'warning');
              return;
            }

            const documents = Array.isArray(payload?.documents) ? payload.documents : [];
            pendingHasPerformedSearch = true;
            renderPendingDocuments(documents);

            if (documents.length) {
              notify('Consulta concluída com sucesso.', 'success');
            } else {
              notify('Nenhuma nota autorizada foi encontrada para o período informado.', 'info');
            }
          } catch (error) {
            if (error?.name === 'AbortError') return;
            console.error('Erro ao consultar notas autorizadas na SEFAZ:', error);
            const message =
              error?.message ||
              'Não foi possível consultar as notas autorizadas. Verifique a conexão e tente novamente.';
            showPendingError(message);
            notify(message, 'error');
          } finally {
            setPendingLoading(false);
          }
        };

        const setPendingPeriodDefaults = () => {
          if (!pendingPeriodStartInput || !pendingPeriodEndInput) return;
          const now = new Date();
          const firstDay = new Date(now.getFullYear(), now.getMonth(), 1);
          const lastDay = new Date(now.getFullYear(), now.getMonth() + 1, 0);
          if (!pendingPeriodStartInput.value) {
            pendingPeriodStartInput.value = formatDateToInputValue(firstDay);
          }
          if (!pendingPeriodEndInput.value) {
            pendingPeriodEndInput.value = formatDateToInputValue(lastDay);
          }
        };

        setPendingPeriodDefaults();

        const setCompanySelectValue = (value) => {
          if (!companySelect) return false;
          const normalized = value ? String(value) : '';
          const option = Array.from(companySelect.options || []).find((opt) => opt.value === normalized);
          if (option) {
            companySelect.value = normalized;
            return true;
          }
          return false;
        };

        const findCompanyOptionByDocument = (documentDigits) => {
          if (!companySelect || !documentDigits) return null;
          const normalized = digitsOnly(documentDigits);
          if (!normalized) return null;
          return (
            Array.from(companySelect.options || [])
              .filter((option) => option.value)
              .find((option) => {
                let optionDigits = option.dataset?.companyDocument;
                if (!optionDigits) {
                  optionDigits = digitsOnly(`${option.value}${option.textContent || ''}`);
                  if (optionDigits && option.dataset) {
                    option.dataset.companyDocument = optionDigits;
                  }
                }
                if (!optionDigits) return false;
                return optionDigits === normalized || optionDigits.includes(normalized) || normalized.includes(optionDigits);
              }) || null
          );
        };

        const loadCompaniesFromApi = async (forceReload = false) => {
          if (!companiesEndpoint) return [];

          if (!forceReload && Array.isArray(companyRegistry.cache) && companyRegistry.cache.length) {
            registerCompanies(companyRegistry.cache);
            return companyRegistry.cache;
          }

          if (!forceReload && companyRegistry.loading) {
            try {
              await companyRegistry.loading;
            } catch (error) {
              console.error('Falha anterior ao carregar empresas:', error);
            }
            registerCompanies(companyRegistry.cache);
            return companyRegistry.cache;
          }

          const requestPromise = (async () => {
            companyRegistry.error = null;
            try {
              const response = await fetch(companiesEndpoint, {
                headers: buildAuthHeaders(),
              });

              let payload = null;
              try {
                payload = await response.json();
              } catch (error) {
                payload = null;
              }

              if (response.status === 401 || response.status === 403) {
                handleAuthError();
              }

              if (!response.ok) {
                const message =
                  (payload && (payload.message || payload.error)) ||
                  'Não foi possível carregar as empresas.';
                const error = new Error(message);
                error.status = response.status;
                throw error;
              }

              const companies = Array.isArray(payload?.stores)
                ? payload.stores
                : Array.isArray(payload)
                ? payload
                : [];

              registerCompanies(companies);
              companyRegistry.cache = companies;
              companyRegistry.lastLoadedAt = Date.now();
              return companies;
            } catch (error) {
              companyRegistry.error = error;
              throw error;
            }
          })();

          companyRegistry.loading = requestPromise;

          try {
            return await requestPromise;
          } finally {
            companyRegistry.loading = null;
          }
        };

        const refreshCompanyOptions = async ({ preserveSelection = true } = {}) => {
          if (!companySelect) return { value: '', changed: false };

          const previousValue = companySelect.value || '';
          const desiredFromData =
            (preserveSelection && previousValue) ||
            (lastNfeData && lastNfeData.selectedCompanyId ? String(lastNfeData.selectedCompanyId) : '') ||
            pendingCompanyId ||
            '';
          const documentDigits =
            pendingCompanyDocumentDigits ||
            (lastNfeData && lastNfeData.dest?.document ? digitsOnly(lastNfeData.dest.document) : '');

          setCompanyPlaceholder('Carregando empresas...', { disabled: true });

          try {
            const companies = await loadCompaniesFromApi();
            const placeholder = companies.length
              ? 'Selecione a empresa'
              : 'Nenhuma empresa cadastrada';
            setCompanyOptions(companies, { placeholder });

            let applied = false;
            if (desiredFromData) {
              applied = setCompanySelectValue(desiredFromData);
              if (applied) {
                pendingCompanyId = '';
                pendingCompanyDocumentDigits = '';
              } else {
                pendingCompanyId = desiredFromData;
              }
            }

            if (!applied && documentDigits) {
              const match = findCompanyOptionByDocument(documentDigits);
              if (match) {
                companySelect.value = match.value;
                applied = true;
                pendingCompanyId = '';
                pendingCompanyDocumentDigits = '';
              } else {
                pendingCompanyDocumentDigits = documentDigits;
              }
            }

            if (!applied && companies.length === 1 && companies[0]?._id) {
              const singleValue = String(companies[0]._id);
              companySelect.value = singleValue;
              applied = true;
              pendingCompanyId = '';
              pendingCompanyDocumentDigits = '';
            }

            companySelect.disabled = !companies.length;

            if (!applied) {
              companySelect.value = '';
              if (!companies.length) {
                setBankAccountPlaceholder('Cadastre uma empresa para listar as contas correntes');
                setDepositPlaceholder('Cadastre uma empresa para listar os depósitos');
              } else {
                setBankAccountPlaceholder('Selecione uma empresa para listar as contas correntes');
                setDepositPlaceholder('Selecione uma empresa para listar os depósitos');
              }
              return { value: '', changed: previousValue !== companySelect.value };
            }

            if (lastNfeData) {
              lastNfeData.selectedCompanyId = companySelect.value || '';
            }

            const changed = previousValue !== companySelect.value;
            if (changed) {
              companySelect.dispatchEvent(new Event('change', { bubbles: true }));
            }

            return { value: companySelect.value || '', changed };
          } catch (error) {
            console.error('Erro ao carregar empresas:', error);
            notify(
              error?.message ||
                'Não foi possível carregar as empresas cadastradas. Tente novamente em instantes.',
              'error'
            );
            setCompanyPlaceholder('Erro ao carregar empresas', { disabled: true });
            companySelect.disabled = true;
            pendingCompanyId = '';
            pendingCompanyDocumentDigits = '';
            return { value: '', changed: false };
          }
        };

        const registerDeposits = (deposits = []) => {
          if (!Array.isArray(deposits)) return [];
          deposits.forEach((deposit) => {
            if (!deposit || !deposit._id) return;
            depositRegistry.index.set(String(deposit._id), deposit);
          });
          return deposits;
        };

        const buildDepositLabel = (deposit) => {
          if (!deposit || typeof deposit !== 'object') return 'Depósito';
          const normalize = (value) => (typeof value === 'string' ? value.trim() : '');
          const name = normalize(deposit.nome);
          const code = normalize(deposit.codigo);
          let companyName = '';
          const company = deposit.empresa;
          if (company && typeof company === 'object') {
            companyName =
              normalize(company.nomeFantasia) ||
              normalize(company.nome) ||
              normalize(company.razaoSocial) ||
              '';
          }
          const parts = [];
          if (name) parts.push(name);
          if (code) parts.push(`Cód. ${code}`);
          if (companyName) parts.push(companyName);
          return parts.join(' • ') || 'Depósito';
        };

        const setDepositOptions = (deposits = [], { placeholder = null } = {}) => {
          if (!depositSelect) return;

          depositSelect.innerHTML = '';
          const defaultOption = document.createElement('option');
          defaultOption.value = '';
          defaultOption.textContent =
            placeholder ||
            (Array.isArray(deposits) && deposits.length
              ? 'Selecione o depósito'
              : 'Nenhum depósito cadastrado para esta empresa');
          depositSelect.appendChild(defaultOption);

          if (Array.isArray(deposits)) {
            deposits.forEach((deposit) => {
              if (!deposit || !deposit._id) return;
              const option = document.createElement('option');
              option.value = String(deposit._id);
              option.textContent = buildDepositLabel(deposit);
              depositSelect.appendChild(option);
            });
          }

          depositSelect.disabled = !deposits || !deposits.length;
        };

        const setDepositSelectValue = (value) => {
          if (!depositSelect) return false;
          const normalized = value ? String(value) : '';
          if (!normalized) {
            depositSelect.value = '';
            return true;
          }
          const options = Array.from(depositSelect.options || []);
          const match = options.find((option) => option.value === normalized);
          if (match) {
            depositSelect.value = normalized;
            return true;
          }
          return false;
        };

        const loadDepositsForCompany = async (companyId = '') => {
          if (!depositsEndpoint) return [];
          const normalizedCompanyId = companyId ? String(companyId) : '';
          const cacheKey = normalizedCompanyId || '__all__';

          if (depositRegistry.cache.has(cacheKey)) {
            const cached = depositRegistry.cache.get(cacheKey) || [];
            registerDeposits(cached);
            return cached;
          }

          if (depositRegistry.loading.has(cacheKey)) {
            try {
              await depositRegistry.loading.get(cacheKey);
            } catch (error) {
              console.error('Falha anterior ao carregar depósitos:', error);
            }
            const cached = depositRegistry.cache.get(cacheKey) || [];
            registerDeposits(cached);
            return cached;
          }

          const query = normalizedCompanyId ? `?empresa=${encodeURIComponent(normalizedCompanyId)}` : '';
          const requestPromise = (async () => {
            depositRegistry.error = null;
            try {
              const response = await fetch(`${depositsEndpoint}${query}`, {
                headers: buildAuthHeaders(),
              });

              let payload = null;
              try {
                payload = await response.json();
              } catch (error) {
                payload = null;
              }

              if (response.status === 401 || response.status === 403) {
                handleAuthError();
              }

              if (!response.ok) {
                const message =
                  (payload && (payload.message || payload.error)) ||
                  'Não foi possível carregar os depósitos.';
                const error = new Error(message);
                error.status = response.status;
                throw error;
              }

              const deposits = Array.isArray(payload?.deposits) ? payload.deposits : [];
              registerDeposits(deposits);
              depositRegistry.cache.set(cacheKey, deposits);
              depositRegistry.lastLoadedAt = Date.now();
              return deposits;
            } catch (error) {
              depositRegistry.error = error;
              throw error;
            }
          })();

          depositRegistry.loading.set(cacheKey, requestPromise);

          try {
            return await requestPromise;
          } finally {
            depositRegistry.loading.delete(cacheKey);
          }
        };

        const refreshDepositOptions = async ({ preserveSelection = true } = {}) => {
          if (!depositSelect) return;

          const companyId = companySelect ? companySelect.value : '';
          const normalizedCompanyId = companyId ? String(companyId) : '';

          if (!normalizedCompanyId) {
            pendingDepositId = '';
            setDepositPlaceholder('Selecione uma empresa para listar os depósitos');
            if (lastNfeData) {
              lastNfeData.selectedDepositId = '';
            }
            return;
          }

          setDepositPlaceholder('Carregando depósitos...', { disabled: true });

          try {
            const deposits = await loadDepositsForCompany(normalizedCompanyId);
            const availableDeposits = Array.isArray(deposits)
              ? deposits.filter((deposit) => {
                  const rawCompany = deposit?.empresa;
                  if (!rawCompany) return true;
                  if (typeof rawCompany === 'object') {
                    const companyValue =
                      rawCompany?._id ||
                      rawCompany?.id ||
                      (typeof rawCompany.valueOf === 'function' ? rawCompany.valueOf() : '');
                    return String(companyValue) === normalizedCompanyId;
                  }
                  return String(rawCompany) === normalizedCompanyId;
                })
              : [];

            setDepositOptions(availableDeposits, {
              placeholder: availableDeposits.length
                ? 'Selecione o depósito'
                : 'Nenhum depósito cadastrado para esta empresa',
            });

            let desiredValue = '';
            if (pendingDepositId) {
              desiredValue = pendingDepositId;
            } else if (preserveSelection) {
              desiredValue =
                depositSelect.value ||
                (lastNfeData && lastNfeData.selectedDepositId ? String(lastNfeData.selectedDepositId) : '');
            }

            if (desiredValue) {
              const applied = setDepositSelectValue(desiredValue);
              if (!applied) {
                pendingDepositId = desiredValue;
              } else {
                pendingDepositId = '';
                if (lastNfeData) {
                  lastNfeData.selectedDepositId = desiredValue;
                }
              }
            } else if (availableDeposits.length === 1 && availableDeposits[0]?._id) {
              const singleValue = String(availableDeposits[0]._id);
              if (setDepositSelectValue(singleValue)) {
                pendingDepositId = '';
                if (lastNfeData) {
                  lastNfeData.selectedDepositId = singleValue;
                }
              }
            } else {
              setDepositSelectValue('');
              if (lastNfeData) {
                lastNfeData.selectedDepositId = '';
              }
            }

            depositSelect.disabled = !availableDeposits.length;
          } catch (error) {
            console.error('Erro ao carregar depósitos:', error);
            notify(
              error?.message ||
                'Não foi possível carregar os depósitos da empresa selecionada. Tente novamente em instantes.',
              'error'
            );
            setDepositPlaceholder('Não foi possível carregar os depósitos.', { disabled: true });
          }
        };

        const normalizeSupplierCalcType = (value) => {
          if (typeof value !== 'string') return '';
          return value
            .normalize('NFD')
            .replace(/[\u0300-\u036f]/g, '')
            .trim()
            .toLowerCase();
        };

        const canonicalSupplierCalcType = (value) => {
          const normalized = normalizeSupplierCalcType(value);
          if (!normalized) return '';
          if (normalized.startsWith('multi') || normalized === 'x') {
            return 'multiply';
          }
          if (normalized.startsWith('div')) {
            return 'divide';
          }
          return '';
        };

        const parseSupplierCalcValue = (rawValue) => {
          if (Number.isFinite(rawValue)) {
            return rawValue > 0 ? rawValue : null;
          }
          const numeric = parseNumber(rawValue);
          return Number.isFinite(numeric) && numeric > 0 ? numeric : null;
        };

        const getBaseConversionFactor = (item) => {
          if (!item) return 1;
          const original = Number.isFinite(item?.originalConversionFactor)
            ? item.originalConversionFactor
            : parseNumber(item?.originalConversionFactor);
          if (Number.isFinite(original) && original > 0) {
            return original;
          }
          const multiplier = Number.isFinite(item?.conversionMultiplier)
            ? item.conversionMultiplier
            : parseNumber(item?.conversionMultiplier);
          const divider = Number.isFinite(item?.conversionDivider)
            ? item.conversionDivider
            : parseNumber(item?.conversionDivider);
          if (Number.isFinite(multiplier) && Number.isFinite(divider) && divider > 0) {
            return multiplier / divider;
          }
          const conversion = Number.isFinite(item?.conversion) ? item.conversion : parseNumber(item?.conversion);
          if (Number.isFinite(conversion) && conversion > 0) {
            return conversion;
          }
          return 1;
        };

        const findSupplierEntryForProduct = (product, item, nfeData) => {
          if (!product) return null;
          const suppliers = Array.isArray(product?.fornecedores) ? product.fornecedores : [];
          if (!suppliers.length) return null;

          const supplierInfo = resolveActiveSupplierInfo(nfeData);
          const normalizedSupplierName = canonicalSupplierName(supplierInfo.name);
          const itemSupplierCode = canonicalSupplierProductCode(item?.supplierCode);

          let candidates = suppliers;

          if (itemSupplierCode) {
            const codeMatches = suppliers.filter(
              (entry) => canonicalSupplierProductCode(entry?.codigoProduto) === itemSupplierCode
            );
            if (codeMatches.length) {
              candidates = codeMatches;
            }
          }

          if (normalizedSupplierName) {
            const nameMatches = candidates.filter(
              (entry) => canonicalSupplierName(entry?.fornecedor) === normalizedSupplierName
            );
            if (nameMatches.length) {
              candidates = nameMatches;
            }
          }

          const hasValidCalc = (entry) =>
            Boolean(canonicalSupplierCalcType(entry?.tipoCalculo)) && parseSupplierCalcValue(entry?.valorCalculo) !== null;

          const prioritized = candidates.filter(hasValidCalc);
          if (prioritized.length) {
            return prioritized[0];
          }

          const fallbackWithCalc = suppliers.filter(hasValidCalc);
          if (fallbackWithCalc.length) {
            return fallbackWithCalc[0];
          }

          return candidates[0] || suppliers[0] || null;
        };

        const applySupplierConversionFromProduct = (item, product, nfeData) => {
          if (!item || !product) return false;
          if (item.manualConversionOverride) return false;

          const supplierEntry = findSupplierEntryForProduct(product, item, nfeData);
          if (!supplierEntry) {
            item.supplierAppliedConversion = null;
            return false;
          }

          const calcType = canonicalSupplierCalcType(supplierEntry?.tipoCalculo);
          const calcValue = parseSupplierCalcValue(supplierEntry?.valorCalculo);
          if (!calcType || calcValue === null) {
            item.supplierAppliedConversion = null;
            item.manualConversionOverride = false;
            return false;
          }

          let baseFactor = getBaseConversionFactor(item);
          if (!Number.isFinite(baseFactor) || baseFactor <= 0) {
            baseFactor = 1;
          }

          let adjustedFactor = baseFactor;
          if (calcType === 'multiply') {
            adjustedFactor = baseFactor * calcValue;
          } else if (calcType === 'divide') {
            adjustedFactor = baseFactor / calcValue;
          }

          if (!Number.isFinite(adjustedFactor) || adjustedFactor <= 0) {
            item.supplierAppliedConversion = null;
            item.manualConversionOverride = false;
            return false;
          }

          const currentFactor = Number.isFinite(item?.conversion) ? item.conversion : parseNumber(item?.conversion);
          const alreadyApplied =
            item?.supplierAppliedConversion &&
            Number.isFinite(item.supplierAppliedConversion?.factor) &&
            Math.abs(item.supplierAppliedConversion.factor - adjustedFactor) <= 0.0005 &&
            item.supplierAppliedConversion.type === calcType &&
            item.supplierAppliedConversion.value === calcValue;

          if (alreadyApplied && Number.isFinite(currentFactor)) {
            item.manualConversionOverride = false;
            return false;
          }

          item.conversion = adjustedFactor;
          item.conversionMultiplier = adjustedFactor;
          item.conversionDivider = 1;
          item.supplierAppliedConversion = {
            type: calcType,
            value: calcValue,
            factor: adjustedFactor,
            supplierCode: canonicalSupplierProductCode(supplierEntry?.codigoProduto),
            supplierName: supplierEntry?.fornecedor || '',
            baseFactor,
          };
          item.manualConversionOverride = false;
          return true;
        };

        const ensureProductSupplierLink = (product, item, nfeData) => {
          const productId = product?._id || product?.id;
          const normalizedCode = canonicalSupplierProductCode(item?.supplierCode);
          if (!productId || !normalizedCode) {
            return null;
          }

          const supplierInfo = resolveActiveSupplierInfo(nfeData);
          const supplierName = typeof supplierInfo.name === 'string' ? supplierInfo.name.trim() : '';
          const normalizedSupplierName = canonicalSupplierName(supplierName);
          const supplierDocumentDigits = digitsOnly(supplierInfo.document);
          if (!normalizedSupplierName) {
            return null;
          }

          const cacheKeySegments = [String(productId).trim(), normalizedCode];
          if (supplierDocumentDigits) {
            cacheKeySegments.splice(1, 0, `DOC:${supplierDocumentDigits}`);
          } else if (normalizedSupplierName) {
            cacheKeySegments.splice(1, 0, `NAME:${normalizedSupplierName}`);
          }
          const cacheKey = cacheKeySegments.join('::');
          if (productSupplierLinkCache.has(cacheKey)) {
            return null;
          }
          if (productSupplierLinkPromises.has(cacheKey)) {
            return productSupplierLinkPromises.get(cacheKey);
          }

          const currentLinks = Array.isArray(product?.fornecedores) ? product.fornecedores : [];
          const alreadyLinked = currentLinks.some((entry) => {
            if (canonicalSupplierProductCode(entry?.codigoProduto) !== normalizedCode) {
              return false;
            }
            const entryDocumentDigits = digitsOnly(entry?.documentoFornecedor);
            const entrySupplierName = canonicalSupplierName(entry?.fornecedor);
            if (supplierDocumentDigits && entryDocumentDigits) {
              return entryDocumentDigits === supplierDocumentDigits;
            }
            return entrySupplierName === normalizedSupplierName;
          });
          if (alreadyLinked) {
            productSupplierLinkCache.add(cacheKey);
            return null;
          }

          if (!supplierName) {
            return null;
          }

          const payload = {
            fornecedor: supplierName,
            nomeProdutoFornecedor: item?.description || '',
            codigoProduto: item?.supplierCode || '',
            unidadeEntrada: item?.unit || item?.unitTrib || '',
            documentoFornecedor: supplierDocumentDigits,
          };

          const headers = buildAuthHeaders();
          headers.set('Content-Type', 'application/json');

          const requestPromise = (async () => {
            const response = await fetch(`${apiBaseUrl}/products/${productId}/suppliers/link`, {
              method: 'POST',
              headers,
              body: JSON.stringify(payload),
            });
            const result = await response.json().catch(() => ({}));
            if (!response.ok) {
              const message =
                result?.message ||
                `Falha ao vincular produto ao fornecedor (status ${response.status}).`;
              throw new Error(message);
            }

            if (Array.isArray(result?.fornecedores)) {
              product.fornecedores = result.fornecedores;
            } else if (result?.fornecedor) {
              const updatedList = Array.isArray(product.fornecedores)
                ? [...product.fornecedores, result.fornecedor]
                : [result.fornecedor];
              product.fornecedores = updatedList;
            }

            productSupplierLinkCache.add(cacheKey);
            return result;
          })()
            .catch((error) => {
              throw error;
            })
            .finally(() => {
              productSupplierLinkPromises.delete(cacheKey);
            });

          productSupplierLinkPromises.set(cacheKey, requestPromise);
          return requestPromise;
        };

        const computeSupplierFactorAdjustment = (item, nfeData) => {
          if (!item || !item.matchedProduct) return null;

          const toNumeric = (value) => (Number.isFinite(value) ? value : parseNumber(value));
          const targetFactor = toNumeric(item?.conversion);
          if (!Number.isFinite(targetFactor) || targetFactor <= 0) {
            return null;
          }

          let baseFactor = getBaseConversionFactor(item);
          if (!Number.isFinite(baseFactor) || baseFactor <= 0) {
            baseFactor = 1;
          }

          const supplierEntry = findSupplierEntryForProduct(item.matchedProduct, item, nfeData);
          const existingType = canonicalSupplierCalcType(supplierEntry?.tipoCalculo);
          const existingValue = parseSupplierCalcValue(supplierEntry?.valorCalculo);

          if (existingType && Number.isFinite(existingValue)) {
            const computedFactor = (() => {
              if (existingType === 'divide') {
                return existingValue > 0 ? baseFactor / existingValue : null;
              }
              return baseFactor * existingValue;
            })();
            if (
              Number.isFinite(computedFactor) &&
              Math.abs(computedFactor - targetFactor) <= FACTOR_COMPARISON_TOLERANCE
            ) {
              return null;
            }
          }

          let ratio = targetFactor / baseFactor;
          let calcType = 'multiply';

          if (!Number.isFinite(ratio) || ratio <= 0) {
            if (targetFactor <= 0) {
              return null;
            }
            ratio = baseFactor / targetFactor;
            calcType = 'divide';
          }

          if (!Number.isFinite(ratio) || ratio <= 0) {
            return null;
          }

          const normalizedRatio = Number.parseFloat(ratio.toFixed(6));
          if (!Number.isFinite(normalizedRatio) || normalizedRatio <= 0) {
            return null;
          }

          if (
            existingType &&
            existingType === calcType &&
            Number.isFinite(existingValue) &&
            Math.abs(existingValue - normalizedRatio) <= FACTOR_COMPARISON_TOLERANCE
          ) {
            return null;
          }

          return {
            calcType,
            calcValue: normalizedRatio,
            supplierEntry,
            targetFactor,
            baseFactor,
          };
        };

        const updateSupplierFactorForItem = (item, nfeData) => {
          if (!item || !item.matchedProduct) return null;

          const productId = getProductIdFromRecord(item.matchedProduct);
          if (!productId) return null;

          const supplierInfo = resolveActiveSupplierInfo(nfeData);
          const supplierName = typeof supplierInfo.name === 'string' ? supplierInfo.name.trim() : '';
          if (!supplierName) return null;

          const supplierCode = canonicalSupplierProductCode(item?.supplierCode);
          if (!supplierCode) return null;

          const adjustment = computeSupplierFactorAdjustment(item, nfeData);
          if (!adjustment) return null;

          const cacheKey = [productId, supplierCode, adjustment.calcType, adjustment.calcValue].join('::');
          if (supplierFactorUpdatePromises.has(cacheKey)) {
            return supplierFactorUpdatePromises.get(cacheKey);
          }

          const headers = buildAuthHeaders();
          headers.set('Content-Type', 'application/json');

          const payload = {
            fornecedor: supplierName,
            codigoProduto: item?.supplierCode || '',
            nomeProdutoFornecedor: item?.description || '',
            unidadeEntrada: item?.unit || item?.unitTrib || '',
            documentoFornecedor: supplierInfo.document || '',
            tipoCalculo: adjustment.calcType,
            valorCalculo: adjustment.calcValue,
          };

          const requestPromise = (async () => {
            const response = await fetch(`${apiBaseUrl}/products/${productId}/suppliers/link`, {
              method: 'POST',
              headers,
              body: JSON.stringify(payload),
            });
            const result = await response.json().catch(() => ({}));
            if (!response.ok) {
              const contextLabel =
                item?.matchedProduct?.nome || item?.description || item?.supplierCode || 'produto';
              const message = result?.message || `Falha ao atualizar o fator do ${contextLabel}.`;
              throw new Error(message);
            }

            if (Array.isArray(result?.fornecedores)) {
              item.matchedProduct.fornecedores = result.fornecedores;
            } else if (result?.fornecedor) {
              const current = Array.isArray(item.matchedProduct.fornecedores)
                ? [...item.matchedProduct.fornecedores]
                : [];
              const normalizedCode = canonicalSupplierProductCode(result.fornecedor?.codigoProduto);
              const normalizedName = canonicalSupplierName(result.fornecedor?.fornecedor);
              let replaced = false;
              const updatedList = current.map((entry) => {
                const entryCode = canonicalSupplierProductCode(entry?.codigoProduto);
                const entryName = canonicalSupplierName(entry?.fornecedor);
                if (!replaced && entryCode === normalizedCode && entryName === normalizedName) {
                  replaced = true;
                  return result.fornecedor;
                }
                return entry;
              });
              if (!replaced) {
                updatedList.push(result.fornecedor);
              }
              item.matchedProduct.fornecedores = updatedList;
            }

            item.manualConversionOverride = false;
            item.supplierAppliedConversion = {
              type: adjustment.calcType,
              value: adjustment.calcValue,
              factor: adjustment.targetFactor,
              baseFactor: adjustment.baseFactor,
              supplierCode,
              supplierName,
            };

            return result;
          })()
            .catch((error) => {
              throw error;
            })
            .finally(() => {
              supplierFactorUpdatePromises.delete(cacheKey);
            });

          supplierFactorUpdatePromises.set(cacheKey, requestPromise);
          return requestPromise;
        };

        const syncSupplierFactorsForItems = async (items, nfeData) => {
          if (!Array.isArray(items) || !items.length) return;
          const promises = [];
          items.forEach((item) => {
            if (item?.validationStatus !== 'matched' || !item?.matchedProduct) {
              return;
            }
            const updatePromise = updateSupplierFactorForItem(item, nfeData);
            if (updatePromise && typeof updatePromise.then === 'function') {
              promises.push(updatePromise);
            }
          });
          if (!promises.length) return;
          await Promise.all(promises);
        };

        const normalizeInternalCode = (value) => {
          if (typeof value === 'number' && Number.isFinite(value)) {
            return String(value);
          }
          if (typeof value === 'string') {
            return value.trim();
          }
          return '';
        };

        const buildTemporaryInternalCode = (index = 0) => {
          const sequence = Number.isFinite(index) ? index + 1 : 1;
          return `${INTERNAL_CODE_PREFIX}${String(sequence).padStart(5, '0')}`;
        };

        const ensureUniqueInternalCodes = (items) => {
          if (!Array.isArray(items) || !items.length) return;

          const usedCodes = new Set();

          items.forEach((item) => {
            const matchedCode = normalizeInternalCode(getProductCodeFromRecord(item?.matchedProduct));
            if (matchedCode) {
              item.internalCode = matchedCode;
            }
          });

          items.forEach((item, index) => {
            const baseCode = normalizeInternalCode(item.internalCode) || buildTemporaryInternalCode(item.index ?? index);
            let candidate = baseCode;
            let attempt = 1;

            while (usedCodes.has(candidate)) {
              attempt += 1;
              candidate = `${baseCode}-${String(attempt).padStart(2, '0')}`;
            }

            item.internalCode = candidate;
            usedCodes.add(candidate);
          });
        };

        const getProductCodeFromRecord = (product) =>
          product?.codigoInterno ||
          product?.cod ||
          product?.codigo ||
          product?.codInterno ||
          product?.codigoReferencia ||
          product?.sku ||
          product?.id ||
          '';

        const getProductNameFromRecord = (product) =>
          product?.nome ||
          product?.name ||
          product?.descricao ||
          product?.description ||
          product?.titulo ||
          product?.title ||
          '';

        const PRODUCT_BARCODE_FIELDS = [
          'codigoBarras',
          'codigoDeBarras',
          'barras',
          'ean',
          'eanTrib',
          'codbarras',
          'barcode',
          'codigo_barras',
        ];

        const getProductBarcodeFromRecord = (product) => {
          if (!product || typeof product !== 'object') return '';
          for (const field of PRODUCT_BARCODE_FIELDS) {
            const normalized = normalizeBarcodeForComparison(product[field]);
            if (normalized) return normalized;
          }
          if (Array.isArray(product.variacoes)) {
            for (const variation of product.variacoes) {
              const normalized = normalizeBarcodeForComparison(
                variation?.codigoBarras || variation?.barcode || variation?.ean
              );
              if (normalized) return normalized;
            }
          }
          return '';
        };

        const getOptionDocument = (option) => {
          if (!option) return '';
          const existingDataset = option.dataset?.supplierDocument;
          if (existingDataset) {
            return existingDataset;
          }
          const digits = digitsOnly(`${option.value}${option.textContent || ''}`);
          if (digits && option.dataset) {
            option.dataset.supplierDocument = digits;
          }
          return digits;
        };

        const formatDocumentForOption = (value) => {
          const digits = digitsOnly(value);
          if (digits.length === 14) {
            return digits.replace(/(\d{2})(\d{3})(\d{3})(\d{4})(\d{2})/, '$1.$2.$3/$4-$5');
          }
          if (digits.length === 11) {
            return digits.replace(/(\d{3})(\d{3})(\d{3})(\d{2})/, '$1.$2.$3-$4');
          }
          return digits;
        };

        const buildSupplierOptionLabel = (supplier, documentDigits) => {
          const formattedDocument = formatDocumentForOption(documentDigits);
          const name =
            supplier?.legalName ||
            supplier?.fantasyName ||
            supplier?.name ||
            formattedDocument;
          const codeValue = supplier?.code ?? supplier?.codeNumber;
          let codeText = '';
          if (typeof codeValue === 'number' && Number.isFinite(codeValue)) {
            codeText = `Código ${String(codeValue).padStart(4, '0')}`;
          } else if (typeof codeValue === 'string' && codeValue.trim()) {
            codeText = `Código ${codeValue.trim()}`;
          }
          return [formattedDocument, name, codeText].filter(Boolean).join(' · ');
        };

        const findSupplierOptionByDocument = (documentDigits) => {
          if (!supplierSelect || !documentDigits) return null;
          return (
            Array.from(supplierSelect.options || []).find(
              (option) => getOptionDocument(option) === documentDigits
            ) || null
          );
        };

        const ensureSupplierOption = (supplier, documentDigits) => {
          if (!supplierSelect || !documentDigits) return null;
          const existingOption = findSupplierOptionByDocument(documentDigits);
          const option = existingOption || document.createElement('option');
          const optionValue = supplier?._id || documentDigits;
          option.value = optionValue;
          option.textContent = buildSupplierOptionLabel(supplier, documentDigits);
          option.dataset.supplierDocument = documentDigits;
          if (supplier?._id) {
            option.dataset.supplierId = supplier._id;
          }
          option.dataset.supplierName =
            supplier?.legalName || supplier?.fantasyName || supplier?.name || '';
          if (!existingOption) {
            supplierSelect.appendChild(option);
          }
          return option;
        };

        const setSupplierSelectValue = (value) => {
          if (!supplierSelect) return false;
          const normalized = value ? String(value) : '';
          if (!normalized) return false;
          const option = Array.from(supplierSelect.options || []).find(
            (entry) => entry.value === normalized
          );
          if (option) {
            supplierSelect.value = normalized;
            return true;
          }
          return false;
        };

        const applyPendingSupplierSelection = () => {
          if (!supplierSelect) return false;

          if (pendingSupplierId && setSupplierSelectValue(pendingSupplierId)) {
            pendingSupplierId = '';
            pendingSupplierDocument = '';
            const selectedOption =
              supplierSelect.selectedOptions && supplierSelect.selectedOptions.length
                ? supplierSelect.selectedOptions[0]
                : null;
            if (selectedOption) {
              const optionDocument = digitsOnly(selectedOption.dataset?.supplierDocument || '');
              const registered = optionDocument
                ? supplierRegistry.byDocument.get(optionDocument) || null
                : null;
              if (registered) {
                lastSupplierRecord = registered;
              } else if (optionDocument) {
                lastSupplierRecord = {
                  _id: selectedOption.dataset?.supplierId || null,
                  legalName: selectedOption.dataset?.supplierName || '',
                  cnpj: optionDocument,
                };
              }
            }
            supplierSelect.dispatchEvent(new Event('change', { bubbles: true }));
            return true;
          }

          if (pendingSupplierDocument) {
            const option = findSupplierOptionByDocument(pendingSupplierDocument);
            if (option) {
              supplierSelect.value = option.value;
              pendingSupplierId = '';
              pendingSupplierDocument = '';
              const optionDocument = digitsOnly(option.dataset?.supplierDocument || '');
              const registered = optionDocument
                ? supplierRegistry.byDocument.get(optionDocument) || null
                : null;
              if (registered) {
                lastSupplierRecord = registered;
              } else if (optionDocument) {
                lastSupplierRecord = {
                  _id: option.dataset?.supplierId || null,
                  legalName: option.dataset?.supplierName || '',
                  cnpj: optionDocument,
                };
              }
              supplierSelect.dispatchEvent(new Event('change', { bubbles: true }));
              return true;
            }
          }

          return false;
        };

        const registerSupplierRecord = (supplier) => {
          if (!supplier) return null;
          const documentDigits = digitsOnly(supplier.cnpj || supplier.document);
          if (!documentDigits) return null;
          supplierRegistry.byDocument.set(documentDigits, supplier);
          return ensureSupplierOption(supplier, documentDigits);
        };

        const indexExistingSupplierOptions = () => {
          if (!supplierSelect) return;
          Array.from(supplierSelect.options || []).forEach((option) => {
            const digits = getOptionDocument(option);
            if (!digits) return;
            option.dataset.supplierDocument = digits;
          });
        };

        const loadSuppliersFromApi = async (forceReload = false) => {
          if (!suppliersEndpoint) {
            applyPendingSupplierSelection();
            return supplierRegistry.byDocument;
          }
          if (forceReload) {
            supplierRegistry.loaded = false;
          }
          if (supplierRegistry.loaded && !forceReload) {
            applyPendingSupplierSelection();
            return supplierRegistry.byDocument;
          }
          if (supplierRegistry.loadingPromise) {
            try {
              await supplierRegistry.loadingPromise;
            } catch (_) {
              // Ignorar erros anteriores, o estado já foi atualizado
            }
            applyPendingSupplierSelection();
            return supplierRegistry.byDocument;
          }
          supplierRegistry.loadingPromise = (async () => {
            try {
              supplierRegistry.error = null;
              const response = await fetch(suppliersEndpoint, {
                headers: buildAuthHeaders(),
              });
              const data = await response.json().catch(() => ({}));
              if (!response.ok) {
                if (response.status === 401) {
                  handleAuthError();
                }
                throw new Error(data?.message || `Falha ao consultar fornecedores (status ${response.status})`);
              }
              const suppliers = Array.isArray(data?.suppliers) ? data.suppliers : [];
              supplierRegistry.byDocument.clear();
              suppliers.forEach((entry) => {
                registerSupplierRecord(entry);
              });
              supplierRegistry.loaded = true;
              supplierRegistry.lastLoadedAt = Date.now();
            } catch (error) {
              supplierRegistry.error = error;
              supplierRegistry.loaded = false;
              console.error('Erro ao carregar fornecedores cadastrados:', error);
            } finally {
              supplierRegistry.loadingPromise = null;
            }
          })();
          try {
            await supplierRegistry.loadingPromise;
          } catch (_) {
            // Erro já tratado no bloco acima
          }
          applyPendingSupplierSelection();
          return supplierRegistry.byDocument;
        };

        const setText = (element, value, fallback = '') => {
          if (!element) return;
          element.textContent = value || fallback;
        };

        const setInputValue = (element, value) => {
          if (!element) return;
          element.value = value ?? '';
        };

        const setSummaryInput = (key, value) => {
          const element = importSummaryFields[key];
          if (!element) return;
          element.value = value ?? '';
        };

        const formatDocument = (value) => {
          const digits = digitsOnly(value);
          if (digits.length === 14) {
            return `CNPJ ${digits.replace(/(\d{2})(\d{3})(\d{3})(\d{4})(\d{2})/, '$1.$2.$3/$4-$5')}`;
          }
          if (digits.length === 11) {
            return `CPF ${digits.replace(/(\d{3})(\d{3})(\d{3})(\d{2})/, '$1.$2.$3-$4')}`;
          }
          return digits || value || '';
        };

        const composeDocumentLine = (documentValue, stateRegistration) => {
          const documentText = formatDocument(documentValue);
          if (documentText && stateRegistration) {
            return `${documentText} · IE ${stateRegistration}`;
          }
          if (documentText) return documentText;
          if (stateRegistration) return `IE ${stateRegistration}`;
          return '';
        };

        const formatCep = (value) => {
          const digits = digitsOnly(value);
          if (digits.length === 8) {
            return digits.replace(/(\d{5})(\d{3})/, '$1-$2');
          }
          return digits || '';
        };

        const formatPhone = (value) => {
          const digits = digitsOnly(value);
          if (digits.length === 11) {
            return digits.replace(/(\d{2})(\d{5})(\d{4})/, '($1) $2-$3');
          }
          if (digits.length === 10) {
            return digits.replace(/(\d{2})(\d{4})(\d{4})/, '($1) $2-$3');
          }
          return digits || '';
        };

        const formatCurrencyBRL = (value) => {
          const numeric = Number.parseFloat(String(value || '').replace(',', '.'));
          if (Number.isFinite(numeric)) {
            return numeric.toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' });
          }
          return 'R$ 0,00';
        };

        const parseMoneyInputValue = (value) => {
          if (value === null || typeof value === 'undefined') return null;
          const raw = String(value).trim();
          if (!raw) return null;

          const cleaned = raw
            .replace(/[^0-9.,-]/g, '')
            .replace(/\.(?=\d{3}(?:\D|$))/g, '')
            .replace(',', '.');

          const numeric = Number.parseFloat(cleaned);
          if (Number.isFinite(numeric)) {
            return numeric;
          }

          const fallback = Number.parseFloat(raw.replace(/[^0-9.-]/g, ''));
          return Number.isFinite(fallback) ? fallback : null;
        };

        const clonePlainObject = (value) => {
          if (value === null || typeof value === 'undefined') return null;
          try {
            return JSON.parse(JSON.stringify(value));
          } catch (error) {
            console.warn('Não foi possível clonar os dados informados para o rascunho.', error);
            return null;
          }
        };

        const formatDraftCode = (code) => {
          if (code === null || typeof code === 'undefined') return '';
          const numeric = Number(code);
          if (Number.isFinite(numeric)) {
            return String(Math.trunc(numeric)).padStart(4, '0');
          }
          return String(code).trim();
        };

        const applyDraftCodeToInput = (codeValue) => {
          if (!nfeCodeInput) return;
          if (codeValue === null || typeof codeValue === 'undefined' || codeValue === '') {
            nfeCodeInput.value = '';
            delete nfeCodeInput.dataset.rawCode;
            return;
          }
          const formatted = formatDraftCode(codeValue);
          nfeCodeInput.value = formatted;
          nfeCodeInput.dataset.rawCode = String(codeValue);
        };

        const determineDraftStatusKey = (status) => {
          const normalized = String(status ?? '').trim().toLowerCase();
          if (normalized === 'approved' || normalized === 'aprovado' || normalized === 'aprovada') {
            return 'approved';
          }
          if (!normalized || normalized === 'draft' || normalized === 'rascunho' || normalized === 'cadastrada') {
            return 'draft';
          }
          return normalized;
        };

        const defaultRegisterIconClass = registerEntryIcon ? registerEntryIcon.className : '';
        const defaultRegisterText = registerEntryText ? registerEntryText.textContent || '' : '';
        const defaultDeleteIconClass = deleteEntryIcon ? deleteEntryIcon.className : '';
        const defaultDeleteText = deleteEntryText ? deleteEntryText.textContent || '' : '';

        const setApproveButtonState = (isProcessing) => {
          if (!registerEntryButton) return;
          const shouldDisable = Boolean(isProcessing) || isFormLocked;
          registerEntryButton.disabled = shouldDisable;
          registerEntryButton.classList.toggle('opacity-60', shouldDisable);
          registerEntryButton.classList.toggle('cursor-wait', Boolean(isProcessing));
          if (registerEntryIcon) {
            registerEntryIcon.className = isProcessing ? 'fas fa-circle-notch fa-spin' : defaultRegisterIconClass;
          }
          if (registerEntryText) {
            if (isProcessing) {
              registerEntryText.textContent = 'Processando...';
            } else {
              registerEntryText.textContent = defaultRegisterText || 'Registrar entrada da NF-e';
            }
          }
        };

        const setDeleteButtonState = (isProcessing) => {
          if (!deleteEntryButton) return;
          const hasDraft = Boolean(currentDraftId);
          const shouldDisable = Boolean(isProcessing) || !hasDraft;
          deleteEntryButton.disabled = shouldDisable;
          deleteEntryButton.classList.toggle('opacity-60', shouldDisable);
          deleteEntryButton.classList.toggle('cursor-wait', Boolean(isProcessing));
          if (deleteEntryIcon) {
            deleteEntryIcon.className = isProcessing ? 'fas fa-circle-notch fa-spin' : defaultDeleteIconClass;
          }
          if (deleteEntryText) {
            deleteEntryText.textContent = isProcessing
              ? 'Excluindo...'
              : defaultDeleteText || 'Excluir nota';
          }
        };

        const togglePriceButtonState = (enabled) => {
          if (!priceAdjustmentButton) return;
          priceAdjustmentButton.disabled = !enabled;
          priceAdjustmentButton.classList.toggle('cursor-not-allowed', !enabled);
          priceAdjustmentButton.classList.toggle('opacity-60', !enabled);
          priceAdjustmentButton.classList.toggle('text-gray-400', !enabled);
          priceAdjustmentButton.classList.toggle('text-gray-600', enabled);
          priceAdjustmentButton.classList.toggle('hover:bg-gray-50', enabled);
        };

        const hasPriceAdjustableProducts = () =>
          Array.isArray(mainProductTableState?.items) &&
          mainProductTableState.items.some((item) => item?.matchedProduct);

        updatePriceButtonAvailability = (status) => {
          const normalized = determineDraftStatusKey(status ?? currentDraftStatus);
          const hasDraft = Boolean(currentDraftId);
          const shouldEnable = hasDraft && normalized === 'approved' && hasPriceAdjustableProducts();
          togglePriceButtonState(shouldEnable);
          if (!shouldEnable && priceAdjustmentState.isOpen) {
            closePriceAdjustmentModal();
          }
        };

        togglePriceButtonState(false);

        const lockStateRegistry = new WeakMap();

        const rememberLockState = (element) => {
          if (!element || typeof element !== 'object') return { disabled: false, readOnly: undefined };
          if (!lockStateRegistry.has(element)) {
            lockStateRegistry.set(element, {
              disabled: 'disabled' in element ? element.disabled : false,
              readOnly: 'readOnly' in element ? element.readOnly : undefined,
            });
          }
          return lockStateRegistry.get(element);
        };

        const shouldSkipFormControlLock = (element) => {
          if (!(element instanceof HTMLElement)) return true;
          if (element.hasAttribute('data-admin-screen-search-input')) return true;
          return false;
        };

        const shouldSkipButtonLock = (button) => {
          if (!(button instanceof HTMLButtonElement)) return true;
          if (button.dataset.tab) return true;
          if (button.hasAttribute('data-accordion-button')) return true;
          if (button.hasAttribute('data-close-code-modal')) return true;
          if (button.hasAttribute('data-close-product-modal')) return true;
          if (button.hasAttribute('data-close-product-link-modal')) return true;
          if (button.hasAttribute('data-admin-sidebar-trigger')) return true;
          if (button.hasAttribute('data-admin-sidebar-close')) return true;
          if (button.hasAttribute('data-delete-entry')) return true;
          if (button.hasAttribute('data-open-price-modal')) return true;
          return false;
        };

        const setFormLockState = (locked) => {
          isFormLocked = Boolean(locked);

          const formControls = document.querySelectorAll('input, select, textarea');
          formControls.forEach((element) => {
            if (!(element instanceof HTMLElement)) return;
            const original = rememberLockState(element);

            if (shouldSkipFormControlLock(element)) {
              if (!isFormLocked) {
                if ('readOnly' in element && typeof original.readOnly !== 'undefined') {
                  element.readOnly = Boolean(original.readOnly);
                } else if ('readOnly' in element) {
                  element.readOnly = false;
                }

                if ('disabled' in element) {
                  element.disabled = Boolean(original.disabled);
                }
              }
              element.classList.remove('cursor-not-allowed');
              return;
            }

            if (isFormLocked) {
              if ('readOnly' in element) {
                const type = (element.getAttribute('type') || '').toLowerCase();
                const useReadOnly =
                  element.tagName === 'TEXTAREA' ||
                  ['text', 'search', 'email', 'url', 'tel', 'number', 'password'].includes(type);
                if (useReadOnly) {
                  element.readOnly = true;
                } else if ('disabled' in element) {
                  element.disabled = true;
                }
              } else if ('disabled' in element) {
                element.disabled = true;
              }
              element.classList.add('cursor-not-allowed');
            } else {
              if ('readOnly' in element && typeof original.readOnly !== 'undefined') {
                element.readOnly = Boolean(original.readOnly);
              } else if ('readOnly' in element) {
                element.readOnly = false;
              }

              if ('disabled' in element) {
                element.disabled = Boolean(original.disabled);
              }

              element.classList.remove('cursor-not-allowed');
            }
          });

          const actionableButtons = document.querySelectorAll('button');
          actionableButtons.forEach((button) => {
            if (!(button instanceof HTMLButtonElement)) return;
            const original = rememberLockState(button);
            if (shouldSkipButtonLock(button)) {
              return;
            }

            if (isFormLocked) {
              button.disabled = true;
              button.classList.add('cursor-not-allowed', 'opacity-60');
            } else {
              button.disabled = Boolean(original.disabled);
              button.classList.remove('cursor-not-allowed', 'opacity-60');
            }
          });

          setApproveButtonState(isApprovingDraft);
        };

        const setDraftStatus = (status) => {
          const normalized = determineDraftStatusKey(status);
          currentDraftStatus = normalized;
          if (lastNfeData && typeof lastNfeData === 'object') {
            lastNfeData.status = normalized;
          }
          updateStatusBadgeDisplay(normalized);
          setFormLockState(normalized === 'approved');
          updateDeleteButtonState(normalized);
          return normalized;
        };

        const focusDuplicateField = (index, field) => {
          if (!duplicatasTableBody) return;
          const row = duplicatasTableBody.querySelector(`tr[data-duplicate-index="${index}"]`);
          if (!row) return;
          let target = null;
          if (field === 'dueDate') {
            target = row.querySelector('[data-duplicateDueInput="true"]');
          } else if (field === 'value') {
            target = row.querySelector('[data-duplicateValueInput="true"]');
          } else if (field === 'bankAccount') {
            target = row.querySelector('[data-duplicateBankSelect="true"]');
          }
          if (target instanceof HTMLElement) {
            target.focus({ preventScroll: false });
            if (typeof target.scrollIntoView === 'function') {
              target.scrollIntoView({ block: 'center', behavior: 'smooth' });
            }
          }
        };

        setApproveButtonState(false);

        const resetDraftState = () => {
          currentDraftId = '';
          currentDraftCode = '';
          applyDraftCodeToInput('');
          setDraftStatus('draft');
        };

        const readNumericInputValue = (input) => {
          if (!input) return null;
          const numeric = toNumeric(input.value);
          return Number.isFinite(numeric) ? numeric : null;
        };

        const computeDuplicatesTotal = (duplicates) => {
          if (!Array.isArray(duplicates)) return 0;
          return duplicates.reduce((sum, duplicate) => {
            const value = toNumeric(duplicate?.value);
            return Number.isFinite(value) ? sum + value : sum;
          }, 0);
        };

        const buildDraftPayloadFromForm = () => {
          const baseData = clonePlainObject(lastNfeData) || {};
          const supplierInfo = resolveActiveSupplierInfo(baseData);
          const supplierDocumentDigits = digitsOnly(supplierCnpjInput?.value || supplierInfo?.document || '');
          const supplierOptionLabel =
            supplierSelect && supplierSelect.selectedOptions && supplierSelect.selectedOptions.length
              ? supplierSelect.selectedOptions[0].dataset?.supplierName || supplierSelect.selectedOptions[0].textContent || ''
              : '';
          const supplierName = (supplierInfo?.name || supplierOptionLabel || '').trim();

          const duplicatesClone =
            clonePlainObject(baseData.duplicates) || clonePlainObject(lastNfeData?.duplicates) || [];
          const supplierAccountDetails = resolveSupplierAccountingAccount();
          if (Array.isArray(duplicatesClone)) {
            duplicatesClone.forEach((duplicate, index) => {
              if (!duplicate || typeof duplicate !== 'object') return;
              if (typeof duplicate.index === 'undefined') {
                duplicate.index = index;
              }
              applyAccountingAccountToDuplicate(duplicate, supplierAccountDetails, {
                preserveExisting: true,
              });
            });
          }

          const itemsSource =
            (Array.isArray(mainProductTableState?.items) && mainProductTableState.items.length
              ? mainProductTableState.items
              : baseData.items) || [];
          const itemsClone = clonePlainObject(itemsSource) || [];
          const referencesClone =
            clonePlainObject(baseData.references) || clonePlainObject(lastNfeData?.references) || [];
          const paymentsClone =
            clonePlainObject(baseData.payments) || clonePlainObject(lastNfeData?.payments) || [];

          const totalsSnapshot = {
            products: readNumericInputValue(totalsProductsInput),
            bonification: readNumericInputValue(totalsBonificationInput),
            icmsBase: readNumericInputValue(totalsIcmsBaseInput),
            icmsValue: readNumericInputValue(totalsIcmsValueInput),
            icmsSt: readNumericInputValue(totalsIcmsStInput),
            fcpSt: readNumericInputValue(totalsFcpStInput),
            discount: readNumericInputValue(totalsDiscountInput),
            other: readNumericInputValue(totalsOtherInput),
            freight: readNumericInputValue(totalsFreightInput),
            ipi: readNumericInputValue(totalsIpiInput),
            insurance: readNumericInputValue(totalsInsuranceInput),
            dollar: readNumericInputValue(totalsDollarInput),
          };

          if (!Number.isFinite(totalsSnapshot.products) && Number.isFinite(baseData?.totals?.products)) {
            totalsSnapshot.products = toNumeric(baseData.totals.products);
          }

          if (!Number.isFinite(totalsSnapshot.bonification) && Number.isFinite(baseData?.totals?.bonification)) {
            totalsSnapshot.bonification = toNumeric(baseData.totals.bonification);
          }

          const duplicatesTotal = computeDuplicatesTotal(duplicatesClone);
          const totalValueCandidate =
            toNumeric(baseData?.totals?.totalValue) ??
            (duplicatesTotal > 0 ? duplicatesTotal : totalsSnapshot.products);

          const headerSnapshot = {
            code: nfeCodeInput?.dataset?.rawCode || currentDraftCode || '',
            number: nfeNumberInput?.value?.trim() || '',
            serie: nfeSeriesInput?.value?.trim() || '',
            type: nfeTypeSelect ? nfeTypeSelect.value || '' : '',
            model: nfeModelSelect ? nfeModelSelect.value || '' : '',
            issueDate: issueDateInput?.value || '',
            entryDate: entryDateInput?.value || '',
          };

          const transportSnapshot = {
            mode: freightModeSelect ? freightModeSelect.value || '' : '',
            transporter: {
              document: transportCnpjInput?.value || '',
              stateRegistration: transportIeInput?.value || '',
              uf: transportUfSelect ? transportUfSelect.value || '' : '',
              name: transportNameInput?.value || '',
            },
            vehicle: {
              plate: transportPlateInput?.value || '',
              uf: transportPlateUfSelect ? transportPlateUfSelect.value || '' : '',
            },
            volume: {
              weightGross: readNumericInputValue(weightGrossInput),
              weightNet: readNumericInputValue(weightNetInput),
            },
          };

          const selectionSnapshot = {
            companyId: companySelect ? companySelect.value || '' : '',
            supplierId: supplierSelect ? supplierSelect.value || '' : '',
            depositId: depositSelect ? depositSelect.value || '' : '',
            bankAccountId: bankAccountSelect ? bankAccountSelect.value || '' : '',
            accountingAccount: accountingAccountInput?.value?.trim() || '',
            duplicataEmissionDate: duplicataEmissionInput?.value || '',
          };

          const additionalInfoSnapshot = {
            observation: observationInput?.value?.trim() || '',
            complementaryFiscal: complementaryInfoInput?.value?.trim() || '',
            paymentCondition: paymentConditionInput?.value?.trim() || '',
            paymentForm: paymentFormInput?.value?.trim() || '',
          };

          const xmlSnapshot = {
            accessKey: accessKeyInput?.value?.trim() || baseData?.accessKey || '',
            importAccessKey: importAccessKeyInput?.value?.trim() || '',
            ambient: baseData?.ambient || '',
          };

          return {
            draftId: currentDraftId || null,
            header: headerSnapshot,
            company: { id: selectionSnapshot.companyId },
            supplier: {
              id: selectionSnapshot.supplierId,
              name: supplierName,
              document: supplierDocumentDigits,
              stateRegistration: supplierIeInput?.value?.trim() || '',
              email: supplierEmailInput?.value?.trim() || '',
              addressText: supplierAddressInput?.value?.trim() || '',
            },
            totals: {
              ...totalsSnapshot,
              totalValue: Number.isFinite(totalValueCandidate) ? totalValueCandidate : null,
            },
            transport: transportSnapshot,
            duplicates: Array.isArray(duplicatesClone) ? duplicatesClone : [],
            duplicatesSummary: {
              totalAmount: duplicatesTotal,
              count: Array.isArray(duplicatesClone) ? duplicatesClone.length : 0,
            },
            items: Array.isArray(itemsClone) ? itemsClone : [],
            references: Array.isArray(referencesClone) ? referencesClone : [],
            payments: Array.isArray(paymentsClone) ? paymentsClone : [],
            additionalInfo: additionalInfoSnapshot,
            selection: selectionSnapshot,
            xml: xmlSnapshot,
            metadata: {
              savedAt: new Date().toISOString(),
              draftCode: currentDraftCode || null,
            },
            importedData: baseData,
          };
        };

        const applyDraftResponseToState = (draft) => {
          if (!draft || typeof draft !== 'object') return;
          if (draft._id || draft.id) {
            currentDraftId = String(draft._id || draft.id);
          }
          if (typeof draft.code !== 'undefined' && draft.code !== null) {
            currentDraftCode = String(draft.code);
            applyDraftCodeToInput(draft.code);
          } else if (draft.codeNumber) {
            currentDraftCode = String(draft.codeNumber);
            applyDraftCodeToInput(draft.codeNumber);
          }
          if (lastNfeData && typeof lastNfeData === 'object') {
            lastNfeData.draftId = currentDraftId;
            lastNfeData.draftCode = currentDraftCode;
          }
          setDraftStatus(draft.status);
        };

        const PAYMENT_METHOD_DESCRIPTIONS = {
          '01': 'Dinheiro',
          '02': 'Cheque',
          '03': 'Cartão de Crédito',
          '04': 'Cartão de Débito',
          '05': 'Crédito Loja',
          '10': 'Vale Alimentação',
          '11': 'Vale Refeição',
          '12': 'Vale Presente',
          '13': 'Vale Combustível',
          '14': 'Duplicata Mercantil',
          '15': 'Boleto Bancário',
          '16': 'Depósito Bancário',
          '17': 'Pagamento Instantâneo (PIX)',
          '18': 'Transferência bancária',
          '19': 'Programa de Fidelidade',
          '90': 'Sem pagamento',
          '99': 'Outros',
        };

        const describePaymentMethod = (code) => {
          if (!code && code !== 0) return '';
          const normalized = String(code).trim();
          if (!normalized) return '';
          const padded = normalized.length === 1 ? `0${normalized}` : normalized;
          return (
            PAYMENT_METHOD_DESCRIPTIONS[padded] ||
            PAYMENT_METHOD_DESCRIPTIONS[normalized] ||
            normalized
          );
        };

        const formatAddressLine = (address = {}) => {
          if (!address || typeof address !== 'object') return '';
          const parts = [];
          const streetParts = [];
          if (address.street) streetParts.push(address.street);
          if (address.number) streetParts.push(address.number);
          const streetLine = streetParts.join(', ');
          if (streetLine) parts.push(streetLine);
          if (address.complement) parts.push(address.complement);
          if (address.neighborhood) parts.push(address.neighborhood);
          const cityState = [address.city, address.state].filter(Boolean).join(' - ');
          if (cityState) parts.push(cityState);
          const cep = formatCep(address.cep);
          if (cep) parts.push(`CEP ${cep}`);
          if (address.country) parts.push(address.country);
          return parts.join(' · ');
        };

        const buildContactLine = (entity = {}) => {
          const parts = [];
          if (entity.email) parts.push(entity.email);
          const phone = formatPhone(entity.phone);
          if (phone) parts.push(phone);
          const mobile = formatPhone(entity.mobile);
          if (mobile && mobile !== phone) parts.push(mobile);
          return parts.length ? parts.join(' · ') : '';
        };

        const mapEnvironment = (value) => {
          if (value === '1') return 'Ambiente produção';
          if (value === '2') return 'Ambiente homologação';
          return 'Ambiente não identificado';
        };

        const mapFrete = (value) => {
          const map = {
            '0': '0 - Contratação do frete por conta do remetente (CIF)',
            '1': '1 - Contratação do frete por conta do destinatário/remetente (FOB)',
            '2': '2 - Contratação do frete por conta de terceiros',
            '3': '3 - Transporte próprio por conta do remetente',
            '4': '4 - Transporte próprio por conta do destinatário',
            '9': '9 - Sem frete',
          };
          return map[value] || value || '';
        };

        const formatIndIe = (value) => {
          const map = {
            '1': '1 - Contribuinte ICMS',
            '2': '2 - Contribuinte isento',
            '9': '9 - Não contribuinte ICMS',
          };
          return map[value] || value || '';
        };

        const mapModelToType = (model) => {
          if (model === '65') return 'NFCe';
          if (model === '55') return 'NF';
          return 'NF';
        };

        const MS_PER_DAY = 24 * 60 * 60 * 1000;

        const computeDateDiffInDays = (startInput, endInput) => {
          if (!startInput || !endInput) return null;
          const startDate = new Date(`${startInput}T00:00:00`);
          const endDate = new Date(`${endInput}T00:00:00`);
          if (Number.isNaN(startDate.getTime()) || Number.isNaN(endDate.getTime())) {
            return null;
          }
          return Math.round((endDate.getTime() - startDate.getTime()) / MS_PER_DAY);
        };

        const addDaysToDateInput = (baseInput, daysToAdd) => {
          if (!baseInput || !Number.isFinite(daysToAdd)) return '';
          const baseDate = new Date(`${baseInput}T00:00:00`);
          if (Number.isNaN(baseDate.getTime())) {
            return '';
          }
          const adjusted = new Date(baseDate.getTime());
          adjusted.setDate(adjusted.getDate() + daysToAdd);
          return adjusted.toISOString().slice(0, 10);
        };

        const addPaymentDaysToDateInput = (baseInput, termDays) => {
          if (!baseInput || !Number.isFinite(termDays)) return '';
          const normalizedOffset = termDays > 0 ? termDays - 1 : 0;
          return addDaysToDateInput(baseInput, normalizedOffset);
        };

        const stripDiacritics = (value) => {
          if (typeof value !== 'string') return '';
          return value.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
        };

        const computeInclusiveTermDays = (baseInput, dueInput) => {
          if (!baseInput || !dueInput) return null;
          const diff = computeDateDiffInDays(baseInput, dueInput);
          if (!Number.isFinite(diff)) return null;
          return diff > 0 ? diff + 1 : diff;
        };

        const extractPaymentConditionHint = (text) => {
          if (!text || typeof text !== 'string') return '';
          const compact = text.replace(/\s+/g, ' ');
          const keywordMatcher = /(cobranc[ao]|pagamento|parcelas?|boleto|duplicat[ao]s?|condica[oa])/i;
          const pattern = /(\d{1,3})(?:(?:\s*[\/\-]\s*|\s+)\d{1,3})+/g;
          let fallback = '';
          let match;
          while ((match = pattern.exec(compact)) !== null) {
            const segment = match[0];
            const parts = segment
              .split(/[\/\-\s]+/)
              .map((part) => part.trim())
              .filter(Boolean);
            if (parts.length < 2) continue;
            const normalizedParts = parts.map((part) => {
              const numeric = Number.parseInt(part, 10);
              if (!Number.isFinite(numeric) || numeric < 0 || numeric > 999) {
                return null;
              }
              return String(numeric);
            });
            if (normalizedParts.some((part) => part === null)) continue;
            const normalizedSegment = normalizedParts.join('/');
            if (!fallback) {
              fallback = normalizedSegment;
            }
            const contextStart = Math.max(0, match.index - 60);
            const contextEnd = Math.min(compact.length, match.index + segment.length + 60);
            const context = stripDiacritics(compact.slice(contextStart, contextEnd)).toLowerCase();
            if (keywordMatcher.test(context)) {
              return normalizedSegment;
            }
          }
          return fallback;
        };

        const normalizeDate = (value) => {
          if (!value) {
            return { dateInput: '', display: '', displayDateTime: '' };
          }
          let date = null;
          if (value.includes('T')) {
            date = new Date(value);
          } else if (/^\d{4}-\d{2}-\d{2}$/.test(value)) {
            date = new Date(`${value}T00:00:00`);
          } else if (/^\d{8}$/.test(value)) {
            const formatted = `${value.slice(0, 4)}-${value.slice(4, 6)}-${value.slice(6, 8)}`;
            date = new Date(`${formatted}T00:00:00`);
          }
          if (date && !Number.isNaN(date.getTime())) {
            return {
              dateInput: date.toISOString().slice(0, 10),
              display: date.toLocaleDateString('pt-BR'),
              displayDateTime: date.toLocaleString('pt-BR', { dateStyle: 'short', timeStyle: 'short' }),
            };
          }
          return { dateInput: '', display: value, displayDateTime: value };
        };

        const setSelectValue = (select, value) => {
          if (!select || typeof value === 'undefined' || value === null) return;
          const option = Array.from(select.options || []).find((item) => item.value === value);
          if (option) {
            select.value = option.value;
            select.dispatchEvent(new Event('change', { bubbles: true }));
          }
        };

        const resetSelectValue = (select, defaultValue = '') => {
          if (!select) return;
          const options = Array.from(select.options || []);
          if (typeof defaultValue !== 'undefined' && defaultValue !== null) {
            const hasMatch = options.some((option) => option.value === defaultValue);
            if (hasMatch || defaultValue === '') {
              select.value = defaultValue;
            } else if (options.length) {
              select.selectedIndex = 0;
            } else {
              select.value = '';
            }
          } else if (options.length) {
            select.selectedIndex = 0;
          } else {
            select.value = '';
          }
          select.dispatchEvent(new Event('change', { bubbles: true }));
        };

        const clearStatusClasses = (element, classes) => {
          if (!element) return;
          const targetClasses = classes && classes.length ? classes : ALL_STATUS_CLASSES;
          if (targetClasses.length) {
            element.classList.remove(...targetClasses);
          }
        };

        const applyStatusClasses = (element, type = 'info') => {
          if (!element) return;
          clearStatusClasses(element, ALL_STATUS_CLASSES);
          const classes = STATUS_CLASS_MAP[type] || STATUS_CLASS_MAP.info;
          element.classList.add(...classes);
        };

        const applyValidationStyles = (type = 'info') => {
          if (!importXmlValidationBadge) return;
          importXmlValidationBadge.classList.remove(...ALL_VALIDATION_CLASSES);
          importXmlValidationBadge.classList.add(...(VALIDATION_BADGE_STYLES[type] || VALIDATION_BADGE_STYLES.info));
          if (importXmlValidationIcon) {
            importXmlValidationIcon.className = `${VALIDATION_ICONS[type] || VALIDATION_ICONS.info} text-[11px]`;
          }
        };

        const clearStatusMessages = () => {
          if (importFileFeedback) {
            importFileFeedback.classList.add('hidden');
            importFileFeedback.textContent = '';
            clearStatusClasses(importFileFeedback, ALL_STATUS_CLASSES);
          }
          if (importSupplierStatus) {
            importSupplierStatus.classList.add('hidden');
            toggleSupplierStatusLayout(false);
            if (importSupplierMessage) importSupplierMessage.textContent = '';
            if (importSupplierDescription) {
              importSupplierDescription.textContent = '';
              importSupplierDescription.classList.remove('hidden');
            }
            if (importSupplierActions) {
              importSupplierActions.innerHTML = '';
              importSupplierActions.classList.add('hidden');
            }
            if (importSupplierIcon) {
              importSupplierIcon.className = 'fas fa-circle-info mt-0.5 text-[12px]';
            }
            clearStatusClasses(importSupplierStatus, ALL_STATUS_CLASSES);
          }
        };

        const showFileFeedback = (message, type = 'info') => {
          if (!importFileFeedback) return;
          importFileFeedback.textContent = message;
          importFileFeedback.classList.remove('hidden');
          applyStatusClasses(importFileFeedback, type);
        };

        const setSupplierSummary = (supplier) => {
          if (!importSupplierSummary) return;
          if (!supplier || (!supplier.name && !supplier.document)) {
            importSupplierSummary.classList.add('hidden');
            if (importSupplierSummaryName) importSupplierSummaryName.textContent = '';
            if (importSupplierSummaryDocument) importSupplierSummaryDocument.textContent = '';
            if (importSupplierSummaryIe) importSupplierSummaryIe.textContent = '';
            if (importSupplierSummaryAddress) importSupplierSummaryAddress.textContent = '';
            if (importSupplierSummaryContact) importSupplierSummaryContact.textContent = '';
            return;
          }
          importSupplierSummary.classList.remove('hidden');
          if (importSupplierSummaryName) {
            importSupplierSummaryName.textContent = supplier.name || 'Emitente não identificado';
          }
          if (importSupplierSummaryDocument) {
            importSupplierSummaryDocument.textContent = formatDocument(supplier.document) || 'Documento não informado';
          }
          if (importSupplierSummaryIe) {
            importSupplierSummaryIe.textContent = supplier.stateRegistration || 'IE não informada';
          }
          if (importSupplierSummaryAddress) {
            importSupplierSummaryAddress.textContent =
              formatAddressLine(supplier.address) || 'Endereço não informado';
          }
          if (importSupplierSummaryContact) {
            importSupplierSummaryContact.textContent = buildContactLine(supplier) || 'Contato não informado';
          }
        };

        const updateSupplierStatusCard = (type = 'info', message = '', description = '', actions = []) => {
          if (!importSupplierStatus) return;

          const hasMessage = Boolean(message);
          const hasDescription = Boolean(description);
          const hasActions = Array.isArray(actions) && actions.length > 0;

          if (!hasMessage && !hasDescription && !hasActions) {
            importSupplierStatus.classList.add('hidden');
            toggleSupplierStatusLayout(false);
            if (importSupplierMessage) importSupplierMessage.textContent = '';
            if (importSupplierDescription) {
              importSupplierDescription.textContent = '';
              importSupplierDescription.classList.add('hidden');
            }
            if (importSupplierActions) {
              importSupplierActions.innerHTML = '';
              importSupplierActions.classList.add('hidden');
            }
            if (importSupplierIcon) {
              importSupplierIcon.className = 'fas fa-circle-info mt-0.5 text-[12px]';
            }
            clearStatusClasses(importSupplierStatus, ALL_STATUS_CLASSES);
            return;
          }

          toggleSupplierStatusLayout(true);
          importSupplierStatus.classList.remove('hidden');
          applyStatusClasses(importSupplierStatus, type);

          if (importSupplierIcon) {
            const iconClass = STATUS_ICONS[type] || STATUS_ICONS.info;
            importSupplierIcon.className = `${iconClass} mt-0.5 text-[12px]`;
          }

          if (importSupplierMessage) {
            importSupplierMessage.textContent = message || '';
          }

          if (importSupplierDescription) {
            if (hasDescription) {
              importSupplierDescription.textContent = description;
              importSupplierDescription.classList.remove('hidden');
            } else {
              importSupplierDescription.textContent = '';
              importSupplierDescription.classList.add('hidden');
            }
          }

          if (!importSupplierActions) return;

          importSupplierActions.innerHTML = '';
          if (hasActions) {
            importSupplierActions.classList.remove('hidden');
            actions.forEach((actionConfig) => {
              if (!actionConfig || !actionConfig.label) return;
              const button = document.createElement('button');
              button.type = 'button';
              button.classList.add(
                'inline-flex',
                'items-center',
                'gap-1.5',
                'rounded-lg',
                'border',
                'px-2.5',
                'py-1',
                'text-[9.5px]',
                'font-semibold',
                'leading-tight',
                'transition',
                'focus:outline-none',
                'focus:ring-2',
                'focus:ring-offset-1'
              );
              const variantClasses = SUPPLIER_ACTION_VARIANTS[actionConfig.variant] || SUPPLIER_ACTION_VARIANTS.secondary;
              button.classList.add(...variantClasses);
              if (actionConfig.icon) {
                const icon = document.createElement('i');
                icon.className = `${actionConfig.icon} text-[11px]`;
                button.appendChild(icon);
              }
              const label = document.createElement('span');
              label.textContent = actionConfig.label;
              button.appendChild(label);
              if (typeof actionConfig.action === 'function') {
                button.addEventListener('click', actionConfig.action);
              }
              importSupplierActions.appendChild(button);
            });
          } else {
            importSupplierActions.classList.add('hidden');
          }
        };

        const buildSupplierRegistrationUrl = (supplier, nfeData) => {
          const url = new URL('admin-compras-fornecedor-cadastro.html', window.location.href);
          const params = new URLSearchParams();
          const documentDigits = digitsOnly(supplier?.document);
          if (documentDigits) {
            params.set('supplierCnpj', documentDigits);
            params.set('supplierType', documentDigits.length === 11 ? 'fisico' : 'juridico');
          }
          if (supplier?.name) params.set('supplierRazaoSocial', supplier.name);
          if (supplier?.fantasyName) params.set('supplierNomeFantasia', supplier.fantasyName);
          if (supplier?.stateRegistration) params.set('supplierIe', supplier.stateRegistration);
          if (supplier?.email) params.set('supplierEmail', supplier.email);
          if (supplier?.phone) params.set('supplierTelefone', digitsOnly(supplier.phone));
          if (supplier?.address?.cep) params.set('supplierCEP', digitsOnly(supplier.address.cep));
          if (supplier?.address?.street) params.set('supplierLogradouro', supplier.address.street);
          if (supplier?.address?.number) params.set('supplierNumero', supplier.address.number);
          if (supplier?.address?.complement) params.set('supplierComplemento', supplier.address.complement);
          if (supplier?.address?.neighborhood) params.set('supplierBairro', supplier.address.neighborhood);
          if (supplier?.address?.city) params.set('supplierCidade', supplier.address.city);
          if (supplier?.address?.state) params.set('supplierUF', supplier.address.state);
          if (supplier?.address?.country) params.set('supplierPais', supplier.address.country);
          if (nfeData?.accessKey) params.set('supplierObservacao', `Origem: XML NF-e ${nfeData.accessKey}`);
          params.set('from', 'nfe-import');
          url.search = params.toString();
          return url.toString();
        };

        const persistProductDraft = (item, nfeData) => {
          if (!item || typeof sessionStorage === 'undefined') return;
          try {
            const supplierSource = lastSupplierData || nfeData?.emit || null;
            const supplierName =
              supplierSource?.name ||
              supplierSource?.fantasyName ||
              supplierSource?.legalName ||
              supplierSource?.razaoSocial ||
              '';
            const supplierPayload = supplierSource
              ? {
                  name: supplierName,
                  fantasyName: supplierSource?.fantasyName || '',
                  document: supplierSource?.document ? digitsOnly(supplierSource.document) : '',
                  stateRegistration: supplierSource?.stateRegistration || '',
                  email: supplierSource?.email || '',
                  phone: supplierSource?.phone || '',
                  address: supplierSource?.address || null,
                }
              : null;
            const payload = {
              item,
              accessKey: nfeData?.accessKey || '',
              generatedAt: new Date().toISOString(),
              supplier: supplierPayload,
              nfe: {
                number: nfeData?.ide?.number || '',
                serie: nfeData?.ide?.serie || '',
                emissionDate: nfeData?.ide?.emissionDate || '',
              },
            };
            sessionStorage.setItem(PRODUCT_DRAFT_STORAGE_KEY, JSON.stringify(payload));
          } catch (error) {
            console.warn('Não foi possível preparar o rascunho de cadastro do produto importado.', error);
          }
        };

        const buildProductRegistrationUrl = (item, nfeData) => {
          const url = new URL('admin-produtos.html', window.location.href);
          url.searchParams.set('from', 'nfe-import');
          if (nfeData?.accessKey) {
            url.searchParams.set('nfe', nfeData.accessKey);
          }
          const barcode = Array.isArray(item?.barcodeCandidates) && item.barcodeCandidates.length
            ? item.barcodeCandidates[0]
            : '';
          if (barcode) {
            url.searchParams.set('barcode', barcode);
          }
          return url.toString();
        };

        const buildExistingProductEditUrl = (item, nfeData) => {
          const productId = getProductIdFromRecord(item?.matchedProduct);
          if (!productId) return null;
          const url = new URL('admin-produtos.html', window.location.href);
          url.searchParams.set('id', productId);
          if (nfeData?.accessKey) {
            url.searchParams.set('nfe', nfeData.accessKey);
          }
          const barcode = Array.isArray(item?.barcodeCandidates) && item.barcodeCandidates.length
            ? item.barcodeCandidates[0]
            : '';
          if (barcode) {
            url.searchParams.set('barcode', barcode);
          }
          return url.toString();
        };

        const isImportModalOpen = () => Boolean(importModal && !importModal.classList.contains('hidden'));

        const updateProductIframeHeader = (item, nfeData) => {
          if (productIframeTitle) {
            const rawTitle = typeof item?.description === 'string' ? item.description.trim() : '';
            const normalizedTitle = rawTitle || 'Cadastro de produto';
            productIframeTitle.textContent = normalizedTitle.length > 140
              ? `${normalizedTitle.slice(0, 137)}...`
              : normalizedTitle;
          }

          if (productIframeSubtitle) {
            const parts = [];
            if (nfeData?.ide?.number) parts.push(`NF-e ${nfeData.ide.number}`);
            if (nfeData?.ide?.serie) parts.push(`Série ${nfeData.ide.serie}`);
            const supplierName =
              lastSupplierData?.fantasyName ||
              lastSupplierData?.name ||
              lastSupplierData?.legalName ||
              nfeData?.emit?.fantasyName ||
              nfeData?.emit?.name ||
              '';
            if (supplierName) parts.push(supplierName);
            const subtitle = parts.join(' · ');
            productIframeSubtitle.textContent = subtitle;
            productIframeSubtitle.classList.toggle('hidden', subtitle.length === 0);
          }

          if (productIframeHelper) {
            const baseMessage =
              'Os dados do XML autorizado foram enviados automaticamente. Revise e complete as informações antes de salvar.';
            const accessKeyNote = nfeData?.accessKey ? ` Chave de acesso ${nfeData.accessKey}.` : '';
            productIframeHelper.textContent = `${baseMessage}${accessKeyNote}`;
          }
        };

        const clearProductModalHeight = () => {
          if (!productIframeShell) return;
          productIframeShell.style.removeProperty('min-height');
          productIframeShell.style.removeProperty('height');
          productIframeShell.style.removeProperty('max-height');
        };

        const syncProductModalHeight = () => {
          if (!productIframeShell || !productIframeModal) return;
          if (productIframeModal.classList.contains('hidden')) {
            clearProductModalHeight();
            return;
          }

          const importModalCard = importModal?.querySelector('[data-import-modal-card]') || null;
          if (!importModalCard) {
            clearProductModalHeight();
            return;
          }

          const { height } = importModalCard.getBoundingClientRect();
          if (!Number.isFinite(height) || height <= 0) {
            clearProductModalHeight();
            return;
          }

          const viewportLimit = Number.isFinite(window.innerHeight)
            ? Math.max(0, window.innerHeight * 0.9)
            : height;
          const targetHeight = Math.max(0, Math.min(height, viewportLimit));

          if (targetHeight === 0) {
            clearProductModalHeight();
            return;
          }

          const heightValue = `${targetHeight}px`;
          productIframeShell.style.minHeight = heightValue;
          productIframeShell.style.height = heightValue;
          productIframeShell.style.maxHeight = heightValue;
        };

        let productModalHeightSyncBound = false;
        let productModalHeightObserver = null;

        const ensureProductModalHeightSync = () => {
          syncProductModalHeight();
          if (productModalHeightSyncBound) return;
          window.addEventListener('resize', syncProductModalHeight);
          productModalHeightSyncBound = true;
          if (typeof ResizeObserver === 'function') {
            const importModalCard = importModal?.querySelector('[data-import-modal-card]') || null;
            if (importModalCard) {
              productModalHeightObserver = new ResizeObserver(() => {
                syncProductModalHeight();
              });
              productModalHeightObserver.observe(importModalCard);
            }
          }
        };

        const teardownProductModalHeightSync = () => {
          if (productModalHeightSyncBound) {
            window.removeEventListener('resize', syncProductModalHeight);
            productModalHeightSyncBound = false;
          }
          if (productModalHeightObserver) {
            try {
              productModalHeightObserver.disconnect();
            } catch (observerError) {
              console.debug('Não foi possível desconectar o observador de altura do modal.', observerError);
            }
            productModalHeightObserver = null;
          }
          clearProductModalHeight();
        };

        const resetProductIframeModal = () => {
          if (productIframeLoading) {
            productIframeLoading.classList.remove('hidden');
          }
          if (productIframe) {
            productIframe.classList.add('hidden');
            try {
              productIframe.src = 'about:blank';
            } catch (iframeResetError) {
              console.debug('Não foi possível redefinir o iframe do produto.', iframeResetError);
            }
          }
          clearProductModalHeight();
        };

        const closeProductIframeModal = () => {
          if (!productIframeModal) return;
          resetProductIframeModal();
          teardownProductModalHeightSync();
          productIframeModal.classList.add('hidden');
          productIframeModal.removeAttribute('data-modal-open');
          if (!isImportModalOpen()) {
            document.body.classList.remove('overflow-hidden');
          }
          if (productModalPreviousFocus && typeof productModalPreviousFocus.focus === 'function') {
            try {
              productModalPreviousFocus.focus();
            } catch (focusError) {
              console.debug('Não foi possível restaurar o foco após fechar o cadastro de produto.', focusError);
            }
          }
          productModalPreviousFocus = null;
        };

        const openProductIframeModal = (url, item, nfeData) => {
          if (!productIframeModal || !productIframe) {
            window.open(url, '_blank', 'noopener');
            return;
          }

          productModalPreviousFocus = document.activeElement instanceof HTMLElement ? document.activeElement : null;
          updateProductIframeHeader(item, nfeData);
          if (productIframeLoading) {
            productIframeLoading.classList.remove('hidden');
          }
          productIframe.classList.add('hidden');
          productIframeModal.classList.remove('hidden');
          productIframeModal.setAttribute('data-modal-open', 'true');
          document.body.classList.add('overflow-hidden');
          productIframe.src = url;
          ensureProductModalHeightSync();
          requestAnimationFrame(syncProductModalHeight);

          requestAnimationFrame(() => {
            if (!productIframeModal) return;
            const focusableElements = Array.from(
              productIframeModal.querySelectorAll(MODAL_FOCUSABLE_SELECTORS)
            ).filter((element) => element instanceof HTMLElement && element.offsetParent !== null);
            if (focusableElements.length > 0) {
              const firstElement = focusableElements[0];
              if (firstElement instanceof HTMLElement) {
                firstElement.focus();
              }
            }
          });
        };

        const openProductRegistration = (item) => {
          if (!item) return;
          persistProductDraft(item, lastNfeData);
          const url = buildProductRegistrationUrl(item, lastNfeData);
          openProductIframeModal(url, item, lastNfeData);
        };

        const openExistingProduct = (item) => {
          if (!item || !item.matchedProduct) {
            notify('Produto não disponível para edição no momento.', 'warning');
            return;
          }
          const url = buildExistingProductEditUrl(item, lastNfeData);
          if (!url) {
            notify('Não foi possível identificar o produto cadastrado para abrir no modal.', 'error');
            return;
          }
          openProductIframeModal(url, item, lastNfeData);
        };

        const isProductLinkModalOpen = () =>
          Boolean(productLinkModal && !productLinkModal.classList.contains('hidden'));

        const isProductIframeModalOpen = () =>
          Boolean(
            productIframeModal &&
              !productIframeModal.classList.contains('hidden') &&
              productIframeModal.hasAttribute('data-modal-open')
          );

        if (priceModal) {
          const filterElements = priceModal.querySelectorAll('[data-price-filter]');
          filterElements.forEach((element) => {
            if (!(element instanceof HTMLInputElement)) return;
            const key = element.dataset.priceFilter || '';
            if (!key) return;
            priceFilterInputs.set(key, element);
          });
        }

        const toNumericValue = (value) => (Number.isFinite(value) ? value : parseNumber(value));
        const sanitizeCurrencyValue = (value) => {
          const numeric = toNumericValue(value);
          if (!Number.isFinite(numeric)) return null;
          return Math.round(numeric * 100) / 100;
        };
        const sanitizePercentValue = (value) => {
          const numeric = toNumericValue(value);
          if (!Number.isFinite(numeric)) return null;
          return Math.round(numeric * 100) / 100;
        };
        const sanitizeQuantityValue = (value) => {
          const numeric = toNumericValue(value);
          if (!Number.isFinite(numeric)) return null;
          return Math.round(numeric * 1000) / 1000;
        };

        const computeMarkupPercentage = (cost, sale) => {
          const costValue = sanitizeCurrencyValue(cost);
          const saleValue = sanitizeCurrencyValue(sale);
          if (!Number.isFinite(costValue) || costValue <= 0 || !Number.isFinite(saleValue) || saleValue <= 0) {
            return null;
          }
          const markup = ((saleValue - costValue) / costValue) * 100;
          return Math.round(markup * 100) / 100;
        };

        const computeSaleFromMarkup = (cost, markup) => {
          const costValue = sanitizeCurrencyValue(cost);
          const markupValue = sanitizePercentValue(markup);
          if (!Number.isFinite(costValue) || costValue < 0) return null;
          if (!Number.isFinite(markupValue)) return costValue;
          const factor = 1 + markupValue / 100;
          if (factor < 0) return 0;
          const result = costValue * factor;
          return Math.round(result * 100) / 100;
        };

        const buildPriceAdjustmentItems = () => {
          const sourceItems = Array.isArray(mainProductTableState?.items) && mainProductTableState.items.length
            ? mainProductTableState.items
            : Array.isArray(lastNfeData?.items)
            ? lastNfeData.items
            : [];

          const items = [];
          sourceItems.forEach((item, index) => {
            if (!item || item.validationStatus !== 'matched' || !item.matchedProduct) return;
            const productId = getProductIdFromRecord(item.matchedProduct);
            if (!productId) return;

            ensureItemCostWithTaxes(item);

            const internalCode = normalizeInternalCode(getProductCodeFromRecord(item.matchedProduct)) || item.internalCode;
            const supplierCode = item.supplierCode || '';
            const code = internalCode || supplierCode || `ITEM-${index + 1}`;
            const description =
              getProductNameFromRecord(item.matchedProduct) ||
              (typeof item.description === 'string' ? item.description : '') ||
              'Produto sem descrição';

            const costPrevious = sanitizeCurrencyValue(item.matchedProduct?.custo);
            const salePrevious = sanitizeCurrencyValue(item.matchedProduct?.venda);
            const costBase = sanitizeCurrencyValue(item.unitCostWithTaxes);
            const entryStock = sanitizeQuantityValue(resolveMainProductEntryStockQuantity(
              item,
              resolveMainProductConversionFactor(item)
            ));
            const currentStock = sanitizeQuantityValue(item.matchedProduct?.stock);
            const previousStock =
              Number.isFinite(currentStock) && Number.isFinite(entryStock)
                ? Math.max(sanitizeQuantityValue(currentStock - entryStock) || 0, 0)
                : null;

            const markupPrevious = computeMarkupPercentage(costPrevious, salePrevious);
            const initialCost = Number.isFinite(costBase) ? costBase : costPrevious;

            let markupCurrent = Number.isFinite(markupPrevious) ? markupPrevious : null;
            let saleNew = Number.isFinite(salePrevious) ? salePrevious : null;

            if (!Number.isFinite(saleNew) && Number.isFinite(initialCost) && Number.isFinite(markupCurrent)) {
              saleNew = computeSaleFromMarkup(initialCost, markupCurrent);
            }

            if (!Number.isFinite(markupCurrent) && Number.isFinite(initialCost) && Number.isFinite(saleNew)) {
              markupCurrent = computeMarkupPercentage(initialCost, saleNew);
            }

            const entryData = {
              id: `${productId}-${index}`,
              productId,
              code,
              description,
              nfeItem: item,
              matchedProduct: item.matchedProduct,
              costPrevious,
              salePrevious,
              costBase: Number.isFinite(initialCost) ? initialCost : null,
              costNew: Number.isFinite(initialCost) ? initialCost : null,
              saleNew,
              markupPrevious,
              markupCurrent,
              entryStock,
              currentStock,
              previousStock,
              selected: false,
              displays: {},
              filterValues: {},
            };

            updateEntryDisplays(entryData);
            items.push(entryData);
          });

          return items;
        };

        const updateEntryDisplays = (entry) => {
          if (!entry || typeof entry !== 'object') return;

          const formatCurrencyDisplay = (value) =>
            Number.isFinite(value) ? formatMoneyValue(value) : '';
          const formatQuantityDisplay = (value) =>
            Number.isFinite(value) ? formatQuantity(value) : '—';
          const formatMarkupDisplay = (value) =>
            Number.isFinite(value) ? formatPercentValue(value) : '';

          entry.displays = {
            costPrevious: Number.isFinite(entry.costPrevious) ? formatMoneyValue(entry.costPrevious) : '—',
            costNew: formatCurrencyDisplay(entry.costNew),
            markup: formatMarkupDisplay(entry.markupCurrent),
            saleNew: formatCurrencyDisplay(entry.saleNew),
            salePrevious: Number.isFinite(entry.salePrevious) ? formatMoneyValue(entry.salePrevious) : '—',
            entryStock: formatQuantityDisplay(entry.entryStock),
            currentStock: formatQuantityDisplay(entry.currentStock),
            previousStock: formatQuantityDisplay(entry.previousStock),
          };

          entry.filterValues = {
            code: entry.code || '',
            description: entry.description || '',
            costPrevious: entry.displays.costPrevious,
            costNew: entry.displays.costNew,
            markup: entry.displays.markup,
            saleNew: entry.displays.saleNew,
            salePrevious: entry.displays.salePrevious,
            entryStock: entry.displays.entryStock,
            currentStock: entry.displays.currentStock,
            previousStock: entry.displays.previousStock,
          };
        };

        const recomputeEntryPricing = (entry, { source } = {}) => {
          if (!entry || typeof entry !== 'object') return;

          const costValue = sanitizeCurrencyValue(entry.costNew);
          entry.costNew = costValue;

          if (priceAdjustmentState.maintainMarkup) {
            const baseMarkup = Number.isFinite(entry.markupPrevious)
              ? entry.markupPrevious
              : computeMarkupPercentage(entry.costPrevious, entry.salePrevious);
            entry.markupCurrent = Number.isFinite(baseMarkup) ? baseMarkup : 0;
            entry.saleNew = computeSaleFromMarkup(costValue, entry.markupCurrent);
          } else if (priceAdjustmentState.usarMarkup) {
            if (!Number.isFinite(entry.markupCurrent)) {
              const fallbackMarkup = computeMarkupPercentage(entry.costPrevious, entry.salePrevious);
              entry.markupCurrent = Number.isFinite(fallbackMarkup) ? fallbackMarkup : 0;
            }
            entry.saleNew = computeSaleFromMarkup(costValue, entry.markupCurrent);
          } else {
            if (!Number.isFinite(entry.saleNew) || source === 'reset-sale') {
              entry.saleNew = Number.isFinite(entry.salePrevious) ? entry.salePrevious : computeSaleFromMarkup(costValue, entry.markupCurrent);
            }
            entry.markupCurrent = computeMarkupPercentage(costValue, entry.saleNew);
          }

          updateEntryDisplays(entry);
        };

        const recomputeAllEntries = () => {
          if (!Array.isArray(priceAdjustmentState.items)) return;
          priceAdjustmentState.items.forEach((entry) => {
            recomputeEntryPricing(entry);
          });
        };

        const filterPriceItems = (items) => {
          const activeFilters = Object.entries(priceAdjustmentState.filters || {}).filter(([, value]) =>
            normalizeFilterText(value).length > 0
          );
          if (!activeFilters.length) {
            return items.slice();
          }
          return items.filter((entry) =>
            activeFilters.every(([key, value]) => {
              const normalizedFilter = normalizeFilterText(value);
              if (!normalizedFilter) return true;
              const columnValue = entry.filterValues?.[key] ?? '';
              const normalizedColumn = normalizeFilterText(columnValue);
              return normalizedColumn.includes(normalizedFilter);
            })
          );
        };

        const syncPriceSelectAllState = () => {
          if (!priceSelectAllCheckbox) return;
          const items = Array.isArray(priceAdjustmentState.items) ? priceAdjustmentState.items : [];
          if (!items.length) {
            priceSelectAllCheckbox.checked = false;
            priceSelectAllCheckbox.indeterminate = false;
            return;
          }
          const selectedCount = items.filter((entry) => entry.selected).length;
          priceSelectAllCheckbox.checked = selectedCount > 0 && selectedCount === items.length;
          priceSelectAllCheckbox.indeterminate = selectedCount > 0 && selectedCount < items.length;
        };

        const createPriceTableRow = (entry) => {
          const row = document.createElement('tr');
          row.dataset.priceRow = entry.id;
          row.className = 'text-[11px] text-gray-700';

          const buildReadOnlyInputClasses = (readOnly) =>
            readOnly
              ? 'w-24 rounded border border-gray-200 bg-gray-50 px-2 py-1 text-right font-semibold text-gray-500 focus:outline-none cursor-not-allowed'
              : 'w-24 rounded border border-gray-200 bg-white px-2 py-1 text-right font-semibold text-gray-700 focus:border-primary focus:outline-none focus:ring-1 focus:ring-primary/30';

          const selectCell = document.createElement('td');
          selectCell.className = 'px-3 py-2 text-center align-top';
          const selectInput = document.createElement('input');
          selectInput.type = 'checkbox';
          selectInput.className = 'h-3.5 w-3.5 rounded border-gray-300 text-primary focus:ring-primary';
          selectInput.checked = Boolean(entry.selected);
          selectInput.addEventListener('change', () => {
            entry.selected = selectInput.checked;
            syncPriceSelectAllState();
          });
          selectCell.appendChild(selectInput);

          const codeCell = document.createElement('td');
          codeCell.className = 'px-3 py-2 align-top text-gray-700 whitespace-nowrap';
          codeCell.textContent = entry.code || '—';

          const descriptionCell = document.createElement('td');
          descriptionCell.className = 'px-3 py-2 align-top text-gray-600';
          descriptionCell.textContent = entry.description || '—';

          const costPreviousCell = document.createElement('td');
          costPreviousCell.className = 'px-3 py-2 align-top text-right text-gray-500 whitespace-nowrap';
          costPreviousCell.textContent = entry.displays.costPrevious;

          const costNewCell = document.createElement('td');
          costNewCell.className = 'px-3 py-2 align-top text-right';
          const costInput = document.createElement('input');
          costInput.type = 'text';
          costInput.inputMode = 'decimal';
          costInput.value = entry.displays.costNew;
          costInput.className = buildReadOnlyInputClasses(false);
          costInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
              event.preventDefault();
              costInput.blur();
            }
          });
          costInput.addEventListener('blur', () => {
            const value = sanitizeCurrencyValue(costInput.value);
            if (!Number.isFinite(value)) {
              costInput.value = entry.displays.costNew;
              return;
            }
            entry.costNew = value;
            recomputeEntryPricing(entry);
            costInput.value = entry.displays.costNew;
            renderPriceAdjustmentTable();
          });
          costNewCell.appendChild(costInput);

          const markupCell = document.createElement('td');
          markupCell.className = 'px-3 py-2 align-top text-right';
          const markupInput = document.createElement('input');
          markupInput.type = 'text';
          markupInput.inputMode = 'decimal';
          markupInput.value = entry.displays.markup;
          const markupReadOnly = priceAdjustmentState.maintainMarkup || !priceAdjustmentState.usarMarkup;
          markupInput.readOnly = markupReadOnly;
          markupInput.className = buildReadOnlyInputClasses(markupReadOnly).replace('w-24', 'w-20');
          markupInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
              event.preventDefault();
              markupInput.blur();
            }
          });
          markupInput.addEventListener('blur', () => {
            if (markupReadOnly) return;
            const value = sanitizePercentValue(markupInput.value);
            if (!Number.isFinite(value)) {
              markupInput.value = entry.displays.markup;
              return;
            }
            entry.markupCurrent = value;
            entry.saleNew = computeSaleFromMarkup(entry.costNew, entry.markupCurrent);
            recomputeEntryPricing(entry);
            renderPriceAdjustmentTable();
          });
          markupCell.appendChild(markupInput);

          const saleNewCell = document.createElement('td');
          saleNewCell.className = 'px-3 py-2 align-top text-right';
          const saleInput = document.createElement('input');
          saleInput.type = 'text';
          saleInput.inputMode = 'decimal';
          saleInput.value = entry.displays.saleNew;
          const saleReadOnly = priceAdjustmentState.usarMarkup || priceAdjustmentState.maintainMarkup;
          saleInput.readOnly = saleReadOnly;
          saleInput.className = buildReadOnlyInputClasses(saleReadOnly);
          saleInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
              event.preventDefault();
              saleInput.blur();
            }
          });
          saleInput.addEventListener('blur', () => {
            if (saleReadOnly) return;
            const value = sanitizeCurrencyValue(saleInput.value);
            if (!Number.isFinite(value)) {
              saleInput.value = entry.displays.saleNew;
              return;
            }
            entry.saleNew = value;
            recomputeEntryPricing(entry, { source: 'sale-update' });
            renderPriceAdjustmentTable();
          });
          saleNewCell.appendChild(saleInput);

          const salePreviousCell = document.createElement('td');
          salePreviousCell.className = 'px-3 py-2 align-top text-right text-gray-500 whitespace-nowrap';
          salePreviousCell.textContent = entry.displays.salePrevious;

          const entryStockCell = document.createElement('td');
          entryStockCell.className = 'px-3 py-2 align-top text-right text-gray-500 whitespace-nowrap';
          entryStockCell.textContent = entry.displays.entryStock;

          const currentStockCell = document.createElement('td');
          currentStockCell.className = 'px-3 py-2 align-top text-right text-gray-500 whitespace-nowrap';
          currentStockCell.textContent = entry.displays.currentStock;

          const previousStockCell = document.createElement('td');
          previousStockCell.className = 'px-3 py-2 align-top text-right text-gray-500 whitespace-nowrap';
          previousStockCell.textContent = entry.displays.previousStock;

          const taxCell = document.createElement('td');
          taxCell.className = 'px-3 py-2 align-top text-center';
          const taxButton = document.createElement('button');
          taxButton.type = 'button';
          taxButton.className =
            'inline-flex items-center gap-1 rounded-full border border-primary/40 px-3 py-0.5 text-[10px] font-semibold text-primary transition hover:bg-primary/10';
          taxButton.textContent = 'Regra';
          taxButton.addEventListener('click', () => {
            openExistingProduct(entry.nfeItem);
          });
          taxCell.appendChild(taxButton);

          row.append(
            selectCell,
            codeCell,
            descriptionCell,
            costPreviousCell,
            costNewCell,
            markupCell,
            saleNewCell,
            salePreviousCell,
            entryStockCell,
            currentStockCell,
            previousStockCell,
            taxCell
          );

          return row;
        };

        const renderPriceAdjustmentTable = () => {
          if (!priceTableBody) return;

          const existingRows = priceTableBody.querySelectorAll('[data-price-row]');
          existingRows.forEach((row) => row.remove());

          const items = Array.isArray(priceAdjustmentState.items) ? priceAdjustmentState.items : [];
          const filteredItems = filterPriceItems(items);

          if (!filteredItems.length) {
            if (priceEmptyRow) {
              priceEmptyRow.classList.remove('hidden');
            }
            syncPriceSelectAllState();
            return;
          }

          if (priceEmptyRow) {
            priceEmptyRow.classList.add('hidden');
          }

          const fragment = document.createDocumentFragment();
          filteredItems.forEach((entry) => {
            const row = createPriceTableRow(entry);
            fragment.appendChild(row);
          });
          priceTableBody.appendChild(fragment);
          syncPriceSelectAllState();
        };

        const setUseMarkupState = (active, { silent } = {}) => {
          const normalized = Boolean(active);
          priceAdjustmentState.usarMarkup = normalized;
          if (priceUseMarkupButton) {
            priceUseMarkupButton.setAttribute('aria-pressed', normalized ? 'true' : 'false');
            priceUseMarkupButton.classList.toggle('bg-primary/10', normalized);
            priceUseMarkupButton.classList.toggle('border-primary/60', normalized);
            priceUseMarkupButton.classList.toggle('text-primary', normalized);
            priceUseMarkupButton.classList.toggle('text-gray-600', !normalized);
          }
          if (!silent) {
            recomputeAllEntries();
            renderPriceAdjustmentTable();
          }
        };

        const setMaintainMarkupState = (active) => {
          const normalized = Boolean(active);
          priceAdjustmentState.maintainMarkup = normalized;
          if (priceMaintainMarkupToggle) {
            priceMaintainMarkupToggle.checked = normalized;
          }
          if (priceUseMarkupButton) {
            priceUseMarkupButton.disabled = normalized;
            priceUseMarkupButton.classList.toggle('opacity-60', normalized);
            priceUseMarkupButton.classList.toggle('cursor-not-allowed', normalized);
          }
          if (normalized) {
            setUseMarkupState(true, { silent: true });
          }
          recomputeAllEntries();
          renderPriceAdjustmentTable();
        };

        const setCostMode = (mode) => {
          const normalized = mode === 'subtract' ? 'subtract' : 'add';
          priceAdjustmentState.costMode = normalized;
          priceCostModeButtons.forEach((button) => {
            if (!(button instanceof HTMLButtonElement)) return;
            const isActive = button.dataset.priceCostMode === normalized;
            button.setAttribute('aria-pressed', isActive ? 'true' : 'false');
            button.classList.toggle('bg-primary/10', isActive);
            button.classList.toggle('border-primary/60', isActive);
            button.classList.toggle('text-primary', isActive);
          });
        };

        const applyCostPercentToSelection = () => {
          if (!Array.isArray(priceAdjustmentState.items) || !priceAdjustmentState.items.length) {
            notify('Nenhum produto disponível para ajuste.', 'warning');
            return;
          }
          const selectedItems = priceAdjustmentState.items.filter((entry) => entry.selected);
          if (!selectedItems.length) {
            notify('Selecione ao menos um produto para ajustar o custo.', 'warning');
            return;
          }
          const percentValue = sanitizePercentValue(priceCostPercentInput?.value);
          const hasPercent = Number.isFinite(percentValue) && percentValue !== 0;
          selectedItems.forEach((entry) => {
            const baseCost = Number.isFinite(entry.costBase) ? entry.costBase : entry.costNew;
            if (!Number.isFinite(baseCost)) return;
            if (!hasPercent) {
              entry.costNew = baseCost;
            } else {
              const factor = priceAdjustmentState.costMode === 'subtract' ? 1 - percentValue / 100 : 1 + percentValue / 100;
              const adjusted = Math.max(baseCost * factor, 0);
              entry.costNew = Math.round(adjusted * 100) / 100;
            }
            recomputeEntryPricing(entry);
          });
          renderPriceAdjustmentTable();
        };

        const setPriceProcessingState = (processing) => {
          priceAdjustmentState.isProcessing = Boolean(processing);
          if (priceUpdateButton) {
            priceUpdateButton.disabled = processing;
            priceUpdateButton.classList.toggle('cursor-wait', processing);
            priceUpdateButton.classList.toggle('opacity-60', processing);
          }
          if (priceUpdateButtonIcon) {
            priceUpdateButtonIcon.className = processing ? 'fas fa-circle-notch fa-spin' : 'fas fa-rotate';
          }
          if (priceUpdateButtonText) {
            priceUpdateButtonText.textContent = processing ? 'Atualizando...' : 'Atualizar';
          }
          if (priceGenerateButton) {
            priceGenerateButton.disabled = processing;
            priceGenerateButton.classList.toggle('opacity-60', processing);
            priceGenerateButton.classList.toggle('cursor-not-allowed', processing);
          }
        };

        closePriceAdjustmentModal = () => {
          if (!priceModal) return;
          if (priceAdjustmentState.isProcessing) return;
          priceAdjustmentState.isOpen = false;
          if (priceModalCard) {
            priceModalCard.classList.add('opacity-0', 'scale-95');
            setTimeout(() => {
              priceModal?.classList.add('hidden');
            }, 180);
          } else {
            priceModal.classList.add('hidden');
          }
          if (!isImportModalOpen() && !isProductIframeModalOpen()) {
            document.body.classList.remove('overflow-hidden');
          }
        };

        const openPriceAdjustmentModal = () => {
          if (!priceModal || !priceAdjustmentButton || priceAdjustmentButton.disabled) return;
          priceAdjustmentState.items = buildPriceAdjustmentItems();
          priceAdjustmentState.filters = {};
          priceFilterInputs.forEach((input) => {
            if (!(input instanceof HTMLInputElement)) return;
            input.value = '';
          });
          setCostMode(priceAdjustmentState.costMode || 'add');
          if (priceMaintainMarkupToggle) {
            setMaintainMarkupState(priceMaintainMarkupToggle.checked);
          } else {
            setMaintainMarkupState(false);
          }
          if (!priceAdjustmentState.maintainMarkup) {
            const useMarkupActive = priceUseMarkupButton?.getAttribute('aria-pressed') === 'true';
            setUseMarkupState(useMarkupActive, { silent: true });
            recomputeAllEntries();
          }
          renderPriceAdjustmentTable();
          priceAdjustmentState.items.forEach((entry) => {
            entry.selected = false;
          });
          syncPriceSelectAllState();

          priceAdjustmentState.isOpen = true;
          if (priceModalCard) {
            priceModalCard.classList.add('opacity-0', 'scale-95');
          }
          priceModal.classList.remove('hidden');
          requestAnimationFrame(() => {
            if (priceModalCard) {
              priceModalCard.classList.remove('opacity-0', 'scale-95');
            }
            const focusable = priceModal?.querySelector('input:not([readonly]):not([disabled])');
            if (focusable instanceof HTMLElement) {
              focusable.focus();
            }
          });
          document.body.classList.add('overflow-hidden');
        };

        const handlePriceUpdate = async () => {
          if (!Array.isArray(priceAdjustmentState.items) || !priceAdjustmentState.items.length) {
            notify('Nenhum produto disponível para atualização.', 'warning');
            return;
          }
          const selectedItems = priceAdjustmentState.items.filter((entry) => entry.selected);
          if (!selectedItems.length) {
            notify('Selecione os produtos que deseja atualizar.', 'warning');
            return;
          }
          if (priceAdjustmentState.isProcessing) return;

          setPriceProcessingState(true);

          const failures = [];
          let successCount = 0;

          try {
            for (const entry of selectedItems) {
              const productId = entry.productId;
              const costValue = sanitizeCurrencyValue(entry.costNew);
              const saleValue = sanitizeCurrencyValue(entry.saleNew);

              if (!productId || !Number.isFinite(costValue) || !Number.isFinite(saleValue)) {
                failures.push({ entry, error: new Error('Valores inválidos para atualização.') });
                continue;
              }

              const headers = buildAuthHeaders();
              headers.set('Content-Type', 'application/json');

              const response = await fetch(`${apiBaseUrl}/products/${productId}`, {
                method: 'PUT',
                headers,
                body: JSON.stringify({ custo: costValue, venda: saleValue }),
              });

              const payload = await response.json().catch(() => ({}));

              if (response.status === 401 || response.status === 403) {
                handleAuthError();
              }

              if (!response.ok) {
                const message = payload?.message || payload?.error || 'Falha ao atualizar o produto.';
                failures.push({ entry, error: new Error(message) });
                continue;
              }

              entry.costPrevious = costValue;
              entry.costBase = Number.isFinite(entry.costBase) ? entry.costBase : costValue;
              entry.salePrevious = saleValue;
              entry.markupPrevious = computeMarkupPercentage(costValue, saleValue);
              entry.markupCurrent = entry.markupPrevious;
              entry.saleNew = saleValue;
              entry.costNew = costValue;

              if (entry.matchedProduct) {
                entry.matchedProduct.custo = costValue;
                entry.matchedProduct.venda = saleValue;
              }

              entry.selected = false;
              updateEntryDisplays(entry);
              successCount += 1;
            }
          } catch (error) {
            failures.push({ entry: null, error });
          } finally {
            setPriceProcessingState(false);
            renderPriceAdjustmentTable();
            updateMainProductsTableDisplay();
            updatePriceButtonAvailability(currentDraftStatus);
          }

          if (successCount > 0) {
            notify(`${successCount} produto${successCount > 1 ? 's' : ''} atualizado${successCount > 1 ? 's' : ''} com sucesso.`, 'success');
          }
          if (failures.length) {
            console.error('Falhas ao atualizar preços:', failures.map((failure) => failure.error));
            notify(`${failures.length} produto${failures.length > 1 ? 's' : ''} não pôde ser atualizado. Verifique os dados e tente novamente.`, 'error');
          }
        };

        if (priceAdjustmentButton) {
          priceAdjustmentButton.addEventListener('click', openPriceAdjustmentModal);
        }

        priceModalCloseButtons.forEach((button) => {
          if (!(button instanceof HTMLElement)) return;
          button.addEventListener('click', (event) => {
            event.preventDefault();
            closePriceAdjustmentModal();
          });
        });

        if (priceCancelButton) {
          priceCancelButton.addEventListener('click', (event) => {
            event.preventDefault();
            closePriceAdjustmentModal();
          });
        }

        if (priceUseMarkupButton) {
          priceUseMarkupButton.addEventListener('click', (event) => {
            event.preventDefault();
            if (priceAdjustmentState.maintainMarkup) return;
            setUseMarkupState(!priceAdjustmentState.usarMarkup);
          });
        }

        if (priceMaintainMarkupToggle) {
          priceMaintainMarkupToggle.addEventListener('change', (event) => {
            setMaintainMarkupState(event.target.checked);
          });
        }

        priceCostModeButtons.forEach((button) => {
          if (!(button instanceof HTMLButtonElement)) return;
          button.addEventListener('click', (event) => {
            event.preventDefault();
            setCostMode(button.dataset.priceCostMode);
          });
        });

        if (priceGenerateButton) {
          priceGenerateButton.addEventListener('click', (event) => {
            event.preventDefault();
            applyCostPercentToSelection();
          });
        }

        if (priceSelectAllCheckbox) {
          priceSelectAllCheckbox.addEventListener('change', () => {
            const checked = priceSelectAllCheckbox.checked;
            if (!Array.isArray(priceAdjustmentState.items)) return;
            priceAdjustmentState.items.forEach((entry) => {
              entry.selected = checked;
            });
            renderPriceAdjustmentTable();
          });
        }

        if (priceMarkAllButton) {
          priceMarkAllButton.addEventListener('click', (event) => {
            event.preventDefault();
            if (!Array.isArray(priceAdjustmentState.items)) return;
            priceAdjustmentState.items.forEach((entry) => {
              entry.selected = true;
            });
            renderPriceAdjustmentTable();
          });
        }

        if (priceUnmarkAllButton) {
          priceUnmarkAllButton.addEventListener('click', (event) => {
            event.preventDefault();
            if (!Array.isArray(priceAdjustmentState.items)) return;
            priceAdjustmentState.items.forEach((entry) => {
              entry.selected = false;
            });
            renderPriceAdjustmentTable();
          });
        }

        if (priceUpdateButton) {
          priceUpdateButton.addEventListener('click', (event) => {
            event.preventDefault();
            handlePriceUpdate();
          });
        }

        priceFilterInputs.forEach((input, key) => {
          if (!(input instanceof HTMLInputElement) || !key) return;
          input.addEventListener('input', () => {
            priceAdjustmentState.filters[key] = input.value || '';
            renderPriceAdjustmentTable();
          });
        });

        if (priceCostPercentInput) {
          priceCostPercentInput.addEventListener('blur', () => {
            const value = sanitizePercentValue(priceCostPercentInput.value);
            priceCostPercentInput.value = Number.isFinite(value) ? formatPercentValue(value) : '';
          });
        }

        const hideProductLinkMessages = () => {
          if (productLinkError) {
            productLinkError.classList.add('hidden');
          }
          if (productLinkEmpty) {
            productLinkEmpty.classList.add('hidden');
          }
        };

        const setProductLinkLoading = (isLoading, message = 'Buscando produtos cadastrados...') => {
          if (productLinkLoading) {
            if (isLoading) {
              productLinkLoading.classList.remove('hidden');
              if (productLinkLoadingText) {
                productLinkLoadingText.textContent = message;
              }
            } else {
              productLinkLoading.classList.add('hidden');
            }
          }
          if (productLinkForm) {
            const controls = productLinkForm.querySelectorAll('input, button');
            controls.forEach((control) => {
              control.disabled = Boolean(isLoading);
            });
          }
        };

        const setProductLinkInteractivity = (isEnabled) => {
          if (!productLinkResults) return;
          productLinkResults.querySelectorAll('button').forEach((button) => {
            if (!(button instanceof HTMLButtonElement)) return;
            button.disabled = !isEnabled;
            button.classList.toggle('opacity-60', !isEnabled);
            button.classList.toggle('cursor-not-allowed', !isEnabled);
          });
        };

        const showProductLinkError = (message) => {
          hideProductLinkMessages();
          if (productLinkError) {
            productLinkError.textContent = message;
            productLinkError.classList.remove('hidden');
          } else {
            notify(message, 'error');
          }
        };

        const showProductLinkEmpty = (message) => {
          hideProductLinkMessages();
          if (productLinkEmpty) {
            productLinkEmpty.textContent = message;
            productLinkEmpty.classList.remove('hidden');
          }
        };

        const resetProductLinkModal = () => {
          if (productLinkSearchAbortController) {
            productLinkSearchAbortController.abort();
            productLinkSearchAbortController = null;
          }
          productLinkActiveItem = null;
          productLinkIsLinking = false;
          if (productLinkSearchInput) {
            productLinkSearchInput.value = '';
          }
          if (productLinkResults) {
            productLinkResults.innerHTML = '';
          }
          hideProductLinkMessages();
          showProductLinkEmpty('Informe ao menos três caracteres para localizar um produto cadastrado.');
          setProductLinkLoading(false);
          setProductLinkInteractivity(true);
        };

        const closeProductLinkModal = () => {
          if (!productLinkModal || productLinkModal.classList.contains('hidden')) return;
          resetProductLinkModal();
          productLinkModal.classList.add('hidden');
          productLinkModal.removeAttribute('data-modal-open');
          if (!isImportModalOpen() && !isProductIframeModalOpen()) {
            document.body.classList.remove('overflow-hidden');
          }
          if (productLinkPreviousFocus && typeof productLinkPreviousFocus.focus === 'function') {
            try {
              productLinkPreviousFocus.focus();
            } catch (focusError) {
              console.debug('Não foi possível restaurar o foco após fechar a seleção de produto.', focusError);
            }
          }
          productLinkPreviousFocus = null;
        };

        const renderProductLinkResults = (products = []) => {
          if (!productLinkResults) return;
          productLinkResults.innerHTML = '';
          if (!Array.isArray(products) || !products.length) {
            showProductLinkEmpty('Nenhum produto cadastrado encontrado para os termos informados.');
            return;
          }
          hideProductLinkMessages();
          const fragment = document.createDocumentFragment();
          products.forEach((product) => {
            const item = document.createElement('li');
            item.className = 'rounded-xl border border-gray-100 bg-white px-3 py-2 shadow-sm';

            const header = document.createElement('div');
            header.className = 'flex items-start justify-between gap-3';

            const infoWrapper = document.createElement('div');
            infoWrapper.className = 'space-y-1';

            const title = document.createElement('p');
            title.className = 'text-[13px] font-semibold text-gray-900';
            title.textContent = product?.nome || product?.name || 'Produto sem nome';
            infoWrapper.appendChild(title);

            const details = document.createElement('p');
            details.className = 'text-[11px] text-gray-600';
            const sku = normalizeInternalCode(getProductCodeFromRecord(product)) || '—';
            const barcode = formatGtinDisplay(getProductBarcodeFromRecord(product));
            details.textContent = `SKU: ${sku} · GTIN: ${barcode}`;
            infoWrapper.appendChild(details);

            header.appendChild(infoWrapper);

            const selectButton = createProductActionButton('Vincular', 'fas fa-link');
            selectButton.addEventListener('click', (event) => {
              event.preventDefault();
              handleProductLinkSelection(product);
            });
            header.appendChild(selectButton);

            item.appendChild(header);

            const footer = document.createElement('p');
            footer.className = 'mt-1 text-[10px] text-gray-500';
            const price = Number.isFinite(product?.precoVenda)
              ? formatMoneyValue(product.precoVenda)
              : '';
            footer.textContent = price ? `Preço de venda: R$ ${price}` : 'Sem preço informado';
            item.appendChild(footer);

            fragment.appendChild(item);
          });
          productLinkResults.appendChild(fragment);
        };

        const openProductLinkModal = (item) => {
          if (!productLinkModal) {
            notify('Seleção de produto indisponível no momento.', 'error');
            return;
          }
          if (!item) {
            notify('Item da nota fiscal não encontrado para vinculação.', 'error');
            return;
          }

          const supplierInfo = resolveActiveSupplierInfo(lastNfeData);
          if (!supplierInfo.name) {
            notify('Selecione o fornecedor da nota antes de vincular um produto.', 'warning');
            return;
          }

          const supplierCode = canonicalSupplierProductCode(item?.supplierCode);
          if (!supplierCode) {
            notify('O item do fornecedor não possui código para realizar o vínculo.', 'error');
            return;
          }

          resetProductLinkModal();
          productLinkPreviousFocus = document.activeElement instanceof HTMLElement ? document.activeElement : null;
          productLinkActiveItem = item;

          if (productLinkItemLabel) {
            productLinkItemLabel.textContent = item?.description || item?.matchedProduct?.nome || 'Item sem descrição';
          }
          if (productLinkCodeLabel) {
            productLinkCodeLabel.textContent = item?.supplierCode || '—';
          }
          if (productLinkSupplierLabel) {
            productLinkSupplierLabel.textContent = supplierInfo.name || '—';
          }

          if (productLinkSearchInput) {
            const defaultTerm = item?.supplierCode || item?.description || '';
            productLinkSearchInput.value = defaultTerm;
          }

          productLinkModal.classList.remove('hidden');
          productLinkModal.setAttribute('data-modal-open', 'true');
          document.body.classList.add('overflow-hidden');

          showProductLinkEmpty('Informe ao menos três caracteres para localizar um produto cadastrado.');
          setProductLinkLoading(false);
          setProductLinkInteractivity(true);

          requestAnimationFrame(() => {
            if (productLinkSearchInput) {
              productLinkSearchInput.focus();
              if (productLinkSearchInput.value && productLinkSearchInput.value.trim().length >= 3) {
                handleProductLinkSearch(productLinkSearchInput.value.trim());
              }
            }
          });
        };

        const handleProductLinkSearch = async (rawTerm) => {
          if (!productLinkModal || productLinkModal.classList.contains('hidden')) return;
          const term = String(rawTerm ?? '').trim();
          if (!term || term.length < 3) {
            if (productLinkResults) {
              productLinkResults.innerHTML = '';
            }
            showProductLinkEmpty('Informe ao menos três caracteres para localizar um produto cadastrado.');
            return;
          }

          if (productLinkSearchAbortController) {
            productLinkSearchAbortController.abort();
          }

          const abortController = new AbortController();
          productLinkSearchAbortController = abortController;

          setProductLinkLoading(true, 'Buscando produtos cadastrados...');
          hideProductLinkMessages();
          if (productLinkResults) {
            productLinkResults.innerHTML = '';
          }

          try {
            const response = await fetch(
              `${apiBaseUrl}/products?search=${encodeURIComponent(term)}&limit=10`,
              { headers: buildAuthHeaders(), signal: abortController.signal }
            );
            const payload = await response.json().catch(() => ({}));
            if (!response.ok) {
              if (response.status === 401) {
                handleAuthError();
              }
              throw new Error(payload?.message || `Falha ao consultar produtos (status ${response.status}).`);
            }
            const products = Array.isArray(payload?.products)
              ? payload.products
              : Array.isArray(payload)
              ? payload
              : [];
            renderProductLinkResults(products);
          } catch (error) {
            if (error?.name === 'AbortError') {
              return;
            }
            console.error('Erro ao buscar produtos cadastrados para vínculo manual:', error);
            showProductLinkError('Não foi possível buscar os produtos cadastrados. Tente novamente.');
          } finally {
            if (productLinkSearchAbortController === abortController) {
              productLinkSearchAbortController = null;
            }
            setProductLinkLoading(false);
            setProductLinkInteractivity(true);
          }
        };

        const handleProductLinkSelection = async (product) => {
          if (!productLinkActiveItem) {
            notify('Nenhum item selecionado para vinculação.', 'error');
            return;
          }
          if (!product) {
            notify('Produto selecionado inválido.', 'error');
            return;
          }

          if (productLinkIsLinking) {
            return;
          }

          const supplierCode = canonicalSupplierProductCode(productLinkActiveItem?.supplierCode);
          if (!supplierCode) {
            notify('O item do fornecedor não possui código para realizar o vínculo.', 'error');
            return;
          }

          const productId = getProductIdFromRecord(product);
          if (!productId) {
            notify('Produto selecionado não possui identificador válido para vínculo.', 'error');
            return;
          }

          const supplierInfo = resolveActiveSupplierInfo(lastNfeData);
          if (!supplierInfo.name) {
            notify('Selecione o fornecedor da nota antes de vincular um produto.', 'warning');
            return;
          }

          productLinkIsLinking = true;
          setProductLinkLoading(true, 'Vinculando produto selecionado...');
          setProductLinkInteractivity(false);

          try {
            const linkPromise = ensureProductSupplierLink(product, productLinkActiveItem, lastNfeData);
            if (linkPromise && typeof linkPromise.then === 'function') {
              await linkPromise;
            }

            productLinkActiveItem.manualConversionOverride = false;
            productLinkActiveItem.matchedProduct = product;
            productLinkActiveItem.validationStatus = 'matched';
            applySupplierConversionFromProduct(productLinkActiveItem, product, lastNfeData);
            productLinkActiveItem.internalCode = normalizeInternalCode(
              getProductCodeFromRecord(product)
            );
            ensureUniqueInternalCodes(productTableOriginalItems);
            updateProductTableDisplay();
            notify('Produto vinculado ao fornecedor com sucesso.', 'success');
            closeProductLinkModal();
          } catch (error) {
            console.error('Erro ao vincular produto selecionado ao fornecedor:', error);
            notify(
              error?.message || 'Não foi possível vincular o produto selecionado ao fornecedor.',
              'error'
            );
            setProductLinkInteractivity(true);
          } finally {
            productLinkIsLinking = false;
            setProductLinkLoading(false);
          }
        };

        if (productIframe) {
          productIframe.addEventListener('load', () => {
            if (productIframeLoading) {
              productIframeLoading.classList.add('hidden');
            }
            productIframe.classList.remove('hidden');
            syncProductModalHeight();
          });
        }

        productIframeCloseTriggers.forEach((trigger) => {
          trigger.addEventListener('click', (event) => {
            event.preventDefault();
            closeProductIframeModal();
          });
        });

        if (productIframeModal) {
          productIframeModal.addEventListener('click', (event) => {
            const target = event.target;
            if (target instanceof Element && target.hasAttribute('data-close-product-modal')) {
              event.preventDefault();
              closeProductIframeModal();
            }
          });
        }

        const handleProductIframeKeydown = (event) => {
          if (!productIframeModal || productIframeModal.classList.contains('hidden')) return;
          if (event.key === 'Escape') {
            event.preventDefault();
            closeProductIframeModal();
            return;
          }
          if (event.key !== 'Tab') return;
          const focusableElements = Array.from(
            productIframeModal.querySelectorAll(MODAL_FOCUSABLE_SELECTORS)
          ).filter((element) => element instanceof HTMLElement && element.offsetParent !== null);
          if (!focusableElements.length) return;
          const firstElement = focusableElements[0];
          const lastElement = focusableElements[focusableElements.length - 1];
          if (event.shiftKey && document.activeElement === firstElement) {
            event.preventDefault();
            lastElement.focus();
          } else if (!event.shiftKey && document.activeElement === lastElement) {
            event.preventDefault();
            firstElement.focus();
          }
        };

        document.addEventListener('keydown', handleProductIframeKeydown);

        productLinkCloseTriggers.forEach((trigger) => {
          trigger.addEventListener('click', (event) => {
            event.preventDefault();
            closeProductLinkModal();
          });
        });

        if (productLinkModal) {
          productLinkModal.addEventListener('click', (event) => {
            const target = event.target;
            if (target instanceof Element && target.hasAttribute('data-close-product-link-modal')) {
              event.preventDefault();
              closeProductLinkModal();
            }
          });
        }

        if (productLinkCard) {
          productLinkCard.addEventListener('click', (event) => {
            event.stopPropagation();
          });
        }

        if (productLinkForm) {
          productLinkForm.addEventListener('submit', (event) => {
            event.preventDefault();
            const term = productLinkSearchInput ? productLinkSearchInput.value : '';
            handleProductLinkSearch(term);
          });
        }

        if (productLinkSearchInput) {
          productLinkSearchInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
              event.preventDefault();
              handleProductLinkSearch(productLinkSearchInput.value);
            }
          });
        }

        const handleProductLinkKeydown = (event) => {
          if (!isProductLinkModalOpen()) return;
          if (event.key === 'Escape') {
            event.preventDefault();
            closeProductLinkModal();
            return;
          }
          if (event.key !== 'Tab') return;
          if (!productLinkModal) return;
          const focusableElements = Array.from(
            productLinkModal.querySelectorAll(MODAL_FOCUSABLE_SELECTORS)
          ).filter((element) => element instanceof HTMLElement && element.offsetParent !== null);
          if (!focusableElements.length) return;
          const firstElement = focusableElements[0];
          const lastElement = focusableElements[focusableElements.length - 1];
          if (event.shiftKey && document.activeElement === firstElement) {
            event.preventDefault();
            lastElement.focus();
          } else if (!event.shiftKey && document.activeElement === lastElement) {
            event.preventDefault();
            firstElement.focus();
          }
        };

        document.addEventListener('keydown', handleProductLinkKeydown);

        const getProductStatusLabel = (item) => {
          if (!item) return '';
          if (item.validationStatus === 'matched' && item.matchedProduct) return 'Cadastrado';
          if (item.validationStatus === 'pending' || item.validationStatus === 'checking') return 'Validando';
          if (item.validationStatus === 'error') return 'Erro';
          if (item.validationStatus === 'no-barcode') return 'Sem GTIN';
          if (!Array.isArray(item.barcodeCandidates) || item.barcodeCandidates.length === 0) return 'Sem GTIN';
          return 'Cadastrar';
        };

        const createStatusBadge = (classes, iconClass, text) => {
          const badge = document.createElement('span');
          badge.classList.add(
            'inline-flex',
            'items-center',
            'gap-1',
            'rounded-full',
            'border',
            'px-1.5',
            'py-0.5',
            'text-[9px]',
            'font-semibold',
            'whitespace-nowrap'
          );
          classes.forEach((cls) => badge.classList.add(cls));
          const icon = document.createElement('i');
          icon.className = `${iconClass} text-[10px]`;
          badge.appendChild(icon);
          const label = document.createElement('span');
          label.textContent = text;
          badge.appendChild(label);
          return badge;
        };

        const createProductActionButton = (label, iconClass = 'fas fa-plus') => {
          const button = document.createElement('button');
          button.type = 'button';
          button.classList.add(
            'inline-flex',
            'items-center',
            'gap-1',
            'rounded-full',
            'border',
            'border-primary/40',
            'bg-primary/10',
            'px-1.5',
            'py-0.5',
            'text-[9px]',
            'font-semibold',
            'text-primary',
            'hover:bg-primary/20',
            'focus:outline-none',
            'focus:ring-2',
            'focus:ring-primary/30',
            'whitespace-nowrap'
          );
          const icon = document.createElement('i');
          icon.className = iconClass;
          const labelSpan = document.createElement('span');
          labelSpan.textContent = label;
          button.append(icon, labelSpan);
          return button;
        };

        const buildBonificationIndicator = (item) => {
          const info = item?.bonificationInfo;
          if (!info?.hasBonification) return null;

          const indicator = document.createElement('span');
          indicator.className =
            'inline-flex h-4 w-4 items-center justify-center rounded-full bg-amber-100 text-[10px] font-bold text-amber-700';
          indicator.textContent = '!';

          const tooltipLines = [];
          if (Number.isFinite(info.bonusQuantity)) {
            tooltipLines.push(`Qtd bonificada: ${formatQuantity(info.bonusQuantity)}`);
          }
          if (Number.isFinite(info.regularQuantity)) {
            tooltipLines.push(`Qtd não bonificada: ${formatQuantity(info.regularQuantity)}`);
          }
          if (Array.isArray(info.bonusCfops) && info.bonusCfops.length) {
            tooltipLines.push(`CFOP bonificação: ${info.bonusCfops.join(', ')}`);
          }
          if (Array.isArray(info.regularCfops) && info.regularCfops.length) {
            tooltipLines.push(`CFOP venda: ${info.regularCfops.join(', ')}`);
          }

          const tooltipText = tooltipLines.length
            ? tooltipLines.join('\n')
            : 'Item com quantidades bonificadas agregadas.';
          indicator.title = tooltipText;
          indicator.setAttribute('aria-label', tooltipLines.length ? tooltipLines.join(' · ') : tooltipText);

          return indicator;
        };

        const buildInternalCodeCell = (item) => {
          const cell = document.createElement('td');
          cell.className = 'px-2 py-1.5 font-semibold text-gray-700 whitespace-nowrap';

          const wrapper = document.createElement('div');
          wrapper.className = 'inline-flex items-center gap-1';

          const codeValue = normalizeInternalCode(item?.internalCode) || '—';
          const codeSpan = document.createElement('span');
          codeSpan.textContent = codeValue;
          wrapper.appendChild(codeSpan);

          const indicator = buildBonificationIndicator(item);
          if (indicator) {
            wrapper.appendChild(indicator);
          }

          cell.appendChild(wrapper);
          return cell;
        };

        const buildStatusCell = (item) => {
          const cell = document.createElement('td');
          cell.className = 'px-2 py-1.5 bg-white sticky left-0 z-10 whitespace-nowrap';
          cell.dataset.validationStatus = item?.validationStatus || '';

          if (item?.validationStatus === 'matched' && item.matchedProduct) {
            cell.appendChild(
              createStatusBadge(
                ['border-emerald-200', 'bg-emerald-50', 'text-emerald-700'],
                'fas fa-check',
                'Cadastrado'
              )
            );
            return cell;
          }

          if (item?.validationStatus === 'pending' || item?.validationStatus === 'checking') {
            cell.appendChild(
              createStatusBadge(
                ['border-sky-200', 'bg-sky-50', 'text-sky-700'],
                'fas fa-spinner fa-spin',
                'Validando'
              )
            );
            return cell;
          }

          if (item?.validationStatus === 'error') {
            cell.appendChild(
              createStatusBadge(
                ['border-rose-200', 'bg-rose-50', 'text-rose-700'],
                'fas fa-circle-exclamation',
                'Erro'
              )
            );
            return cell;
          }

          if (!Array.isArray(item?.barcodeCandidates) || item.barcodeCandidates.length === 0) {
            cell.appendChild(
              createStatusBadge(
                ['border-amber-200', 'bg-amber-50', 'text-amber-700'],
                'fas fa-barcode',
                'Sem GTIN'
              )
            );
            return cell;
          }

          const button = createProductActionButton('Cadastrar', 'fas fa-plus');
          button.dataset.productBarcode = item?.barcodeCandidates?.[0] || '';
          button.addEventListener('click', () => openProductRegistration(item));
          cell.appendChild(button);
          return cell;
        };

        const getProductIdFromRecord = (product) => {
          if (!product || typeof product !== 'object') return '';
          const candidateKeys = ['_id', 'id', 'uuid'];
          for (const key of candidateKeys) {
            const value = typeof product[key] === 'string' ? product[key].trim() : '';
            if (value) {
              return value;
            }
          }
          return '';
        };

        const ensureConversionDefaults = (item) => {
          if (!item) return;
          const toNumeric = (value) => (Number.isFinite(value) ? value : parseNumber(value));

          const multiplierFromData = toNumeric(item.conversionMultiplier);
          const dividerFromData = toNumeric(item.conversionDivider);
          const quantityFromData = toNumeric(item.quantity);
          const qTribFromData = toNumeric(item.qTrib);

          if (!Object.prototype.hasOwnProperty.call(item, 'originalConversionMultiplier') && Number.isFinite(multiplierFromData)) {
            item.originalConversionMultiplier = multiplierFromData;
          }

          if (
            !Object.prototype.hasOwnProperty.call(item, 'originalConversionDivider') &&
            Number.isFinite(dividerFromData) &&
            dividerFromData > 0
          ) {
            item.originalConversionDivider = dividerFromData;
          }

          const numerator = Number.isFinite(multiplierFromData)
            ? multiplierFromData
            : Number.isFinite(quantityFromData)
            ? quantityFromData
            : null;
          const denominator = Number.isFinite(dividerFromData) && dividerFromData > 0
            ? dividerFromData
            : Number.isFinite(qTribFromData) && qTribFromData > 0
            ? qTribFromData
            : 1;

          const conversionFactor = Number.isFinite(numerator) && Number.isFinite(denominator) && denominator > 0
            ? numerator / denominator
            : null;

          if (!Object.prototype.hasOwnProperty.call(item, 'originalConversionFactor') && Number.isFinite(conversionFactor)) {
            item.originalConversionFactor = conversionFactor;
          }

          if (Number.isFinite(conversionFactor)) {
            item.conversion = conversionFactor;
            item.conversionMultiplier = conversionFactor;
            item.conversionDivider = 1;
          } else {
            item.conversion = null;
            if (!Number.isFinite(item.conversionMultiplier)) {
              item.conversionMultiplier = Number.isFinite(quantityFromData) ? quantityFromData : 1;
            }
            if (!Number.isFinite(item.conversionDivider) || item.conversionDivider <= 0) {
              item.conversionDivider = Number.isFinite(qTribFromData) && qTribFromData > 0 ? qTribFromData : 1;
            }
          }
        };

        const updateItemConversion = (item, factor) => {
          if (!item) return;
          if (Number.isFinite(factor)) {
            item.conversion = factor;
            item.conversionMultiplier = factor;
            item.conversionDivider = 1;
          } else {
            item.conversion = null;
          }
        };

        const formatConversionInputValue = (value) => {
          if (!Number.isFinite(value)) return '';
          return formatDecimal(value, { minimumFractionDigits: 3, maximumFractionDigits: 3 });
        };

        const buildConversionCell = (item) => {
          ensureConversionDefaults(item);
          const toNumeric = (value) => (Number.isFinite(value) ? value : parseNumber(value));
          const cell = document.createElement('td');
          cell.className = 'px-2 py-1.5 text-gray-600 whitespace-nowrap align-top';

          const wrapper = document.createElement('div');
          wrapper.className = 'flex flex-col gap-1.5';

          const supplierEntry =
            item?.matchedProduct && lastNfeData
              ? findSupplierEntryForProduct(item.matchedProduct, item, lastNfeData)
              : null;
          const supplierCalcType = canonicalSupplierCalcType(supplierEntry?.tipoCalculo);
          const supplierCalcValue = parseSupplierCalcValue(supplierEntry?.valorCalculo);
          let supplierBaseFactor = null;
          let supplierFactor = null;
          if (supplierEntry && supplierCalcType && supplierCalcValue !== null) {
            supplierBaseFactor = getBaseConversionFactor(item);
            if (!Number.isFinite(supplierBaseFactor) || supplierBaseFactor <= 0) {
              supplierBaseFactor = 1;
            }
            const computedFactor =
              supplierCalcType === 'divide'
                ? supplierBaseFactor / supplierCalcValue
                : supplierBaseFactor * supplierCalcValue;
            if (Number.isFinite(computedFactor) && computedFactor > 0) {
              supplierFactor = computedFactor;
            }
          }

          const factorText = document.createElement('span');
          factorText.className = 'text-[9px] text-right font-medium text-gray-500';
          const updateFactorText = () => {
            const factor = toNumeric(item?.conversion);
            if (Number.isFinite(factor)) {
              let suffix = '';
              if (item?.supplierAppliedConversion && !item?.manualConversionOverride) {
                const appliedType = item.supplierAppliedConversion.type;
                const appliedValue = item.supplierAppliedConversion.value;
                if (appliedType && Number.isFinite(appliedValue)) {
                  const symbol = appliedType === 'divide' ? '÷' : '×';
                  const formattedAppliedValue = formatConversionInputValue(appliedValue) || appliedValue;
                  suffix = ` (Fornecedor ${symbol} ${formattedAppliedValue})`;
                }
              }
              factorText.textContent = `Fator: ${formatDecimal(factor, {
                minimumFractionDigits: 3,
                maximumFractionDigits: 3,
              })}${suffix}`;
            } else {
              factorText.textContent = 'Fator: —';
            }
          };

          const handleTableRefresh = () => {
            const hasActiveFilters = Object.values(productTableState?.filters || {}).some(
              (value) => normalizeFilterText(value).length > 0
            );
            if (hasActiveFilters || productTableState?.sortKey) {
              requestAnimationFrame(() => updateProductTableDisplay());
            }
          };

          const commitConversionChange = (factor) => {
            const fromSupplierCalculation =
              Number.isFinite(supplierFactor) &&
              Number.isFinite(factor) &&
              Math.abs(supplierFactor - factor) <= 0.0005;

            if (fromSupplierCalculation && supplierEntry && supplierCalcType && supplierCalcValue !== null) {
              item.manualConversionOverride = false;
              item.supplierAppliedConversion = {
                type: supplierCalcType,
                value: supplierCalcValue,
                factor,
                supplierCode: canonicalSupplierProductCode(supplierEntry?.codigoProduto),
                supplierName: supplierEntry?.fornecedor || '',
                baseFactor: supplierBaseFactor ?? getBaseConversionFactor(item),
              };
            } else {
              item.manualConversionOverride = true;
              item.supplierAppliedConversion = null;
            }
            updateItemConversion(item, factor);
            updateFactorText();
            handleTableRefresh();
          };

          const createNumericEditor = (labelText, { initialValue, allowZero = false, step = 1, quickActions = [], onCommit }) => {
            let currentValue = Number.isFinite(initialValue) ? initialValue : null;
            const MIN_POSITIVE = 0.001;
            const container = document.createElement('div');
            container.className = 'flex flex-col items-end gap-1';

            const label = document.createElement('span');
            label.className = 'text-[9px] font-semibold uppercase tracking-wide text-gray-500';
            label.textContent = labelText;
            container.appendChild(label);

            const controlsRow = document.createElement('div');
            controlsRow.className = 'flex items-center gap-1';

            const input = document.createElement('input');
            input.type = 'text';
            input.inputMode = 'decimal';
            input.placeholder = '0,000';
            input.className =
              'w-20 rounded border border-gray-200 bg-white px-2 py-1 text-[11px] text-right font-semibold text-gray-700 focus:border-primary focus:outline-none focus:ring-1 focus:ring-primary/30';

            const formatValue = (value) => (Number.isFinite(value) ? formatConversionInputValue(value) : '');
            const normalizeValue = (value) => {
              const numeric = Number.isFinite(value) ? value : parseNumber(value);
              if (!Number.isFinite(numeric)) return null;
              const minValue = allowZero ? 0 : MIN_POSITIVE;
              const sanitized = numeric < minValue ? minValue : numeric;
              return Number.parseFloat(sanitized.toFixed(3));
            };

            const updateInputValue = () => {
              input.value = formatValue(currentValue);
            };

            if (Number.isFinite(currentValue)) {
              updateInputValue();
            }

            input.addEventListener('focus', () => {
              setTimeout(() => input.select(), 0);
            });

            const commitValue = (value) => {
              const normalized = normalizeValue(value);
              if (normalized === null) {
                updateInputValue();
                return;
              }
              currentValue = normalized;
              updateInputValue();
              if (typeof onCommit === 'function') {
                onCommit(normalized);
              }
            };

            const computeStep = (event) => {
              let computed = Number.isFinite(step) && step > 0 ? step : 1;
              if (event?.shiftKey) {
                computed *= 10;
              }
              if (event?.altKey) {
                computed /= 10;
              }
              if (event?.ctrlKey || event?.metaKey) {
                computed /= 100;
              }
              return computed;
            };

            const applyStep = (direction, event) => {
              const baseValue = (() => {
                const inputValue = parseNumber(input.value);
                if (Number.isFinite(inputValue)) return inputValue;
                if (Number.isFinite(currentValue)) return currentValue;
                return allowZero ? 0 : step || 1;
              })();
              const nextValue = baseValue + direction * computeStep(event);
              commitValue(nextValue);
            };

            const createStepButton = (symbol, direction) => {
              const button = document.createElement('button');
              button.type = 'button';
              button.className =
                'h-6 w-6 flex items-center justify-center rounded border border-gray-200 bg-white text-[11px] font-semibold text-gray-500 hover:bg-primary/10 hover:text-primary focus:outline-none focus:ring-1 focus:ring-primary/30';
              button.textContent = symbol;
              button.title =
                direction > 0
                  ? 'Aumentar valor (Shift=×10, Alt=÷10, Ctrl=÷100)'
                  : 'Reduzir valor (Shift=×10, Alt=÷10, Ctrl=÷100)';
              button.addEventListener('click', (event) => {
                event.preventDefault();
                applyStep(direction, event);
              });
              return button;
            };

            const decrementButton = createStepButton('−', -1);
            const incrementButton = createStepButton('+', 1);
            controlsRow.append(decrementButton, input, incrementButton);
            container.appendChild(controlsRow);

            input.addEventListener('keydown', (event) => {
              if (event.key === 'Enter') {
                event.preventDefault();
                commitValue(input.value);
                input.blur();
                return;
              }
              if (event.key === 'Escape') {
                event.preventDefault();
                updateInputValue();
                input.blur();
                return;
              }
              if (event.key === 'ArrowUp' || event.key === 'ArrowDown') {
                event.preventDefault();
                applyStep(event.key === 'ArrowUp' ? 1 : -1, event);
              }
            });

            input.addEventListener('blur', () => commitValue(input.value));

            if (quickActions.length > 0) {
              const quickRow = document.createElement('div');
              quickRow.className = 'flex flex-wrap items-center justify-end gap-1';
              quickActions.forEach((action) => {
                const quickButton = document.createElement('button');
                quickButton.type = 'button';
                quickButton.className =
                  'rounded border border-gray-200 bg-gray-50 px-1.5 py-0.5 text-[9px] font-medium text-gray-600 hover:border-primary hover:text-primary focus:outline-none focus:ring-1 focus:ring-primary/30';
                quickButton.textContent = action.label;
                if (action.title) {
                  quickButton.title = action.title;
                }
                quickButton.addEventListener('click', (event) => {
                  event.preventDefault();
                  const actionValue = typeof action.getValue === 'function' ? action.getValue() : action.value;
                  commitValue(actionValue);
                });
                quickRow.appendChild(quickButton);
              });
              container.appendChild(quickRow);
            }

            return container;
          };

          const xmlMultiplier = toNumeric(item?.originalConversionMultiplier);
          const xmlDivider = toNumeric(item?.originalConversionDivider);
          const xmlFactor = (() => {
            const storedFactor = toNumeric(item?.originalConversionFactor);
            if (Number.isFinite(storedFactor)) {
              return storedFactor;
            }
            if (Number.isFinite(xmlMultiplier) && Number.isFinite(xmlDivider) && xmlDivider > 0) {
              return xmlMultiplier / xmlDivider;
            }
            return null;
          })();

          let conversionInitial = toNumeric(item?.conversion);
          if (!Number.isFinite(conversionInitial)) {
            conversionInitial = 1;
          }
          const quickActions = [];
          if (Number.isFinite(xmlFactor)) {
            quickActions.push({ label: 'XML', value: Number.parseFloat(xmlFactor.toFixed(3)), title: 'Valor informado no XML' });
          }
          if (Number.isFinite(supplierFactor)) {
            const supplierValueLabel = formatConversionInputValue(supplierCalcValue) || supplierCalcValue;
            const supplierTitle = supplierCalcType === 'divide'
              ? `Aplicar cálculo do fornecedor (÷ ${supplierValueLabel})`
              : `Aplicar cálculo do fornecedor (× ${supplierValueLabel})`;
            quickActions.push({
              label: 'Fornecedor',
              value: Number.parseFloat(supplierFactor.toFixed(3)),
              title: supplierTitle,
            });
          }
          quickActions.push({ label: '0', value: 0, title: 'Definir como divisão (0)' });
          quickActions.push({ label: formatDecimal(0.5, { minimumFractionDigits: 1, maximumFractionDigits: 1 }), value: 0.5 });
          quickActions.push({ label: '1', value: 1, title: 'Fator 1 (sem conversão)' });
          quickActions.push({ label: '2', value: 2 });
          quickActions.push({ label: '3', value: 3 });

          const conversionEditor = createNumericEditor('Fator', {
            initialValue: conversionInitial,
            allowZero: true,
            step: 0.5,
            quickActions,
            onCommit: (value) => {
              commitConversionChange(value);
            },
          });

          wrapper.append(conversionEditor, factorText);
          updateFactorText();

          cell.appendChild(wrapper);
          return cell;
        };

        const buildUnitarizeCell = () => {
          const cell = document.createElement('td');
          cell.className = 'px-2 py-1.5 whitespace-nowrap';
          const label = document.createElement('label');
          label.className = 'inline-flex items-center gap-2 text-[9px] text-gray-600 whitespace-nowrap';
          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.className = 'h-3 w-3 rounded border-gray-300 text-primary focus:ring-primary/40';
          const text = document.createElement('span');
          text.textContent = 'Unitário';
          label.append(checkbox, text);
          cell.appendChild(label);
          return cell;
        };

        const buildSelectCell = (item) => {
          const cell = document.createElement('td');
          cell.className = 'px-2 py-1.5 whitespace-nowrap';
          const button = createProductActionButton('Selecionar', 'fas fa-pen-to-square');
          const productId = getProductIdFromRecord(item?.matchedProduct);
          const canOpenExistingProduct = item?.validationStatus === 'matched' && Boolean(productId);
          const isValidationInProgress =
            item?.validationStatus === 'pending' || item?.validationStatus === 'checking';

          if (canOpenExistingProduct) {
            button.title = 'Abrir o produto cadastrado para visualizar ou editar';
            button.addEventListener('click', () => openExistingProduct(item));
          } else if (!isValidationInProgress) {
            button.title = 'Selecionar um produto cadastrado para vincular a este item';
            button.addEventListener('click', () => openProductLinkModal(item));
          } else {
            button.disabled = true;
            button.classList.add('opacity-50', 'cursor-not-allowed');
            button.setAttribute('aria-disabled', 'true');
            button.title =
              'Disponível após localizar o produto cadastrado pelo XML importado';
          }

          cell.appendChild(button);
          return cell;
        };

        const buildNumericFilterValue = (displayText, rawValue) => {
          const numericValue = Number.isFinite(rawValue) ? rawValue : parseNumber(rawValue);
          if (!Number.isFinite(numericValue)) {
            return displayText || '';
          }
          const plain = String(numericValue).replace('.', ',');
          const digits = plain.replace(/\D+/g, '');
          return [displayText || '', plain, digits].filter(Boolean).join(' ');
        };

        const PRODUCT_TABLE_COLUMNS = [
          {
            key: 'status',
            label: 'Cadastrar',
            headerClass: 'sticky left-0 z-20 bg-gray-50 px-2 py-1.5 text-left shadow-sm',
            renderCell: (item) => buildStatusCell(item),
            getDisplayText: (item) => getProductStatusLabel(item),
            getFilterValue: (item) => getProductStatusLabel(item),
            getSortValue: (item) => getProductStatusLabel(item),
          },
          {
            key: 'unitarize',
            label: 'Unitarizar',
            headerClass: 'px-2 py-1.5 text-left',
            renderCell: () => buildUnitarizeCell(),
            getDisplayText: () => 'Unitário',
          },
          {
            key: 'select',
            label: 'Selecionar',
            headerClass: 'px-2 py-1.5 text-left',
            renderCell: (item) => buildSelectCell(item),
            getDisplayText: () => 'Selecionado',
          },
          {
            key: 'internalCode',
            label: 'Cod. Interno (SKU)',
            headerClass: 'px-2 py-1.5 text-left',
            renderCell: (item) => buildInternalCodeCell(item),
            getDisplayText: (item) => normalizeInternalCode(item?.internalCode) || '—',
          },
          {
            key: 'systemName',
            label: 'Nome',
            headerClass: 'px-2 py-1.5 text-left',
            cellClass: 'px-2 py-1.5 text-gray-700 whitespace-nowrap',
            getDisplayText: (item) => item?.matchedProduct?.nome || item?.description || '—',
          },
          {
            key: 'supplierCode',
            label: 'Cod_Fornecedor',
            headerClass: 'px-2 py-1.5 text-left',
            getDisplayText: (item) => item?.supplierCode || '—',
          },
          {
            key: 'barcode',
            label: 'Cod_Barras',
            headerClass: 'px-2 py-1.5 text-left',
            getDisplayText: (item) => item?.barcodeDisplay || 'SEM GTIN',
          },
          {
            key: 'barcodeTrib',
            label: 'Cod_Barras_Trib',
            headerClass: 'px-2 py-1.5 text-left',
            getDisplayText: (item) => item?.barcodeTribDisplay || 'SEM GTIN',
          },
          {
            key: 'supplierName',
            label: 'Nome no Fornecedor',
            headerClass: 'px-2 py-1.5 text-left',
            getDisplayText: (item) => item?.description || '—',
          },
          {
            key: 'conversion',
            label: 'Multiplicador/Divisão',
            headerClass: 'px-2 py-1.5 text-left',
            isNumeric: true,
            sortType: 'numeric',
            renderCell: (item) => buildConversionCell(item),
            getDisplayText: (item) =>
              formatDecimal(item?.conversion, { minimumFractionDigits: 3, maximumFractionDigits: 3 }),
            getFilterValue: (item) =>
              buildNumericFilterValue(
                formatDecimal(item?.conversion, { minimumFractionDigits: 3, maximumFractionDigits: 3 }),
                item?.conversion
              ),
            getSortValue: (item) =>
              Number.isFinite(item?.conversion) ? item.conversion : parseNumber(item?.conversion) || 0,
          },
          {
            key: 'unit',
            label: 'Unidade',
            headerClass: 'px-2 py-1.5 text-left',
            getDisplayText: (item) => item?.unit || '—',
          },
          {
            key: 'quantity',
            label: 'Quantidade',
            headerClass: 'px-2 py-1.5 text-right',
            cellClass: 'px-2 py-1.5 text-right text-gray-600 whitespace-nowrap',
            isNumeric: true,
            sortType: 'numeric',
            getDisplayText: (item) => formatQuantity(item?.quantity),
            getFilterValue: (item) => buildNumericFilterValue(formatQuantity(item?.quantity), item?.quantity),
            getSortValue: (item) => (Number.isFinite(item?.quantity) ? item.quantity : parseNumber(item?.quantity) || 0),
          },
          {
            key: 'unitPrice',
            label: 'Unitário (R$)',
            headerClass: 'px-2 py-1.5 text-right',
            cellClass: 'px-2 py-1.5 text-right text-gray-700 whitespace-nowrap',
            isNumeric: true,
            sortType: 'numeric',
            getDisplayText: (item) => formatMoneyValue(item?.unitPrice),
            getFilterValue: (item) => buildNumericFilterValue(formatMoneyValue(item?.unitPrice), item?.unitPrice),
            getSortValue: (item) =>
              Number.isFinite(item?.unitPrice) ? item.unitPrice : parseNumber(item?.unitPrice) || 0,
          },
          {
            key: 'discount',
            label: 'Desconto (R$)',
            headerClass: 'px-2 py-1.5 text-right',
            cellClass: 'px-2 py-1.5 text-right text-gray-700 whitespace-nowrap',
            isNumeric: true,
            sortType: 'numeric',
            getDisplayText: (item) => formatMoneyValue(item?.discount),
            getFilterValue: (item) => buildNumericFilterValue(formatMoneyValue(item?.discount), item?.discount),
            getSortValue: (item) => (Number.isFinite(item?.discount) ? item.discount : parseNumber(item?.discount) || 0),
          },
          {
            key: 'total',
            label: 'Total',
            headerClass: 'px-2 py-1.5 text-right',
            cellClass: 'px-2 py-1.5 text-right text-gray-700 whitespace-nowrap',
            isNumeric: true,
            sortType: 'numeric',
            getDisplayText: (item) => formatMoneyValue(item?.total),
            getFilterValue: (item) => buildNumericFilterValue(formatMoneyValue(item?.total), item?.total),
            getSortValue: (item) => (Number.isFinite(item?.total) ? item.total : parseNumber(item?.total) || 0),
          },
          {
            key: 'ncm',
            label: 'NCM',
            headerClass: 'px-2 py-1.5 text-left',
            getDisplayText: (item) => item?.ncm || '—',
          },
          {
            key: 'cfop',
            label: 'CFOP',
            headerClass: 'px-2 py-1.5 text-left',
            getDisplayText: (item) => item?.cfop || '—',
          },
          {
            key: 'cst',
            label: 'CST',
            headerClass: 'px-2 py-1.5 text-left',
            getDisplayText: (item) => item?.cst || '—',
          },
          {
            key: 'icmsRate',
            label: 'ICMS (%)',
            headerClass: 'px-2 py-1.5 text-right',
            cellClass: 'px-2 py-1.5 text-right text-gray-600 whitespace-nowrap',
            isNumeric: true,
            sortType: 'numeric',
            getDisplayText: (item) => formatPercentValue(item?.icmsRate),
            getFilterValue: (item) => buildNumericFilterValue(formatPercentValue(item?.icmsRate), item?.icmsRate),
            getSortValue: (item) => (Number.isFinite(item?.icmsRate) ? item.icmsRate : parseNumber(item?.icmsRate) || 0),
          },
          {
            key: 'icmsBase',
            label: 'Base ICMS (R$)',
            headerClass: 'px-2 py-1.5 text-right',
            cellClass: 'px-2 py-1.5 text-right text-gray-600 whitespace-nowrap',
            isNumeric: true,
            sortType: 'numeric',
            getDisplayText: (item) => formatMoneyValue(item?.icmsBase),
            getFilterValue: (item) => buildNumericFilterValue(formatMoneyValue(item?.icmsBase), item?.icmsBase),
            getSortValue: (item) => (Number.isFinite(item?.icmsBase) ? item.icmsBase : parseNumber(item?.icmsBase) || 0),
          },
          {
            key: 'icmsValue',
            label: 'Valor ICMS (R$)',
            headerClass: 'px-2 py-1.5 text-right',
            cellClass: 'px-2 py-1.5 text-right text-gray-600 whitespace-nowrap',
            isNumeric: true,
            sortType: 'numeric',
            getDisplayText: (item) => formatMoneyValue(item?.icmsValue),
            getFilterValue: (item) => buildNumericFilterValue(formatMoneyValue(item?.icmsValue), item?.icmsValue),
            getSortValue: (item) => (Number.isFinite(item?.icmsValue) ? item.icmsValue : parseNumber(item?.icmsValue) || 0),
          },
          {
            key: 'iva',
            label: 'IVA (%)',
            headerClass: 'px-2 py-1.5 text-right',
            cellClass: 'px-2 py-1.5 text-right text-gray-600 whitespace-nowrap',
            isNumeric: true,
            sortType: 'numeric',
            getDisplayText: (item) => formatPercentValue(item?.iva),
            getFilterValue: (item) => buildNumericFilterValue(formatPercentValue(item?.iva), item?.iva),
            getSortValue: (item) => (Number.isFinite(item?.iva) ? item.iva : parseNumber(item?.iva) || 0),
          },
          {
            key: 'icmsStRate',
            label: 'ICMS ST (%)',
            headerClass: 'px-2 py-1.5 text-right',
            cellClass: 'px-2 py-1.5 text-right text-gray-600 whitespace-nowrap',
            isNumeric: true,
            sortType: 'numeric',
            getDisplayText: (item) => formatPercentValue(item?.icmsStRate),
            getFilterValue: (item) => buildNumericFilterValue(formatPercentValue(item?.icmsStRate), item?.icmsStRate),
            getSortValue: (item) =>
              Number.isFinite(item?.icmsStRate) ? item.icmsStRate : parseNumber(item?.icmsStRate) || 0,
          },
          {
            key: 'icmsStValue',
            label: 'Valor ICMS ST (R$)',
            headerClass: 'px-2 py-1.5 text-right',
            cellClass: 'px-2 py-1.5 text-right text-gray-600 whitespace-nowrap',
            isNumeric: true,
            sortType: 'numeric',
            getDisplayText: (item) => formatMoneyValue(item?.icmsStValue),
            getFilterValue: (item) => buildNumericFilterValue(formatMoneyValue(item?.icmsStValue), item?.icmsStValue),
            getSortValue: (item) =>
              Number.isFinite(item?.icmsStValue) ? item.icmsStValue : parseNumber(item?.icmsStValue) || 0,
          },
          {
            key: 'ipiRate',
            label: 'IPI (%)',
            headerClass: 'px-2 py-1.5 text-right',
            cellClass: 'px-2 py-1.5 text-right text-gray-600 whitespace-nowrap',
            isNumeric: true,
            sortType: 'numeric',
            getDisplayText: (item) => formatPercentValue(item?.ipiRate),
            getFilterValue: (item) => buildNumericFilterValue(formatPercentValue(item?.ipiRate), item?.ipiRate),
            getSortValue: (item) => (Number.isFinite(item?.ipiRate) ? item.ipiRate : parseNumber(item?.ipiRate) || 0),
          },
          {
            key: 'ipiBase',
            label: 'Base IPI (R$)',
            headerClass: 'px-2 py-1.5 text-right',
            cellClass: 'px-2 py-1.5 text-right text-gray-600 whitespace-nowrap',
            isNumeric: true,
            sortType: 'numeric',
            getDisplayText: (item) => formatMoneyValue(item?.ipiBase),
            getFilterValue: (item) => buildNumericFilterValue(formatMoneyValue(item?.ipiBase), item?.ipiBase),
            getSortValue: (item) => (Number.isFinite(item?.ipiBase) ? item.ipiBase : parseNumber(item?.ipiBase) || 0),
          },
          {
            key: 'ipiValue',
            label: 'Valor IPI (R$)',
            headerClass: 'px-2 py-1.5 text-right',
            cellClass: 'px-2 py-1.5 text-right text-gray-600 whitespace-nowrap',
            isNumeric: true,
            sortType: 'numeric',
            getDisplayText: (item) => formatMoneyValue(item?.ipiValue),
            getFilterValue: (item) => buildNumericFilterValue(formatMoneyValue(item?.ipiValue), item?.ipiValue),
            getSortValue: (item) => (Number.isFinite(item?.ipiValue) ? item.ipiValue : parseNumber(item?.ipiValue) || 0),
          },
          {
            key: 'ipiCst',
            label: 'ST IPI',
            headerClass: 'px-2 py-1.5 text-left',
            getDisplayText: (item) => item?.ipiCst || '—',
          },
          {
            key: 'pisRate',
            label: 'Alíquota PIS (%)',
            headerClass: 'px-2 py-1.5 text-right',
            cellClass: 'px-2 py-1.5 text-right text-gray-600 whitespace-nowrap',
            isNumeric: true,
            sortType: 'numeric',
            getDisplayText: (item) => formatPercentValue(item?.pisRate),
            getFilterValue: (item) => buildNumericFilterValue(formatPercentValue(item?.pisRate), item?.pisRate),
            getSortValue: (item) => (Number.isFinite(item?.pisRate) ? item.pisRate : parseNumber(item?.pisRate) || 0),
          },
          {
            key: 'pisBase',
            label: 'Base PIS (R$)',
            headerClass: 'px-2 py-1.5 text-right',
            cellClass: 'px-2 py-1.5 text-right text-gray-600 whitespace-nowrap',
            isNumeric: true,
            sortType: 'numeric',
            getDisplayText: (item) => formatMoneyValue(item?.pisBase),
            getFilterValue: (item) => buildNumericFilterValue(formatMoneyValue(item?.pisBase), item?.pisBase),
            getSortValue: (item) => (Number.isFinite(item?.pisBase) ? item.pisBase : parseNumber(item?.pisBase) || 0),
          },
          {
            key: 'pisValue',
            label: 'Valor PIS (R$)',
            headerClass: 'px-2 py-1.5 text-right',
            cellClass: 'px-2 py-1.5 text-right text-gray-600 whitespace-nowrap',
            isNumeric: true,
            sortType: 'numeric',
            getDisplayText: (item) => formatMoneyValue(item?.pisValue),
            getFilterValue: (item) => buildNumericFilterValue(formatMoneyValue(item?.pisValue), item?.pisValue),
            getSortValue: (item) => (Number.isFinite(item?.pisValue) ? item.pisValue : parseNumber(item?.pisValue) || 0),
          },
          {
            key: 'cofinsRate',
            label: 'ST CONFINS (%)',
            headerClass: 'px-2 py-1.5 text-right',
            cellClass: 'px-2 py-1.5 text-right text-gray-600 whitespace-nowrap',
            isNumeric: true,
            sortType: 'numeric',
            getDisplayText: (item) => formatPercentValue(item?.cofinsRate),
            getFilterValue: (item) => buildNumericFilterValue(formatPercentValue(item?.cofinsRate), item?.cofinsRate),
            getSortValue: (item) =>
              Number.isFinite(item?.cofinsRate) ? item.cofinsRate : parseNumber(item?.cofinsRate) || 0,
          },
          {
            key: 'cofinsBase',
            label: 'Base CONFINS (R$)',
            headerClass: 'px-2 py-1.5 text-right',
            cellClass: 'px-2 py-1.5 text-right text-gray-600 whitespace-nowrap',
            isNumeric: true,
            sortType: 'numeric',
            getDisplayText: (item) => formatMoneyValue(item?.cofinsBase),
            getFilterValue: (item) => buildNumericFilterValue(formatMoneyValue(item?.cofinsBase), item?.cofinsBase),
            getSortValue: (item) =>
              Number.isFinite(item?.cofinsBase) ? item.cofinsBase : parseNumber(item?.cofinsBase) || 0,
          },
          {
            key: 'cofinsValue',
            label: 'Valor CONFINS (R$)',
            headerClass: 'px-2 py-1.5 text-right',
            cellClass: 'px-2 py-1.5 text-right text-gray-600 whitespace-nowrap',
            isNumeric: true,
            sortType: 'numeric',
            getDisplayText: (item) => formatMoneyValue(item?.cofinsValue),
            getFilterValue: (item) => buildNumericFilterValue(formatMoneyValue(item?.cofinsValue), item?.cofinsValue),
            getSortValue: (item) =>
              Number.isFinite(item?.cofinsValue) ? item.cofinsValue : parseNumber(item?.cofinsValue) || 0,
          },
          {
            key: 'freight',
            label: 'Frete (R$)',
            headerClass: 'px-2 py-1.5 text-right',
            cellClass: 'px-2 py-1.5 text-right text-gray-600 whitespace-nowrap',
            isNumeric: true,
            sortType: 'numeric',
            getDisplayText: (item) => formatMoneyValue(item?.freight),
            getFilterValue: (item) => buildNumericFilterValue(formatMoneyValue(item?.freight), item?.freight),
            getSortValue: (item) => (Number.isFinite(item?.freight) ? item.freight : parseNumber(item?.freight) || 0),
          },
          {
            key: 'other',
            label: 'Valor Outros (R$)',
            headerClass: 'px-2 py-1.5 text-right',
            cellClass: 'px-2 py-1.5 text-right text-gray-600 whitespace-nowrap',
            isNumeric: true,
            sortType: 'numeric',
            getDisplayText: (item) => formatMoneyValue(item?.other),
            getFilterValue: (item) => buildNumericFilterValue(formatMoneyValue(item?.other), item?.other),
            getSortValue: (item) => (Number.isFinite(item?.other) ? item.other : parseNumber(item?.other) || 0),
          },
        ];

        const PRODUCT_TABLE_COLUMNS_MAP = new Map(PRODUCT_TABLE_COLUMNS.map((column) => [column.key, column]));
        const PRODUCT_TABLE_COLUMN_COUNT = PRODUCT_TABLE_COLUMNS.length;
        const productTableState = {
          filters: {},
          sortKey: null,
          sortDirection: 'asc',
        };
        const productTableFilterInputs = new Map();
        const productTableSortButtons = new Map();
        let productTableOriginalItems = [];
        let productTableHeaderInitialized = false;

        const normalizeFilterText = (value) =>
          String(value ?? '')
            .normalize('NFD')
            .replace(/[\u0300-\u036f]/g, '')
            .replace(/\s+/g, ' ')
            .trim()
            .toLowerCase();

        const createTextCell = (value, className = 'px-2 py-1.5 text-gray-600 whitespace-nowrap') => {
          const cell = document.createElement('td');
          cell.className = className;
          if (!cell.classList.contains('whitespace-nowrap')) {
            cell.classList.add('whitespace-nowrap');
          }
          cell.textContent = value && value !== '' ? value : '—';
          return cell;
        };

        const setSortButtonState = (button, isActive) => {
          if (!button) return;
          if (isActive) {
            button.classList.add('text-primary', 'border-primary/40', 'bg-primary/10');
            button.classList.remove('text-gray-400');
            button.setAttribute('aria-pressed', 'true');
          } else {
            button.classList.remove('text-primary', 'border-primary/40', 'bg-primary/10');
            button.classList.add('text-gray-400');
            button.setAttribute('aria-pressed', 'false');
          }
        };

        const updateProductTableSortIndicators = () => {
          productTableSortButtons.forEach(({ ascButton, descButton }, key) => {
            const isActive = productTableState.sortKey === key;
            setSortButtonState(ascButton, isActive && productTableState.sortDirection === 'asc');
            setSortButtonState(descButton, isActive && productTableState.sortDirection === 'desc');
          });
        };

        const toggleProductTableSort = (columnKey, direction) => {
          if (!columnKey) return;
          const isSameColumn = productTableState.sortKey === columnKey && productTableState.sortDirection === direction;
          if (isSameColumn) {
            productTableState.sortKey = null;
            productTableState.sortDirection = 'asc';
          } else {
            productTableState.sortKey = columnKey;
            productTableState.sortDirection = direction === 'desc' ? 'desc' : 'asc';
          }
          updateProductTableSortIndicators();
          updateProductTableDisplay();
        };

        const setProductTableFilter = (columnKey, value) => {
          if (!columnKey) return;
          productTableState.filters[columnKey] = value || '';
          updateProductTableDisplay();
        };

        const applyProductTableState = (items) => {
          if (!Array.isArray(items)) return [];
          const activeFilters = Object.entries(productTableState.filters || {}).filter(
            ([, raw]) => normalizeFilterText(raw).length > 0
          );

          let filteredItems = items;
          if (activeFilters.length) {
            filteredItems = items.filter((item) =>
              activeFilters.every(([key, raw]) => {
                const filterValue = normalizeFilterText(raw);
                if (!filterValue) return true;
                const column = PRODUCT_TABLE_COLUMNS_MAP.get(key);
                if (!column) return true;
                const columnValue =
                  (typeof column.getFilterValue === 'function'
                    ? column.getFilterValue(item)
                    : typeof column.getDisplayText === 'function'
                    ? column.getDisplayText(item)
                    : '') ?? '';
                const normalizedColumn = normalizeFilterText(columnValue);
                return normalizedColumn.includes(filterValue);
              })
            );
          } else {
            filteredItems = items.slice();
          }

          const { sortKey, sortDirection } = productTableState;
          if (!sortKey) {
            return filteredItems;
          }

          const column = PRODUCT_TABLE_COLUMNS_MAP.get(sortKey);
          if (!column) {
            return filteredItems;
          }

          const directionMultiplier = sortDirection === 'desc' ? -1 : 1;
          const sortedItems = filteredItems.slice().sort((a, b) => {
            const valueA =
              typeof column.getSortValue === 'function'
                ? column.getSortValue(a)
                : typeof column.getFilterValue === 'function'
                ? column.getFilterValue(a)
                : typeof column.getDisplayText === 'function'
                ? column.getDisplayText(a)
                : '';
            const valueB =
              typeof column.getSortValue === 'function'
                ? column.getSortValue(b)
                : typeof column.getFilterValue === 'function'
                ? column.getFilterValue(b)
                : typeof column.getDisplayText === 'function'
                ? column.getDisplayText(b)
                : '';

            if (column.sortType === 'numeric') {
              const numericA = Number.isFinite(valueA) ? valueA : parseNumber(valueA);
              const numericB = Number.isFinite(valueB) ? valueB : parseNumber(valueB);
              const safeA = Number.isFinite(numericA) ? numericA : Number.NEGATIVE_INFINITY;
              const safeB = Number.isFinite(numericB) ? numericB : Number.NEGATIVE_INFINITY;
              if (safeA === safeB) {
                const indexA = Number.isFinite(a?.index) ? a.index : 0;
                const indexB = Number.isFinite(b?.index) ? b.index : 0;
                return indexA - indexB;
              }
              return safeA > safeB ? directionMultiplier : -directionMultiplier;
            }

            const textA = String(valueA ?? '');
            const textB = String(valueB ?? '');
            const comparison = textA.localeCompare(textB, 'pt-BR', { sensitivity: 'base', numeric: true });
            if (comparison === 0) {
              const indexA = Number.isFinite(a?.index) ? a.index : 0;
              const indexB = Number.isFinite(b?.index) ? b.index : 0;
              return indexA - indexB;
            }
            return comparison * directionMultiplier;
          });

          return sortedItems;
        };

        const initializeProductTableHeader = () => {
          if (!importProductsTableHead || productTableHeaderInitialized) return;
          productTableHeaderInitialized = true;
          importProductsTableHead.innerHTML = '';
          const headerRow = document.createElement('tr');

          PRODUCT_TABLE_COLUMNS.forEach((column) => {
            const th = document.createElement('th');
            th.dataset.columnKey = column.key;
            const baseClasses = column.headerClass ? column.headerClass.split(/\s+/) : [];
            if (baseClasses.length) {
              th.classList.add(...baseClasses);
            }
            th.classList.add('align-top', 'bg-gray-50', 'whitespace-nowrap');

            const wrapper = document.createElement('div');
            wrapper.className = 'flex flex-col gap-1';

            const labelRow = document.createElement('div');
            labelRow.className = 'flex items-center justify-between gap-1';

            const label = document.createElement('span');
            label.textContent = column.label;
            label.className = 'flex-1 text-[8px] font-semibold uppercase leading-tight tracking-wide text-gray-600';
            if (column.isNumeric) {
              label.classList.add('text-right');
            }
            labelRow.appendChild(label);

            const sortGroup = document.createElement('div');
            sortGroup.className = 'flex flex-col items-center justify-center gap-px text-gray-400';

            const createSortButton = (direction) => {
              const button = document.createElement('button');
              button.type = 'button';
              button.dataset.sortDirection = direction;
              button.classList.add(
                'flex',
                'h-3.5',
                'w-3.5',
                'items-center',
                'justify-center',
                'rounded',
                'border',
                'border-transparent',
                'text-gray-400',
                'transition',
                'hover:text-primary',
                'focus:outline-none',
                'focus:ring-1',
                'focus:ring-primary/40'
              );
              button.setAttribute(
                'aria-label',
                `Ordenar ${direction === 'asc' ? 'crescente' : 'decrescente'} pela coluna ${column.label}`
              );
              const icon = document.createElement('i');
              icon.className = direction === 'asc' ? 'fas fa-sort-up text-[9px]' : 'fas fa-sort-down text-[9px]';
              button.appendChild(icon);
              button.addEventListener('click', () => toggleProductTableSort(column.key, direction));
              return button;
            };

            const ascButton = createSortButton('asc');
            const descButton = createSortButton('desc');
            sortGroup.append(ascButton, descButton);
            labelRow.appendChild(sortGroup);

            const filterInput = document.createElement('input');
            filterInput.type = 'text';
            filterInput.placeholder = 'Filtrar';
            filterInput.value = productTableState.filters[column.key] || '';
            filterInput.classList.add(
              'rounded',
              'border',
              'border-gray-200',
              'bg-white',
              'px-1',
              'py-0.5',
              'text-[8px]',
              'font-medium',
              'text-gray-600',
              'placeholder:text-gray-400',
              'focus:border-primary',
              'focus:outline-none',
              'focus:ring-2',
              'focus:ring-primary/20'
            );
            if (column.isNumeric) {
              filterInput.classList.add('text-right');
            }
            filterInput.addEventListener('input', (event) => {
              setProductTableFilter(column.key, event.target.value || '');
            });

            wrapper.append(labelRow, filterInput);
            th.appendChild(wrapper);
            headerRow.appendChild(th);

            productTableFilterInputs.set(column.key, filterInput);
            productTableSortButtons.set(column.key, { ascButton, descButton });
          });

          importProductsTableHead.appendChild(headerRow);
          updateProductTableSortIndicators();
        };

        const updateProductTableDisplay = () => {
          if (!importProductsTableBody) return;

          importProductsTableBody.innerHTML = '';

          if (!Array.isArray(productTableOriginalItems) || !productTableOriginalItems.length) {
            const emptyRow = document.createElement('tr');
            const emptyCell = document.createElement('td');
            emptyCell.colSpan = PRODUCT_TABLE_COLUMN_COUNT;
            emptyCell.className = 'px-3 py-6 text-center text-[10px] text-gray-500';
            emptyCell.textContent = 'Importe um XML autorizado para listar os itens da NF-e.';
            emptyRow.appendChild(emptyCell);
            importProductsTableBody.appendChild(emptyRow);
            updateProductValidationBadge([]);
            return;
          }

          const itemsToRender = applyProductTableState(productTableOriginalItems);

          if (!itemsToRender.length) {
            const emptyRow = document.createElement('tr');
            const emptyCell = document.createElement('td');
            emptyCell.colSpan = PRODUCT_TABLE_COLUMN_COUNT;
            emptyCell.className = 'px-3 py-6 text-center text-[10px] text-gray-500';
            emptyCell.textContent = 'Nenhum item encontrado com os filtros aplicados.';
            emptyRow.appendChild(emptyCell);
            importProductsTableBody.appendChild(emptyRow);
            updateProductValidationBadge(productTableOriginalItems);
            return;
          }

          const fragment = document.createDocumentFragment();

          itemsToRender.forEach((item) => {
            const row = document.createElement('tr');
            row.className = 'hover:bg-primary/5';
            const rowIndex = Number.isFinite(item?.index) ? item.index : productTableOriginalItems.indexOf(item);
            row.dataset.itemIndex = String(rowIndex >= 0 ? rowIndex : 0);

            if (item?.validationStatus === 'not-found') {
              row.classList.add('bg-amber-50/60');
            } else if (item?.validationStatus === 'error') {
              row.classList.add('bg-rose-50/60');
            }

            PRODUCT_TABLE_COLUMNS.forEach((column) => {
              let cell = null;
              if (typeof column.renderCell === 'function') {
                cell = column.renderCell(item);
              } else {
                const value =
                  typeof column.getDisplayText === 'function' ? column.getDisplayText(item) : item?.[column.key] || '—';
                const className = column.cellClass || 'px-2 py-1.5 text-gray-600 whitespace-nowrap';
                cell = createTextCell(value, className);
              }
              if (!cell) return;
              if (!cell.classList.contains('whitespace-nowrap')) {
                cell.classList.add('whitespace-nowrap');
              }
              row.appendChild(cell);
            });

            fragment.appendChild(row);
          });

          importProductsTableBody.appendChild(fragment);
          updateProductValidationBadge(productTableOriginalItems);
        };

        const updateProductValidationBadge = (items) => {
          if (!importXmlValidationText) return;
          if (!Array.isArray(items) || !items.length) {
            importXmlValidationText.textContent = 'Importe o XML autorizado para validar os itens.';
            applyValidationStyles('info');
            return;
          }
          const hasError = items.some((item) => item.validationStatus === 'error');
          if (hasError) {
            importXmlValidationText.textContent = 'Falha ao validar produtos na base cadastrada.';
            applyValidationStyles('error');
            return;
          }
          const isPending = items.some((item) => item.validationStatus === 'pending' || item.validationStatus === 'checking');
          if (isPending) {
            importXmlValidationText.textContent = 'Validando produtos pelo fornecedor e código de barras...';
            applyValidationStyles('info');
            return;
          }
          const withBarcode = items.filter((item) => Array.isArray(item?.barcodeCandidates) && item.barcodeCandidates.length);
          const withoutBarcodeCount = items.length - withBarcode.length;
          const notFoundCount = withBarcode.filter((item) => item.validationStatus === 'not-found').length;
          if (!withBarcode.length) {
            importXmlValidationText.textContent = 'XML sem GTIN: valide os produtos manualmente.';
            applyValidationStyles('info');
            return;
          }
          if (notFoundCount > 0) {
            const suffix = notFoundCount === 1 ? '' : 's';
            importXmlValidationText.textContent = `${notFoundCount} produto${suffix} sem cadastro pelo código de barras.`;
            applyValidationStyles('warning');
            return;
          }
          if (withoutBarcodeCount > 0) {
            const suffix = withoutBarcodeCount === 1 ? '' : 's';
            importXmlValidationText.textContent = `${withoutBarcodeCount} item${suffix} sem GTIN precisa${suffix ? 'm' : ''} de revisão.`;
            applyValidationStyles('warning');
            return;
          }
          importXmlValidationText.textContent = 'Todos os produtos foram localizados na base.';
          applyValidationStyles('success');
        };

        function renderImportedProducts(items = []) {
          if (!importProductsTableBody) return;
          if (!productTableHeaderInitialized) {
            initializeProductTableHeader();
          }

          productTableOriginalItems = Array.isArray(items) ? items : [];
          if (productTableOriginalItems.length) {
            ensureUniqueInternalCodes(productTableOriginalItems);
          }

          updateProductTableDisplay();
        }

        const buildSupplierLookupKey = (supplierInfo, supplierCode) => {
          const normalizedCode = canonicalSupplierProductCode(supplierCode);
          if (!normalizedCode) return '';
          const parts = [normalizedCode];
          if (supplierInfo) {
            const supplierNameKey = canonicalSupplierName(supplierInfo.name);
            if (supplierNameKey) {
              parts.push(`NAME:${supplierNameKey}`);
            }
            const supplierDocumentKey = digitsOnly(supplierInfo.document);
            if (supplierDocumentKey) {
              parts.push(`DOC:${supplierDocumentKey}`);
            }
          }
          return parts.join('::');
        };

        const findProductBySupplierReference = async (supplierInfo, supplierCode) => {
          const normalizedCanonicalCode = canonicalSupplierProductCode(supplierCode);
          if (!normalizedCanonicalCode) return null;

          const normalizedSupplierCode = normalizeSupplierProductCode(supplierCode);
          const cacheKey = buildSupplierLookupKey(supplierInfo, supplierCode);
          if (cacheKey && supplierReferenceLookupCache.has(cacheKey)) {
            return supplierReferenceLookupCache.get(cacheKey);
          }
          if (cacheKey && supplierReferenceLookupPromises.has(cacheKey)) {
            return supplierReferenceLookupPromises.get(cacheKey);
          }

          const params = new URLSearchParams();
          params.set('supplierCode', normalizedSupplierCode);
          if (supplierInfo?.name) {
            params.set('supplierName', supplierInfo.name);
          }
          if (supplierInfo?.document) {
            const documentDigits = digitsOnly(supplierInfo.document);
            if (documentDigits) {
              params.set('supplierDocument', documentDigits);
            }
          }

          const headers = buildAuthHeaders();
          const requestPromise = (async () => {
            const response = await fetch(
              `${apiBaseUrl}/products/search-by-supplier?${params.toString()}`,
              { headers }
            );
            const payload = await response.json().catch(() => ({}));

            if (response.status === 401) {
              handleAuthError();
            }

            if (response.status === 404) {
              if (cacheKey) {
                supplierReferenceLookupCache.set(cacheKey, null);
              }
              return null;
            }

            if (!response.ok) {
              throw new Error(
                payload?.message ||
                  `Falha ao consultar produtos do fornecedor (status ${response.status}).`
              );
            }

            const product = payload?.product || null;
            if (cacheKey) {
              supplierReferenceLookupCache.set(cacheKey, product);
            }
            return product;
          })()
            .catch((error) => {
              if (cacheKey) {
                supplierReferenceLookupCache.delete(cacheKey);
              }
              throw error;
            })
            .finally(() => {
              if (cacheKey) {
                supplierReferenceLookupPromises.delete(cacheKey);
              }
            });

          if (cacheKey) {
            supplierReferenceLookupPromises.set(cacheKey, requestPromise);
          }
          return requestPromise;
        };

        const findProductByBarcode = async (barcodeDigits) => {
          const normalized = normalizeBarcodeForComparison(barcodeDigits);
          if (!normalized) return null;
          if (productLookupCache.has(normalized)) {
            return productLookupCache.get(normalized);
          }
          if (productLookupPromises.has(normalized)) {
            return productLookupPromises.get(normalized);
          }
          const promise = (async () => {
            const response = await fetch(
              `${apiBaseUrl}/products?search=${encodeURIComponent(normalized)}&limit=8`,
              { headers: buildAuthHeaders() }
            );
            const payload = await response.json().catch(() => ({}));
            if (!response.ok) {
              if (response.status === 401) {
                handleAuthError();
              }
              throw new Error(payload?.message || `Falha ao consultar produtos (status ${response.status}).`);
            }
            const products = Array.isArray(payload?.products)
              ? payload.products
              : Array.isArray(payload)
              ? payload
              : [];
            const match =
              products.find((product) => getProductBarcodeFromRecord(product) === normalized) || null;
            productLookupCache.set(normalized, match);
            return match;
          })();
          productLookupPromises.set(normalized, promise);
          try {
            return await promise;
          } finally {
            productLookupPromises.delete(normalized);
          }
        };

        const findProductMatchForCandidates = async (candidates) => {
          if (!Array.isArray(candidates) || !candidates.length) return null;
          for (const candidate of candidates) {
            const product = await findProductByBarcode(candidate);
            if (product) return product;
          }
          return null;
        };

        const validateImportedProducts = async (nfeData) => {
          if (!nfeData) return;
          const items = Array.isArray(nfeData.items) ? nfeData.items : [];
          const sequence = ++productValidationSequence;

          if (!items.length) {
            renderImportedProducts([]);
            return;
          }

          const supplierInfo = resolveActiveSupplierInfo(nfeData);
          const itemsWithSupplierReference = items.filter((item) =>
            Boolean(canonicalSupplierProductCode(item?.supplierCode))
          );
          const itemsWithBarcode = items.filter(
            (item) => Array.isArray(item?.barcodeCandidates) && item.barcodeCandidates.length
          );
          const pendingValidationItems = Array.from(
            new Set([...itemsWithSupplierReference, ...itemsWithBarcode])
          );
          if (pendingValidationItems.length) {
            pendingValidationItems.forEach((item) => {
              item.validationStatus = 'checking';
            });
          }

          renderImportedProducts(items);

          let hadError = false;
          const linkingTasks = [];

          for (const item of items) {
            if (sequence !== productValidationSequence) {
              return;
            }

            const hasSupplierReference = Boolean(canonicalSupplierProductCode(item?.supplierCode));
            const hasBarcodeCandidates = Array.isArray(item?.barcodeCandidates) && item.barcodeCandidates.length;
            let matchedProduct = null;
            let matched = false;

            if (hasSupplierReference) {
              try {
                matchedProduct = await findProductBySupplierReference(supplierInfo, item.supplierCode);
                if (sequence !== productValidationSequence) {
                  return;
                }
                matched = Boolean(matchedProduct);
              } catch (error) {
                console.error('Erro ao validar produto pelo fornecedor:', error);
                item.validationStatus = 'error';
                hadError = true;
                continue;
              }
            }

            if (!matched && hasBarcodeCandidates) {
              try {
                matchedProduct = await findProductMatchForCandidates(item.barcodeCandidates);
                if (sequence !== productValidationSequence) {
                  return;
                }
                matched = Boolean(matchedProduct);
              } catch (error) {
                console.error('Erro ao validar produto pelo código de barras:', error);
                item.validationStatus = 'error';
                hadError = true;
                continue;
              }
            }

            if (matched && matchedProduct) {
              item.matchedProduct = matchedProduct;
              item.validationStatus = 'matched';
              applySupplierConversionFromProduct(item, matchedProduct, nfeData);
              const linkPromise = ensureProductSupplierLink(matchedProduct, item, nfeData);
              if (linkPromise) {
                linkingTasks.push(
                  linkPromise.catch((error) => {
                    console.error('Erro ao vincular produto ao fornecedor automaticamente:', error);
                    if (!supplierLinkErrorNotified) {
                      notify(
                        'Não foi possível vincular alguns produtos ao fornecedor automaticamente. Verifique os cadastros.',
                        'warning'
                      );
                      supplierLinkErrorNotified = true;
                    }
                    return null;
                  })
                );
              }
            } else if (hasSupplierReference || hasBarcodeCandidates) {
              item.matchedProduct = null;
              item.validationStatus = 'not-found';
            }
          }

          if (sequence !== productValidationSequence) {
            return;
          }

          if (linkingTasks.length) {
            await Promise.all(linkingTasks);
            if (sequence !== productValidationSequence) {
              return;
            }
          }

          renderImportedProducts(items);

          if (hadError) {
            notify(
              'Alguns produtos não puderam ser validados automaticamente. Tente novamente em instantes.',
              'error'
            );
          }
        };

        const updateSummaryFromData = (data) => {
          if (!data) {
            setText(importSummaryEmitenteName, 'Informe a chave ou importe o XML');
            setText(importSummaryEmitenteDocument, 'Documento não identificado');
            setText(importSummaryAccessKey, '------------------------------');
            setText(importSummaryAccessKeyDetails, 'DV -- · Ambiente não identificado');
            setText(importSummaryProtocol, 'Protocolo não informado');
            setText(importSummaryProtocolReceived, 'Recebimento não disponível');
            setText(importSummarySupplierName, 'Fornecedor não localizado');
            setText(importSummarySupplierDocument, 'Documento não disponível');
            setText(importSummaryTotal, 'R$ 0,00');
            setText(importSummaryTotalStatus, 'Aguardando importação do XML');
            setText(importSummaryDestName, 'Destinatário não identificado');
            setText(importSummaryDestDocument, 'Documento não disponível');
            ['nf-number', 'nf-serie', 'nf-emissao', 'nf-entrada', 'cfop', 'natureza', 'modalidade-frete', 'indicador-ie'].forEach(
              (key) => setSummaryInput(key, '')
            );
            if (importXmlNumber) {
              importXmlNumber.textContent = 'XML não importado';
            }
            if (importXmlValidationText) {
              importXmlValidationText.textContent = 'Aguardando validação fiscal';
            }
            applyValidationStyles('info');
            productValidationSequence += 1;
            renderImportedProducts([]);
            return;
          }

          const supplierDoc = composeDocumentLine(data.emit?.document, data.emit?.stateRegistration);
          const destDoc = composeDocumentLine(data.dest?.document, data.dest?.stateRegistration);

          setText(importSummaryEmitenteName, data.emit?.name || 'Emitente não identificado');
          setText(importSummaryEmitenteDocument, supplierDoc || 'Documento não identificado');

          if (data.accessKey) {
            setText(importSummaryAccessKey, data.accessKey);
            setText(importSummaryAccessKeyDetails, `DV ${data.accessKey.slice(-1)} · ${mapEnvironment(data.ambient)}`);
            if (importXmlNumber) {
              importXmlNumber.textContent = `XML nº ${data.accessKey}`;
            }
          } else {
            setText(importSummaryAccessKey, '------------------------------');
            setText(importSummaryAccessKeyDetails, 'DV -- · Ambiente não identificado');
            if (importXmlNumber) {
              importXmlNumber.textContent = 'XML importado';
            }
          }

          const protocolNumber = data.protocol?.number || '';
          if (protocolNumber) {
            setText(importSummaryProtocol, protocolNumber);
            const received = normalizeDate(data.protocol?.receivedAt);
            const receivedText = received.displayDateTime || received.display || received.dateInput || '';
            setText(
              importSummaryProtocolReceived,
              receivedText ? `Recebido em ${receivedText}` : 'Recebimento registrado pela SEFAZ'
            );
            if (importXmlValidationText) {
              importXmlValidationText.textContent = 'XML autorizado na SEFAZ';
            }
            applyValidationStyles('success');
          } else {
            setText(importSummaryProtocol, 'Protocolo não informado');
            setText(importSummaryProtocolReceived, 'Recebimento não disponível');
            if (importXmlValidationText) {
              importXmlValidationText.textContent = 'XML importado (aguardando protocolo)';
            }
            applyValidationStyles('warning');
          }

          setText(importSummarySupplierName, data.emit?.name || 'Fornecedor não localizado');
          setText(importSummarySupplierDocument, supplierDoc || 'Documento não disponível');

          const totalFormatted = formatCurrencyBRL(data.totals?.totalValue);
          setText(importSummaryTotal, totalFormatted);
          setText(importSummaryTotalStatus, 'Valor informado pelo XML autorizado');

          setText(importSummaryDestName, data.dest?.name || 'Destinatário não identificado');
          setText(importSummaryDestDocument, destDoc || 'Documento não disponível');

          const emission = normalizeDate(data.ide?.emissionDate);
          const entry = normalizeDate(data.ide?.entryDate);

          setSummaryInput('nf-number', data.ide?.number || '');
          setSummaryInput('nf-serie', data.ide?.serie || '');
          setSummaryInput('nf-emissao', emission.display || emission.dateInput || '');
          setSummaryInput('nf-entrada', entry.display || entry.dateInput || '');
          setSummaryInput('cfop', data.ide?.cfop || '');
          setSummaryInput('natureza', data.ide?.natOp || '');
          setSummaryInput('modalidade-frete', mapFrete(data.ide?.freightMode));
          setSummaryInput('indicador-ie', formatIndIe(data.dest?.indIEDest));

          const items = Array.isArray(data.items) ? data.items : [];
          renderImportedProducts(items);
        };

        const setImportModalContext = (context) => {
          const normalized = context === IMPORT_CONTEXT_BONUS ? IMPORT_CONTEXT_BONUS : IMPORT_CONTEXT_FULL;
          importModalContext = normalized;

          if (normalized !== IMPORT_CONTEXT_BONUS) {
            pendingBonusData = null;
          }

          if (confirmImportIcon) {
            if (normalized === IMPORT_CONTEXT_BONUS) {
              confirmImportIcon.className = 'fas fa-gift';
            } else if (defaultConfirmIconClass) {
              confirmImportIcon.className = defaultConfirmIconClass;
            }
          }

          if (confirmImportText) {
            confirmImportText.textContent =
              normalized === IMPORT_CONTEXT_BONUS ? 'Aplicar bonificação' : defaultConfirmText || 'Importar';
          }

          if (refreshImportedProductsButton) {
            refreshImportedProductsButton.classList.toggle('hidden', normalized === IMPORT_CONTEXT_BONUS);
          }

          if (normalized === IMPORT_CONTEXT_BONUS) {
            const hasPendingBonus = Array.isArray(pendingBonusData?.items) && pendingBonusData.items.length > 0;
            if (hasPendingBonus) {
              updateSummaryFromData(pendingBonusData);
            } else {
              updateSummaryFromData(null);
              if (importXmlNumber) {
                importXmlNumber.textContent = 'XML de bonificação não importado';
              }
              if (importXmlValidationText) {
                importXmlValidationText.textContent = 'Aguardando importação das bonificações';
                applyValidationStyles('info');
              }
            }
          } else if (normalized === IMPORT_CONTEXT_FULL) {
            if (lastNfeData) {
              updateSummaryFromData(lastNfeData);
            } else {
              updateSummaryFromData(null);
            }
            if (refreshImportedProductsButton) {
              refreshImportedProductsButton.classList.remove('hidden');
            }
          }
        };

        const fillMainFormFromNfeData = (data) => {
          if (!data) return;
          if (nfeNumberInput && data.ide?.number) nfeNumberInput.value = data.ide.number;
          if (nfeSeriesInput) nfeSeriesInput.value = data.ide?.serie || '';
          const emission = normalizeDate(data.ide?.emissionDate);
          if (issueDateInput) issueDateInput.value = emission.dateInput || '';
          const entry = normalizeDate(data.ide?.entryDate);
          if (entryDateInput) entryDateInput.value = entry.dateInput || '';
          if (nfeModelSelect && data.ide?.model) setSelectValue(nfeModelSelect, data.ide.model);
          if (nfeTypeSelect) setSelectValue(nfeTypeSelect, mapModelToType(data.ide?.model));
          if (accessKeyInput && data.accessKey) accessKeyInput.value = data.accessKey;
          if (importAccessKeyInput && data.accessKey) importAccessKeyInput.value = data.accessKey;
          if (companySelect) {
            const previousValue = companySelect.value || '';
            const desiredCompanyId = data.selectedCompanyId ? String(data.selectedCompanyId) : '';
            const documentDigits = data.dest?.document ? digitsOnly(data.dest.document) : '';
            let applied = false;

            if (desiredCompanyId) {
              applied = setCompanySelectValue(desiredCompanyId);
              if (!applied) {
                pendingCompanyId = desiredCompanyId;
              } else {
                pendingCompanyId = '';
              }
            }

            if (!applied && documentDigits) {
              const matchedCompany = findCompanyOptionByDocument(documentDigits);
              if (matchedCompany) {
                companySelect.value = matchedCompany.value;
                applied = true;
                pendingCompanyId = '';
              }
            }

            if (applied) {
              pendingCompanyDocumentDigits = '';
              if (lastNfeData) {
                lastNfeData.selectedCompanyId = companySelect.value || '';
              }
              if (previousValue !== companySelect.value) {
                companySelect.dispatchEvent(new Event('change', { bubbles: true }));
              }
            } else {
              pendingCompanyDocumentDigits = documentDigits || '';
            }
          }
        };

        const setNumericInputValue = (input, value, fractionDigits = 2) => {
          if (!input) return;
          const numericValue = parseNumber(value);
          if (Number.isFinite(numericValue)) {
            input.value = numericValue.toFixed(fractionDigits);
          } else {
            input.value = '';
          }
        };

        const fillSupplierFieldsFromNfe = (data) => {
          const supplier = data?.emit;
          if (!supplier) return;
          lastSupplierData = supplier;
          setInputValue(
            supplierCnpjInput,
            supplier.document ? formatDocument(supplier.document) : ''
          );
          setInputValue(supplierIeInput, supplier.stateRegistration || '');
          if (supplierUfSelect && supplier.address?.state) {
            setSelectValue(supplierUfSelect, supplier.address.state);
          }
          setInputValue(supplierEmailInput, supplier.email || '');
          setInputValue(supplierAddressInput, formatAddressLine(supplier.address));
        };

        const applySupplierSelectionFromData = (data) => {
          if (!supplierSelect) return;

          const selection = data?.selection || {};
          const desiredSupplierId = selection.supplierId ? String(selection.supplierId).trim() : '';
          const supplierDocument = digitsOnly(
            data?.supplier?.document || data?.emit?.document || ''
          );

          let applied = false;

          if (desiredSupplierId) {
            applied = setSupplierSelectValue(desiredSupplierId);
            if (applied) {
              pendingSupplierId = '';
            } else {
              pendingSupplierId = desiredSupplierId;
            }
          } else {
            pendingSupplierId = '';
          }

          if (!applied && supplierDocument) {
            const option = findSupplierOptionByDocument(supplierDocument);
            if (option) {
              supplierSelect.value = option.value;
              applied = true;
              pendingSupplierId = '';
              pendingSupplierDocument = '';
            } else {
              pendingSupplierDocument = supplierDocument;
            }
          } else if (!applied) {
            pendingSupplierDocument = supplierDocument || pendingSupplierDocument;
          } else {
            pendingSupplierDocument = '';
          }

          if (supplierSelect && supplierSelect.value) {
            const selectedOption =
              supplierSelect.selectedOptions && supplierSelect.selectedOptions.length
                ? supplierSelect.selectedOptions[0]
                : null;
            if (selectedOption) {
              const optionDocument = digitsOnly(
                selectedOption.dataset?.supplierDocument || supplierDocument || ''
              );
              const registered = optionDocument
                ? supplierRegistry.byDocument.get(optionDocument) || null
                : null;
              if (registered) {
                lastSupplierRecord = registered;
              } else if (optionDocument) {
                lastSupplierRecord = {
                  _id: selectedOption.dataset?.supplierId || null,
                  legalName: selectedOption.dataset?.supplierName || '',
                  cnpj: optionDocument,
                };
              }
            }
          }

          if (!applied) {
            applyPendingSupplierSelection();
          } else {
            supplierSelect.dispatchEvent(new Event('change', { bubbles: true }));
          }
        };

        const fillTotalsFromNfeData = (data) => {
          const totals = data?.totals || {};
          setNumericInputValue(totalsProductsInput, totals.products);
          setNumericInputValue(totalsBonificationInput, totals.bonification);
          setNumericInputValue(totalsIcmsBaseInput, totals.icmsBase);
          setNumericInputValue(totalsIcmsValueInput, totals.icmsValue);
          setNumericInputValue(totalsIcmsStInput, totals.icmsSt);
          setNumericInputValue(totalsFcpStInput, totals.fcpSt);
          setNumericInputValue(totalsDiscountInput, totals.discount);
          setNumericInputValue(totalsOtherInput, totals.other);
          setNumericInputValue(totalsFreightInput, totals.freight);
          setNumericInputValue(totalsIpiInput, totals.ipi);
          setNumericInputValue(totalsInsuranceInput, totals.insurance);
          setInputValue(totalsUnitDiscountInput, '');
          setInputValue(totalsDollarInput, '');
        };

        const fillTransportFromNfeData = (data) => {
          const transport = data?.transport || {};
          const transporter = transport.transporter || {};
          const vehicle = transport.vehicle || {};
          const volume = transport.volume || {};

          setInputValue(
            transportCnpjInput,
            transporter.document ? formatDocument(transporter.document) : ''
          );
          setInputValue(transportIeInput, transporter.stateRegistration || '');
          if (transportUfSelect && transporter.uf) {
            setSelectValue(transportUfSelect, transporter.uf);
          }
          setInputValue(transportNameInput, transporter.name || '');
          setInputValue(transportPlateInput, vehicle.plate || '');
          if (transportPlateUfSelect && vehicle.uf) {
            setSelectValue(transportPlateUfSelect, vehicle.uf);
          }
          setNumericInputValue(weightGrossInput, volume.weightGross, 3);
          setNumericInputValue(weightNetInput, volume.weightNet, 3);
          if (freightModeSelect) {
            const modeValue = transport.mode || data?.ide?.freightMode || '';
            if (modeValue) {
              setSelectValue(freightModeSelect, modeValue);
            }
          }
        };

        const fillDepositSelectionFromNfeData = (data) => {
          if (!depositSelect) return;
          const desiredValue = data?.selectedDepositId ? String(data.selectedDepositId) : '';
          if (!desiredValue) {
            setDepositSelectValue('');
            pendingDepositId = '';
            return;
          }
          const applied = setDepositSelectValue(desiredValue);
          if (!applied) {
            pendingDepositId = desiredValue;
          } else {
            pendingDepositId = '';
          }
        };

        const fillAdditionalInfoFromNfeData = (data) => {
          const additional = data?.additionalInfo || {};
          if (observationInput) {
            observationInput.value = additional.complementary || '';
          }
          if (complementaryInfoInput) {
            complementaryInfoInput.value = additional.fiscal || '';
          }

          const payments = Array.isArray(data?.payments) ? data.payments : [];
          if (paymentFormInput) {
            const descriptions = payments
              .map((payment) => payment?.description || describePaymentMethod(payment?.method))
              .filter(Boolean);
            const uniqueDescriptions = Array.from(new Set(descriptions));
            paymentFormInput.value = uniqueDescriptions.join(', ');
          }

          if (paymentConditionInput) {
            const duplicates = Array.isArray(data?.duplicates) ? data.duplicates : [];
            const emission = normalizeDate(data?.ide?.emissionDate);
            const meaningfulDuplicates = duplicates.filter((dup) => {
              const valueNumeric = toNumeric(dup?.value);
              const dueInfo = normalizeDate(dup?.dueDate);
              const termDays = Number.isFinite(dup?.termDays) ? dup.termDays : null;
              return (
                (Number.isFinite(valueNumeric) && Math.abs(valueNumeric) > 0.000001) ||
                dueInfo.dateInput ||
                Number.isFinite(termDays)
              );
            });
            if (meaningfulDuplicates.length && emission.dateInput) {
              const diffValues = meaningfulDuplicates
                .map((dup) => {
                  if (Number.isFinite(dup?.termDays)) {
                    return dup.termDays;
                  }
                  const dueInfo = normalizeDate(dup?.dueDate);
                  if (dueInfo.dateInput) {
                    const diff = computeInclusiveTermDays(emission.dateInput, dueInfo.dateInput);
                    if (Number.isFinite(diff)) {
                      return diff;
                    }
                  }
                  return null;
                })
                .filter((value) => value !== null)
                .sort((a, b) => a - b);
              if (diffValues.length) {
                paymentConditionInput.value = diffValues.join('/');
              } else {
                paymentConditionInput.value = `${meaningfulDuplicates.length} parcela${
                  meaningfulDuplicates.length > 1 ? 's' : ''
                }`;
              }
            } else {
              const paymentConditionHint = data?.paymentConditionHint || '';
              if (paymentConditionHint) {
                paymentConditionInput.value = paymentConditionHint;
              } else {
                const meaningfulPayments = payments.filter((payment) => {
                  const amount = toNumeric(payment?.amount);
                  const dueInfo = normalizeDate(payment?.dueDate);
                  return (
                    (Number.isFinite(amount) && Math.abs(amount) > 0.000001) ||
                    dueInfo.dateInput ||
                    Number.isFinite(payment?.termDays)
                  );
                });
                if (meaningfulPayments.length) {
                  paymentConditionInput.value = `${meaningfulPayments.length} parcela${
                    meaningfulPayments.length > 1 ? 's' : ''
                  }`;
                } else {
                  paymentConditionInput.value = '';
                }
              }
            }
          }
        };

        const renderDocumentsFromNfe = (references = []) => {
          if (!documentsTableBody) return;
          const existingRows = documentsTableBody.querySelectorAll(
            'tr:not([data-nfe-documents-empty])'
          );
          existingRows.forEach((row) => row.remove());

          const hasReferences = Array.isArray(references) && references.length > 0;
          if (documentsEmptyRow) {
            documentsEmptyRow.classList.toggle('hidden', hasReferences);
          }
          if (!hasReferences) {
            return;
          }

          const fragment = document.createDocumentFragment();
          references.forEach((reference) => {
            const row = document.createElement('tr');

            const typeCell = document.createElement('td');
            typeCell.className = 'px-4 py-3 text-gray-600';
            typeCell.textContent = reference?.type || 'Documento referenciado';
            if (reference?.issuerUf || reference?.document) {
              const extra = document.createElement('p');
              extra.className = 'text-xs text-gray-500';
              const details = [];
              if (reference.issuerUf) details.push(`UF ${reference.issuerUf}`);
              if (reference.document) details.push(formatDocument(reference.document));
              extra.textContent = details.join(' · ');
              if (extra.textContent) {
                typeCell.appendChild(extra);
              }
            }

            const modelCell = document.createElement('td');
            modelCell.className = 'px-4 py-3 text-gray-600';
            modelCell.textContent = reference?.model || '—';

            const numberCell = document.createElement('td');
            numberCell.className = 'px-4 py-3 text-gray-600';
            const numberParts = [];
            if (reference?.number) numberParts.push(reference.number);
            if (reference?.series) numberParts.push(`Série ${reference.series}`);
            if (!numberParts.length) numberParts.push('—');
            numberCell.textContent = numberParts.join(' · ');

            const keyCell = document.createElement('td');
            keyCell.className = 'px-4 py-3 text-gray-600 font-mono text-xs';
            keyCell.textContent = reference?.accessKey || '—';

            const emissionCell = document.createElement('td');
            emissionCell.className = 'px-4 py-3 text-gray-600';
            const emission = normalizeDate(reference?.emissionDate);
            emissionCell.textContent = emission.display || emission.dateInput || '—';

            row.append(typeCell, modelCell, numberCell, keyCell, emissionCell);
            fragment.appendChild(row);
          });

          documentsTableBody.appendChild(fragment);
        };

        const renderDuplicatasFromNfe = (duplicates = [], data = null) => {
          if (!duplicatasTableBody) return;
          const existingRows = duplicatasTableBody.querySelectorAll(
            'tr:not([data-nfe-duplicatas-empty])'
          );
          existingRows.forEach((row) => row.remove());

          const hasDuplicates = Array.isArray(duplicates) && duplicates.length > 0;
          if (duplicatasEmptyRow) {
            duplicatasEmptyRow.classList.toggle('hidden', hasDuplicates);
          }
          if (!hasDuplicates) {
            return;
          }

          const emission = normalizeDate(data?.ide?.emissionDate);
          const entry = normalizeDate(data?.ide?.entryDate);
          const baseDateInput = emission.dateInput || entry.dateInput || '';
          const supplierAccount = resolveSupplierAccountingAccount();
          const bankOptionsSnapshot = getBankAccountOptionsSnapshot();

          const fragment = document.createDocumentFragment();
          duplicates.forEach((dup, index) => {
            const row = document.createElement('tr');
            row.dataset.duplicateIndex = String(index);

            const parcelCell = document.createElement('td');
            parcelCell.className = 'px-4 py-3 text-gray-600';
            parcelCell.textContent = dup?.number || `Parcela ${index + 1}`;

            const daysCell = document.createElement('td');
            daysCell.className = 'px-4 py-3 text-gray-600';
            daysCell.dataset.duplicateTerm = String(index);
            const manualDueInfo = normalizeDate(dup?.manualDueDate);
            const dueInfo = manualDueInfo.dateInput ? manualDueInfo : normalizeDate(dup?.dueDate);
            let diffText = '—';
            if (Number.isFinite(dup?.termDays)) {
              diffText = String(dup.termDays);
            } else if (baseDateInput) {
              const diffBase = dueInfo.dateInput || manualDueInfo.dateInput;
              if (diffBase) {
                const diff = computeInclusiveTermDays(baseDateInput, diffBase);
                if (Number.isFinite(diff)) {
                  diffText = String(diff);
                }
              }
            }
            daysCell.textContent = diffText;

            const dueCell = document.createElement('td');
            dueCell.className = 'px-4 py-3';
            const dueInput = document.createElement('input');
            dueInput.type = 'date';
            dueInput.className =
              'w-full rounded-lg border border-gray-200 px-3 py-2 text-sm text-gray-700 focus:border-primary focus:ring-2 focus:ring-primary/20';
            dueInput.dataset.duplicateDueInput = 'true';
            dueInput.dataset.duplicateIndex = String(index);

            let dueInputInfo = manualDueInfo.dateInput ? manualDueInfo : dueInfo;
            if (!dueInputInfo.dateInput && Number.isFinite(dup?.termDays) && baseDateInput) {
              const fallbackDueInput = addPaymentDaysToDateInput(baseDateInput, dup.termDays);
              dueInputInfo = normalizeDate(fallbackDueInput);
            }
            dueInput.value = dueInputInfo.dateInput || '';
            dueCell.appendChild(dueInput);

            const valueCell = document.createElement('td');
            valueCell.className = 'px-4 py-3 text-right text-gray-800 font-semibold';
            if (!Number.isFinite(toNumeric(dup?.originalValue))) {
              const originalNumeric = toNumeric(dup?.value);
              if (Number.isFinite(originalNumeric)) {
                dup.originalValue = originalNumeric;
              }
            }
            const valueWrapper = document.createElement('div');
            valueWrapper.className = 'flex items-center justify-end gap-2';

            const currencyLabel = document.createElement('span');
            currencyLabel.className = 'text-xs font-semibold uppercase text-gray-500';
            currencyLabel.textContent = 'R$';

            const valueInput = document.createElement('input');
            valueInput.type = 'text';
            valueInput.inputMode = 'decimal';
            valueInput.autocomplete = 'off';
            valueInput.placeholder = '0,00';
            valueInput.className =
              'w-full max-w-[140px] rounded-lg border border-gray-200 px-3 py-2 text-sm text-right font-semibold text-gray-800 focus:border-primary focus:ring-2 focus:ring-primary/20';
            valueInput.dataset.duplicateValueInput = 'true';
            valueInput.dataset.duplicateIndex = String(index);
            const valueNumeric = toNumeric(dup?.value);
            valueInput.value = Number.isFinite(valueNumeric) ? formatMoneyValue(valueNumeric) : '';

            valueWrapper.append(currencyLabel, valueInput);
            valueCell.appendChild(valueWrapper);

            const observationCell = document.createElement('td');
            observationCell.className = 'px-4 py-3 text-gray-600';
            const observationParts = [];
            const methodDescription =
              dup?.paymentDescription ||
              (dup?.paymentMethod ? describePaymentMethod(dup.paymentMethod) : '');
            if (methodDescription) {
              observationParts.push(methodDescription);
            }
            const paymentTypeRaw = dup?.paymentType;
            let paymentTypeLabel = '';
            if (paymentTypeRaw === '0') paymentTypeLabel = 'À vista';
            else if (paymentTypeRaw === '1') paymentTypeLabel = 'À prazo';
            else if (paymentTypeRaw === '2') paymentTypeLabel = 'Outros';
            if (paymentTypeLabel) {
              observationParts.push(paymentTypeLabel);
            }
            observationCell.textContent = observationParts.join(' · ') || '—';

            const duplicateAccount = extractAccountingAccountFromDuplicate(dup);
            const resolvedAccount = duplicateAccount || supplierAccount || null;

            const accountCell = document.createElement('td');
            accountCell.className = 'px-4 py-3 text-gray-600';
            accountCell.textContent = resolvedAccount?.name || '—';

            const accountCodeCell = document.createElement('td');
            accountCodeCell.className = 'px-4 py-3 text-gray-600';
            accountCodeCell.textContent = resolvedAccount?.code || '—';

            const bankCell = document.createElement('td');
            bankCell.className = 'px-4 py-3';
            const bankSelect = document.createElement('select');
            bankSelect.className =
              'w-full rounded-lg border border-gray-200 px-3 py-2 text-sm text-gray-700 focus:border-primary focus:ring-2 focus:ring-primary/20';
            bankSelect.dataset.duplicateBankSelect = 'true';
            bankSelect.dataset.duplicateIndex = String(index);

            let desiredBankAccountId = dup?.bankAccount ? String(dup.bankAccount) : '';
            if (!desiredBankAccountId) {
              const fallbackBankAccount = resolveSelectedBankAccount(data);
              if (fallbackBankAccount && fallbackBankAccount._id) {
                desiredBankAccountId = String(fallbackBankAccount._id);
              }
            }
            populateDuplicateBankAccountSelect(bankSelect, desiredBankAccountId, bankOptionsSnapshot);
            bankCell.appendChild(bankSelect);

            row.append(
              parcelCell,
              daysCell,
              dueCell,
              valueCell,
              observationCell,
              accountCell,
              accountCodeCell,
              bankCell
            );
            fragment.appendChild(row);
          });

          duplicatasTableBody.appendChild(fragment);
        };

        const resolveDuplicataManualTotalAmount = () => {
          const candidates = [];

          if (lastNfeData?.totals) {
            candidates.push(toNumeric(lastNfeData.totals.totalValue));
            candidates.push(toNumeric(lastNfeData.totals.products));
          }

          if (Array.isArray(lastNfeData?.duplicates) && lastNfeData.duplicates.length) {
            const duplicatesSum = lastNfeData.duplicates.reduce((sum, duplicate) => {
              const value = toNumeric(duplicate?.value);
              return Number.isFinite(value) ? sum + value : sum;
            }, 0);
            if (Number.isFinite(duplicatesSum) && duplicatesSum > 0) {
              candidates.push(duplicatesSum);
            }
          }

          if (totalsProductsInput && totalsProductsInput.value) {
            const productsTotal = toNumeric(totalsProductsInput.value);
            if (Number.isFinite(productsTotal) && productsTotal > 0) {
              candidates.push(productsTotal);
            }
          }

          for (const candidate of candidates) {
            if (Number.isFinite(candidate) && Math.abs(candidate) > 0) {
              return Math.abs(candidate);
            }
          }

          return null;
        };

        const resolveDuplicataBaseDate = () => {
          const emissionFromField = normalizeDate(duplicataEmissionInput?.value || '');
          if (emissionFromField.dateInput) {
            return emissionFromField.dateInput;
          }

          const emissionFromData = normalizeDate(lastNfeData?.ide?.emissionDate || '');
          if (emissionFromData.dateInput) {
            return emissionFromData.dateInput;
          }

          const entryFromData = normalizeDate(lastNfeData?.ide?.entryDate || '');
          if (entryFromData.dateInput) {
            return entryFromData.dateInput;
          }

          const issueFromInput = normalizeDate(issueDateInput?.value || '');
          if (issueFromInput.dateInput) {
            return issueFromInput.dateInput;
          }

          const entryFromInput = normalizeDate(entryDateInput?.value || '');
          if (entryFromInput.dateInput) {
            return entryFromInput.dateInput;
          }

          return '';
        };

        const generateDuplicatasPreviewFromInputs = () => {
          if (!duplicataCountInput) {
            return;
          }

          if (!lastNfeData) {
            notify('Importe uma NF-e antes de gerar as duplicatas.', 'warning');
            return;
          }

          const parcelsRaw = duplicataCountInput.value ? Number.parseInt(duplicataCountInput.value, 10) : NaN;
          if (!Number.isFinite(parcelsRaw) || parcelsRaw <= 0) {
            notify('Informe uma quantidade de parcelas válida para gerar as duplicatas.', 'warning');
            duplicataCountInput.focus();
            return;
          }

          const totalAmount = resolveDuplicataManualTotalAmount();
          if (!Number.isFinite(totalAmount) || totalAmount <= 0) {
            notify('Não foi possível determinar o valor total da nota para gerar as duplicatas.', 'warning');
            return;
          }

          const typeValue = duplicataDaysTypeSelect ? duplicataDaysTypeSelect.value || 'dias' : 'dias';
          const baseDateInput = resolveDuplicataBaseDate();

          const firstDueInfo = normalizeDate(duplicataFirstDueInput?.value || '');
          const initialDaysRaw = duplicataInitialDaysInput?.value
            ? Number.parseInt(duplicataInitialDaysInput.value, 10)
            : NaN;
          const intervalDaysRaw = duplicataDaysInput?.value
            ? Number.parseInt(duplicataDaysInput.value, 10)
            : NaN;

          if (Number.isFinite(initialDaysRaw) && initialDaysRaw < 0) {
            notify('Os dias para o primeiro vencimento devem ser maiores ou iguais a zero.', 'warning');
            duplicataInitialDaysInput?.focus();
            return;
          }

          if (Number.isFinite(intervalDaysRaw) && intervalDaysRaw < 0) {
            notify('Informe um intervalo de dias maior ou igual a zero para as duplicatas.', 'warning');
            duplicataDaysInput?.focus();
            return;
          }

          const hasInitialDays = Number.isFinite(initialDaysRaw);
          const hasIntervalDays = Number.isFinite(intervalDaysRaw);

          let firstDueDate = firstDueInfo.dateInput || '';
          if (!firstDueDate && baseDateInput && hasInitialDays) {
            firstDueDate = addPaymentDaysToDateInput(baseDateInput, initialDaysRaw) || '';
          }
          if (!firstDueDate && baseDateInput && hasIntervalDays) {
            firstDueDate = addPaymentDaysToDateInput(baseDateInput, intervalDaysRaw) || '';
          }

          if (!firstDueDate) {
            notify('Informe um vencimento inicial ou os dias necessários para calcular as duplicatas.', 'warning');
            duplicataFirstDueInput?.focus();
            return;
          }

          let resolvedStepDays = Number.isFinite(intervalDaysRaw) ? intervalDaysRaw : null;
          if (!Number.isFinite(resolvedStepDays)) {
            if (Number.isFinite(initialDaysRaw)) {
              resolvedStepDays = initialDaysRaw;
            } else if (baseDateInput) {
              const diff = computeInclusiveTermDays(baseDateInput, firstDueDate);
              if (Number.isFinite(diff)) {
                resolvedStepDays = diff;
              }
            }
          }

          if (parcelsRaw > 1 && (!Number.isFinite(resolvedStepDays) || resolvedStepDays < 0)) {
            resolvedStepDays = 30;
          }

          const firstTermDiff =
            baseDateInput && firstDueDate ? computeInclusiveTermDays(baseDateInput, firstDueDate) : null;
          const firstTermCandidate = Number.isFinite(firstTermDiff) ? firstTermDiff : null;
          let currentTermDays = Number.isFinite(firstTermCandidate)
            ? firstTermCandidate
            : Number.isFinite(initialDaysRaw)
            ? initialDaysRaw
            : null;

          const totalCents = Math.round(totalAmount * 100);
          const baseShare = Math.floor(totalCents / parcelsRaw);
          let remainder = totalCents - baseShare * parcelsRaw;

          const normalizedBankAccount = bankAccountSelect && bankAccountSelect.value ? String(bankAccountSelect.value) : '';
          lastNfeData.selectedBankAccountId = normalizedBankAccount || pendingBankAccountId || '';

          const duplicates = [];
          let currentDueDate = firstDueDate;
          const paymentTypeValue = parcelsRaw > 1 ? '1' : '0';
          const supplierAccountDetails = resolveSupplierAccountingAccount();

          for (let index = 0; index < parcelsRaw; index += 1) {
            const valueCents = baseShare + (remainder > 0 ? 1 : 0);
            if (remainder > 0) {
              remainder -= 1;
            }

            const termDaysValue = Number.isFinite(currentTermDays) ? currentTermDays : null;
            const dueDateValue = currentDueDate || '';

            const duplicate = {
              index,
              number: `Parcela ${index + 1}`,
              dueDate: dueDateValue,
              originalDueDate: dueDateValue,
              manualDueDate: dueDateValue,
              value: valueCents / 100,
              paymentMethod: '',
              paymentDescription: 'Gerado manualmente',
              paymentType: paymentTypeValue,
              termDays: termDaysValue,
              bankAccount: normalizedBankAccount ? normalizedBankAccount : null,
              bankAccountIsManual: false,
            };
            applyAccountingAccountToDuplicate(duplicate, supplierAccountDetails);
            duplicates.push(duplicate);

            if (index < parcelsRaw - 1) {
              const step = Number.isFinite(intervalDaysRaw) ? intervalDaysRaw : resolvedStepDays;
              const increment = Number.isFinite(step) ? step : 0;

              if (currentDueDate && Number.isFinite(increment)) {
                const nextDue = addDaysToDateInput(currentDueDate, increment);
                if (nextDue) {
                  currentDueDate = nextDue;
                }
              } else if (!currentDueDate && baseDateInput && Number.isFinite(increment)) {
                const baseOffset = Number.isFinite(currentTermDays) ? currentTermDays + increment : increment;
                const nextDue = Number.isFinite(baseOffset)
                  ? addPaymentDaysToDateInput(baseDateInput, baseOffset)
                  : '';
                if (nextDue) {
                  currentDueDate = nextDue;
                }
              }

              if (baseDateInput && currentDueDate) {
                const diff = computeInclusiveTermDays(baseDateInput, currentDueDate);
                if (Number.isFinite(diff)) {
                  currentTermDays = diff;
                } else if (Number.isFinite(currentTermDays) && Number.isFinite(increment)) {
                  currentTermDays += increment;
                } else if (Number.isFinite(increment)) {
                  currentTermDays = increment;
                } else {
                  currentTermDays = null;
                }
              } else if (Number.isFinite(currentTermDays) && Number.isFinite(increment)) {
                currentTermDays += increment;
              } else if (Number.isFinite(increment)) {
                currentTermDays = Number.isFinite(currentTermDays) ? currentTermDays + increment : increment;
              } else {
                currentTermDays = null;
              }
            }
          }

          lastNfeData.duplicates = duplicates;

          if (duplicataFirstDueInput) {
            duplicataFirstDueInput.value = duplicates[0]?.dueDate || '';
          }

          if (!hasInitialDays && duplicataInitialDaysInput) {
            const firstTerm = Number.isFinite(duplicates[0]?.termDays) ? duplicates[0].termDays : null;
            duplicataInitialDaysInput.value = Number.isFinite(firstTerm) ? String(firstTerm) : duplicataInitialDaysInput.value;
          }

          if (!hasIntervalDays && duplicataDaysInput && parcelsRaw > 1 && Number.isFinite(resolvedStepDays)) {
            duplicataDaysInput.value = String(resolvedStepDays);
          }

          if (duplicataDaysTypeSelect) {
            setSelectValue(duplicataDaysTypeSelect, typeValue);
          }

          renderDuplicatasFromNfe(duplicates, lastNfeData);

          if (paymentConditionInput) {
            const baseForDiff = baseDateInput || duplicates[0]?.dueDate || '';
            const normalizedBase = normalizeDate(baseForDiff).dateInput;
            if (normalizedBase) {
              const diffValues = duplicates
                .map((duplicate) => {
                  const dueInfo = normalizeDate(duplicate?.dueDate || '');
                  if (!dueInfo.dateInput) return null;
                  const diff = computeInclusiveTermDays(normalizedBase, dueInfo.dateInput);
                  return Number.isFinite(diff) ? diff : null;
                })
                .filter((value) => value !== null);
              if (diffValues.length) {
                paymentConditionInput.value = diffValues.join('/');
              } else {
                paymentConditionInput.value = `${parcelsRaw} parcela${parcelsRaw > 1 ? 's' : ''}`;
              }
            } else {
              paymentConditionInput.value = `${parcelsRaw} parcela${parcelsRaw > 1 ? 's' : ''}`;
            }
          }

          notify('Pré-visualização das duplicatas atualizada.', 'success');
        };

        const refreshAccountingAccountBindings = () => {
          const account = resolveSupplierAccountingAccount();
          if (accountingAccountInput) {
            accountingAccountInput.value = formatAccountingAccountValue(account);
          }
          return account;
        };

        const syncAccountingAccountWithDuplicates = () => {
          const account = refreshAccountingAccountBindings();
          if (lastNfeData && Array.isArray(lastNfeData.duplicates)) {
            lastNfeData.duplicates.forEach((duplicate) => {
              applyAccountingAccountToDuplicate(duplicate, account);
            });
            renderDuplicatasFromNfe(lastNfeData.duplicates, lastNfeData);
          }
          return account;
        };

        const resolveMainProductConversionFactor = (item) => {
          const conversionFromItem = toNumeric(item?.conversion);
          if (Number.isFinite(conversionFromItem)) {
            return conversionFromItem;
          }
          const multiplierValue = toNumeric(item?.conversionMultiplier);
          const dividerValue = toNumeric(item?.conversionDivider);
          if (Number.isFinite(multiplierValue) && Number.isFinite(dividerValue) && dividerValue !== 0) {
            return multiplierValue / dividerValue;
          }
          if (Number.isFinite(multiplierValue)) {
            return multiplierValue;
          }
          if (Number.isFinite(dividerValue) && dividerValue !== 0) {
            return 1 / dividerValue;
          }
          return null;
        };

        const resolveMainProductEntryStockQuantity = (item, conversionFactor) => {
          if (Number.isFinite(item?.entryStockQuantity)) {
            return item.entryStockQuantity;
          }
          const quantityValue = toNumeric(item?.quantity);
          const qTribValue = toNumeric(item?.qTrib);
          if (Number.isFinite(quantityValue) && Number.isFinite(conversionFactor)) {
            return quantityValue * conversionFactor;
          }
          if (Number.isFinite(qTribValue)) {
            return qTribValue;
          }
          if (Number.isFinite(quantityValue)) {
            return quantityValue;
          }
          return null;
        };

        const buildMainProductRowData = (item, index) => {
          ensureItemCostWithTaxes(item);

          const matchedCode = item?.matchedProduct
            ? normalizeInternalCode(getProductCodeFromRecord(item.matchedProduct))
            : '';
          const supplierCode = item?.supplierCode || '';
          const systemProductName = item?.matchedProduct
            ? getProductNameFromRecord(item.matchedProduct)
            : '';
          const supplierDescription = typeof item?.description === 'string' ? item.description : '';
          const descriptionDisplay = systemProductName || supplierDescription || 'Item sem descrição';
          const systemBarcodeDigits = item?.matchedProduct
            ? getProductBarcodeFromRecord(item.matchedProduct)
            : '';
          const systemBarcodeDisplay = formatGtinDisplay(systemBarcodeDigits);
          const nfBarcodeRaw =
            (item?.barcodeDisplay && item.barcodeDisplay !== 'SEM GTIN' ? item.barcodeDisplay : '') ||
            item?.ean ||
            item?.eanTrib ||
            '';
          const nfBarcodeDisplay = formatGtinDisplay(nfBarcodeRaw);
          const effectiveBarcodeDisplay =
            systemBarcodeDisplay !== 'SEM GTIN' ? systemBarcodeDisplay : nfBarcodeDisplay;
          const conversionFactor = resolveMainProductConversionFactor(item);
          const entryStockValue = resolveMainProductEntryStockQuantity(item, conversionFactor);

          if (Number.isFinite(entryStockValue) && !Number.isFinite(item.entryStockQuantity)) {
            item.entryStockQuantity = entryStockValue;
            ensureItemCostWithTaxes(item);
          }

          const unitCostWithTaxesValue = toNumeric(item?.unitCostWithTaxes);
          const quantityDisplay = formatQuantity(item?.quantity);
          const conversionDisplay = Number.isFinite(conversionFactor)
            ? formatQuantity(conversionFactor)
            : '—';
          const entryStockDisplay = Number.isFinite(entryStockValue)
            ? formatQuantity(entryStockValue)
            : '—';
          const unitDisplay = item?.unit || item?.unitTrib || '—';
          const costDisplay = Number.isFinite(unitCostWithTaxesValue)
            ? formatMoneyValue(unitCostWithTaxesValue)
            : '—';
          const unitPriceDisplay = formatMoneyValue(item?.unitPrice);
          const discountDisplay = formatPercentValue(item?.discountPercent);
          const quantityValue = toNumeric(item?.quantity);
          const conversionSortValue = Number.isFinite(conversionFactor)
            ? conversionFactor
            : toNumeric(item?.conversion);
          const unitPriceValue = toNumeric(item?.unitPrice);
          const discountValue = toNumeric(item?.discountPercent);
          const codeSortValue = [matchedCode, supplierCode].filter(Boolean).join(' ').trim();
          const descriptionSortValue = descriptionDisplay;
          const unitSortValue = [item?.unit, item?.unitTrib].filter(Boolean).join(' ').trim();

          const descriptionFilterParts = [
            descriptionDisplay,
            supplierDescription && supplierDescription !== descriptionDisplay ? supplierDescription : '',
            item?.unit ? `UN ${item.unit}` : '',
            item?.unitTrib && item.unitTrib !== item.unit ? `TRIB ${item.unitTrib}` : '',
            item?.ncm ? `NCM ${item.ncm}` : '',
            item?.cest ? `CEST ${item.cest}` : '',
            item?.cfop ? `CFOP ${item.cfop}` : '',
            item?.cst ? `CST ${item.cst}` : '',
            formatPercentValue(item?.icmsRate),
            formatPercentValue(item?.icmsStRate),
            formatPercentValue(item?.ipiRate),
            formatPercentValue(item?.pisRate),
            formatPercentValue(item?.cofinsRate),
            systemBarcodeDisplay !== 'SEM GTIN' ? systemBarcodeDisplay : '',
            nfBarcodeDisplay !== 'SEM GTIN' ? nfBarcodeDisplay : '',
            systemBarcodeDigits,
            normalizeBarcodeForComparison(nfBarcodeRaw),
          ].filter(Boolean);

          return {
            item,
            index,
            displays: {
              code: matchedCode || supplierCode || '—',
              description: descriptionDisplay,
              quantity: quantityDisplay,
              conversion: conversionDisplay,
              unit: unitDisplay,
              entryStock: entryStockDisplay,
              cost: costDisplay,
              unitPrice: unitPriceDisplay,
              discount: discountDisplay,
              barcode: effectiveBarcodeDisplay || 'SEM GTIN',
            },
            filterTexts: {
              item: String(index + 1),
              code: [matchedCode, supplierCode].filter(Boolean).join(' '),
              description: descriptionFilterParts.join(' '),
              quantity: buildNumericFilterValue(quantityDisplay, item?.quantity),
              conversion: buildNumericFilterValue(
                conversionDisplay !== '—' ? conversionDisplay : '',
                conversionFactor
              ),
              unit: [item?.unit, item?.unitTrib].filter(Boolean).join(' '),
              entryStock: buildNumericFilterValue(
                entryStockDisplay !== '—' ? entryStockDisplay : '',
                entryStockValue
              ),
              cost: buildNumericFilterValue(costDisplay, unitCostWithTaxesValue),
              unitPrice: buildNumericFilterValue(unitPriceDisplay, item?.unitPrice),
              discount: buildNumericFilterValue(discountDisplay, item?.discountPercent),
            },
            sortValues: {
              item: index,
              code: codeSortValue,
              description: descriptionSortValue,
              quantity: Number.isFinite(quantityValue) ? quantityValue : null,
              conversion: Number.isFinite(conversionSortValue) ? conversionSortValue : null,
              unit: unitSortValue,
              entryStock: Number.isFinite(entryStockValue) ? entryStockValue : null,
              cost: Number.isFinite(unitCostWithTaxesValue) ? unitCostWithTaxesValue : null,
              unitPrice: Number.isFinite(unitPriceValue) ? unitPriceValue : null,
              discount: Number.isFinite(discountValue) ? discountValue : null,
            },
            supplierDescription,
          };
        };

        const applyMainProductFiltersToRows = (entries) => {
          const activeFilters = Object.entries(mainProductTableState.filters || {}).filter(
            ([, value]) => Boolean(normalizeFilterText(value))
          );
          if (!activeFilters.length) {
            return entries;
          }
          return entries.filter((entry) =>
            activeFilters.every(([key, value]) => {
              const normalizedFilter = normalizeFilterText(value);
              if (!normalizedFilter) return true;
              const columnValue = entry.filterTexts?.[key] ?? '';
              const normalizedColumn = normalizeFilterText(columnValue);
              return normalizedColumn.includes(normalizedFilter);
            })
          );
        };

        const applyMainProductSortToRows = (entries) => {
          if (!Array.isArray(entries) || !entries.length) {
            return [];
          }
          const { sort } = mainProductTableState;
          const sortKey = sort?.key || '';
          if (!sortKey) {
            return entries.slice();
          }
          const sortDirection = sort?.direction === 'desc' ? 'desc' : 'asc';
          const directionMultiplier = sortDirection === 'desc' ? -1 : 1;
          return entries
            .slice()
            .sort((a, b) => {
              const sortValuesA = a?.sortValues || {};
              const sortValuesB = b?.sortValues || {};
              const valueA = sortValuesA[sortKey];
              const valueB = sortValuesB[sortKey];
              const numericA = Number.isFinite(valueA) ? valueA : parseNumber(valueA);
              const numericB = Number.isFinite(valueB) ? valueB : parseNumber(valueB);
              if (Number.isFinite(numericA) || Number.isFinite(numericB)) {
                const safeA = Number.isFinite(numericA) ? numericA : Number.NEGATIVE_INFINITY;
                const safeB = Number.isFinite(numericB) ? numericB : Number.NEGATIVE_INFINITY;
                if (safeA === safeB) {
                  const indexA = Number.isFinite(a?.index) ? a.index : 0;
                  const indexB = Number.isFinite(b?.index) ? b.index : 0;
                  return indexA - indexB;
                }
                return safeA > safeB ? directionMultiplier : -directionMultiplier;
              }
              const textA = String(valueA ?? '').trim();
              const textB = String(valueB ?? '').trim();
              const comparison = textA.localeCompare(textB, 'pt-BR', {
                sensitivity: 'base',
                numeric: true,
              });
              if (comparison === 0) {
                const indexA = Number.isFinite(a?.index) ? a.index : 0;
                const indexB = Number.isFinite(b?.index) ? b.index : 0;
                return indexA - indexB;
              }
              return comparison * directionMultiplier;
            });
        };

        const updateMainProductSortButtons = () => {
          const { sort } = mainProductTableState;
          const activeKey = sort?.key || '';
          const activeDirection = sort?.direction === 'desc' ? 'desc' : 'asc';

          mainProductSortHeaders.forEach((header, key) => {
            if (!header) return;
            if (key === activeKey && activeKey) {
              header.setAttribute('aria-sort', activeDirection === 'desc' ? 'descending' : 'ascending');
            } else {
              header.removeAttribute('aria-sort');
            }
          });

          mainProductSortButtons.forEach((meta, button) => {
            if (!button) return;
            const isActive = activeKey && meta.key === activeKey && meta.direction === activeDirection;
            button.classList.toggle('text-primary', isActive);
            button.classList.toggle('border-primary/60', isActive);
            button.classList.toggle('bg-primary/10', isActive);
            button.setAttribute('aria-pressed', isActive ? 'true' : 'false');
          });
        };

        const updateMainProductsTableDisplay = () => {
          if (!mainProductsTableBody) return;

          const items = Array.isArray(mainProductTableState.items)
            ? mainProductTableState.items
            : [];

          const hasItems = items.length > 0;

          updateMainProductSortButtons();

          if (mainProductsEmptyRow) {
            mainProductsEmptyRow.classList.toggle('hidden', hasItems);
          }
          if (mainProductsFilteredEmptyRow) {
            mainProductsFilteredEmptyRow.classList.add('hidden');
          }

          const existingRows = mainProductsTableBody.querySelectorAll('[data-nfe-products-row]');
          existingRows.forEach((row) => row.remove());

          if (!hasItems) {
            return;
          }

          const derivedEntries = items.map((item, index) => buildMainProductRowData(item, index));
          const filteredEntries = applyMainProductFiltersToRows(derivedEntries);
          const itemsToRender = applyMainProductSortToRows(filteredEntries);

          if (!itemsToRender.length) {
            if (mainProductsFilteredEmptyRow) {
              mainProductsFilteredEmptyRow.classList.remove('hidden');
            }
            return;
          }

          const fragment = document.createDocumentFragment();

          itemsToRender.forEach((entry) => {
            const { item, index, displays } = entry;
            const row = document.createElement('tr');
            row.dataset.nfeProductsRow = 'true';

            const indexCell = document.createElement('td');
            indexCell.className = 'px-4 py-3 text-gray-600';
            indexCell.textContent = String(index + 1);

            const codeCell = document.createElement('td');
            codeCell.className = 'px-4 py-3 text-gray-600';
            const codeWrapper = document.createElement('div');
            codeWrapper.className = 'inline-flex items-center gap-1';
            const codeSpan = document.createElement('span');
            codeSpan.textContent = displays.code;
            codeWrapper.appendChild(codeSpan);
            const mainIndicator = buildBonificationIndicator(item);
            if (mainIndicator) {
              codeWrapper.appendChild(mainIndicator);
            }
            codeCell.appendChild(codeWrapper);

            const descriptionCell = document.createElement('td');
            descriptionCell.className = 'px-4 py-3 text-gray-700';
            descriptionCell.textContent = displays.description || 'Item sem descrição';

            const detailLine1 = document.createElement('p');
            detailLine1.className = 'text-xs text-gray-500';
            const line1Parts = [];
            if (item?.unit) line1Parts.push(`UN: ${item.unit}`);
            if (item?.unitTrib && item.unitTrib !== item.unit)
              line1Parts.push(`Trib: ${item.unitTrib}`);
            if (item?.ncm) line1Parts.push(`NCM ${item.ncm}`);
            if (item?.cest) line1Parts.push(`CEST ${item.cest}`);
            detailLine1.textContent = line1Parts.join(' · ') || '—';

            const detailLine2 = document.createElement('p');
            detailLine2.className = 'text-xs text-gray-500';
            const line2Parts = [];
            if (item?.cfop) line2Parts.push(`CFOP ${item.cfop}`);
            if (item?.cst) line2Parts.push(`CST ${item.cst}`);
            line2Parts.push(`ICMS ${formatPercentValue(item?.icmsRate)}`);
            line2Parts.push(`ICMS ST ${formatPercentValue(item?.icmsStRate)}`);
            detailLine2.textContent = line2Parts.join(' · ');

            const detailLine3 = document.createElement('p');
            detailLine3.className = 'text-xs text-gray-500';
            detailLine3.textContent = `IPI ${formatPercentValue(item?.ipiRate)} · PIS ${formatPercentValue(
              item?.pisRate
            )} · COFINS ${formatPercentValue(item?.cofinsRate)}`;

            const detailLine4 = document.createElement('p');
            detailLine4.className = 'text-xs text-gray-500';
            detailLine4.textContent = `GTIN: ${displays.barcode || 'SEM GTIN'}`;

            descriptionCell.append(detailLine1, detailLine2, detailLine3, detailLine4);

            const supplierDescriptionText = entry.supplierDescription || '';
            if (supplierDescriptionText && supplierDescriptionText !== displays.description) {
              const supplierDetailLine = document.createElement('p');
              supplierDetailLine.className = 'text-xs text-gray-400 italic';
              supplierDetailLine.textContent = `Descrição NF: ${supplierDescriptionText}`;
              descriptionCell.appendChild(supplierDetailLine);
            }

            const quantityCell = document.createElement('td');
            quantityCell.className = 'px-4 py-3 text-right text-gray-600';
            quantityCell.textContent = displays.quantity;

            const conversionCell = document.createElement('td');
            conversionCell.className = 'px-4 py-3 text-right text-gray-600';
            conversionCell.textContent = displays.conversion;

            const unitCell = document.createElement('td');
            unitCell.className = 'px-4 py-3 text-left text-gray-600';
            unitCell.textContent = displays.unit;

            const entryStockCell = document.createElement('td');
            entryStockCell.className = 'px-4 py-3 text-right text-gray-600';
            entryStockCell.textContent = displays.entryStock;

            const calculatedCostCell = document.createElement('td');
            calculatedCostCell.className = 'px-4 py-3 text-right text-gray-600';
            calculatedCostCell.textContent = displays.cost;

            const unitPriceCell = document.createElement('td');
            unitPriceCell.className = 'px-4 py-3 text-right text-gray-600';
            unitPriceCell.textContent = displays.unitPrice;

            const discountCell = document.createElement('td');
            discountCell.className = 'px-4 py-3 text-right text-gray-600';
            discountCell.textContent = displays.discount;

            row.append(
              indexCell,
              codeCell,
              descriptionCell,
              quantityCell,
              conversionCell,
              unitCell,
              entryStockCell,
              calculatedCostCell,
              unitPriceCell,
              discountCell
            );
            fragment.appendChild(row);
          });

          mainProductsTableBody.appendChild(fragment);
          updatePriceButtonAvailability(currentDraftStatus);
        };

        const setMainProductTableFilter = (key, value) => {
          if (!key) return;
          const nextValue = value || '';
          if (mainProductTableState.filters[key] === nextValue) {
            return;
          }
          mainProductTableState.filters[key] = nextValue;
          updateMainProductsTableDisplay();
        };

        const setMainProductSort = (key, direction) => {
          if (!key) return;
          const nextDirection = direction === 'desc' ? 'desc' : 'asc';
          const { sort } = mainProductTableState;
          const currentKey = sort?.key || '';
          const currentDirection = sort?.direction || 'asc';
          if (currentKey === key && currentDirection === nextDirection) {
            mainProductTableState.sort = { key: '', direction: 'asc' };
          } else {
            mainProductTableState.sort = { key, direction: nextDirection };
          }
          updateMainProductsTableDisplay();
        };

        const renderMainProductsFromNfe = (items = []) => {
          mainProductTableState.items = Array.isArray(items) ? items : [];
          updateMainProductsTableDisplay();
          updatePriceButtonAvailability(currentDraftStatus);

          const bonificationTotal = computeBonificationTotal(mainProductTableState.items);
          setNumericInputValue(totalsBonificationInput, bonificationTotal);

          if (lastNfeData && typeof lastNfeData === 'object') {
            if (!lastNfeData.totals || typeof lastNfeData.totals !== 'object') {
              lastNfeData.totals = {};
            }
            lastNfeData.totals.bonification = Number.isFinite(bonificationTotal)
              ? bonificationTotal
              : null;
          }
        };

        const CODE_STATUS_LABELS = {
          draft: 'Cadastrada',
          approved: 'Aprovada',
        };

        const CODE_STATUS_CLASSES = {
          cadastrada: ['border-amber-200', 'bg-amber-50', 'text-amber-700'],
          aprovada: ['border-emerald-200', 'bg-emerald-50', 'text-emerald-700'],
        };

        const ALL_CODE_STATUS_CLASSES = Array.from(
          new Set(Object.values(CODE_STATUS_CLASSES).flat())
        );

        const mapDraftStatusLabel = (status) => {
          if (status === null || typeof status === 'undefined') {
            return CODE_STATUS_LABELS.draft;
          }
          const normalized = String(status).trim().toLowerCase();
          if (!normalized) return CODE_STATUS_LABELS.draft;
          if (normalized === 'approved' || normalized === 'aprovado' || normalized === 'aprovada') {
            return CODE_STATUS_LABELS.approved;
          }
          if (normalized === 'draft' || normalized === 'rascunho' || normalized === 'cadastrada') {
            return CODE_STATUS_LABELS.draft;
          }
          return normalized.charAt(0).toUpperCase() + normalized.slice(1);
        };

        const mapDraftStatusClasses = (statusLabel) => {
          const normalized = String(statusLabel || '').trim().toLowerCase();
          return CODE_STATUS_CLASSES[normalized] || ['border-gray-200', 'bg-gray-100', 'text-gray-600'];
        };

        updateStatusBadgeDisplay = (status) => {
          if (!statusBadge) return;
          const label = mapDraftStatusLabel(status);
          statusBadge.textContent = label || '—';
          statusBadge.classList.remove(...ALL_CODE_STATUS_CLASSES);
          const classes = mapDraftStatusClasses(label);
          classes.forEach((className) => statusBadge.classList.add(className));
          updatePriceButtonAvailability(status);
        };

        updateDeleteButtonState = (status) => {
          if (!deleteEntryButton) return;
          const normalized = determineDraftStatusKey(status ?? currentDraftStatus);
          const hasDraft = Boolean(currentDraftId);
          const shouldShow = hasDraft && normalized === 'approved';
          deleteEntryButton.classList.toggle('hidden', !shouldShow);

          if (!shouldShow) {
            deleteEntryButton.disabled = true;
            deleteEntryButton.classList.remove('cursor-wait');
            deleteEntryButton.classList.remove('opacity-60');
            if (deleteEntryIcon) {
              deleteEntryIcon.className = defaultDeleteIconClass;
            }
            if (deleteEntryText && defaultDeleteText) {
              deleteEntryText.textContent = defaultDeleteText;
            }
            return;
          }

          setDeleteButtonState(isDeletingDraft);
        };

        updateStatusBadgeDisplay(currentDraftStatus);
        updateDeleteButtonState(currentDraftStatus);
        setFormLockState(false);

        const parseDateForSort = (value) => {
          if (!value) return null;
          const info = normalizeDate(value);
          if (info.dateInput) {
            const timestamp = Date.parse(`${info.dateInput}T00:00:00`);
            return Number.isNaN(timestamp) ? null : timestamp;
          }
          const parsed = Date.parse(value);
          return Number.isNaN(parsed) ? null : parsed;
        };

        const buildCodeLookupRowData = (item, index) => {
          const numericCode = Number.isFinite(item?.code) ? Number(item.code) : toNumeric(item?.code);
          const headerCode = item?.headerCode || item?.header?.code || '';
          const displayCode = headerCode || formatDraftCode(numericCode ?? item?.code ?? '');
          const accessKey = item?.accessKey || item?.xml?.accessKey || '';
          const nfNumber = item?.number || item?.header?.number || '';
          const serie = item?.serie || item?.header?.serie || '';
          const nfDisplay = [nfNumber, serie ? `Série ${serie}` : ''].filter(Boolean).join(' · ');
          const supplierName = item?.supplierName || '';
          const supplierDocument = item?.supplierDocument || '';
          const totalNumeric = Number.isFinite(item?.totalValue) ? Number(item.totalValue) : toNumeric(item?.totalValue);
          const totalDisplay = Number.isFinite(totalNumeric) ? formatCurrencyBRL(totalNumeric) : 'R$ 0,00';
          const issueSource = item?.issueDate || item?.header?.issueDate || '';
          const entrySource = item?.entryDate || item?.header?.entryDate || '';
          const issueInfo = normalizeDate(issueSource);
          const entryInfo = normalizeDate(entrySource);
          const statusLabel = mapDraftStatusLabel(item?.status);
          const issueTimestamp = parseDateForSort(issueSource);
          const entryTimestamp = parseDateForSort(entrySource);
          return {
            item,
            index,
            displays: {
              code: displayCode || '—',
              accessKey: accessKey || '—',
              nf: nfDisplay || nfNumber || '—',
              supplier: supplierName || '—',
              supplierDocument,
              total: totalDisplay,
              issueDate: issueInfo.display || issueInfo.dateInput || '—',
              entryDate: entryInfo.display || entryInfo.dateInput || '—',
              status: statusLabel,
            },
            sortValues: {
              code: Number.isFinite(numericCode) ? numericCode : parseNumber(displayCode),
              accessKey,
              number: nfNumber,
              supplier: supplierName,
              total: Number.isFinite(totalNumeric) ? totalNumeric : 0,
              issueDate: Number.isFinite(issueTimestamp) ? issueTimestamp : null,
              entryDate: Number.isFinite(entryTimestamp) ? entryTimestamp : null,
              status: statusLabel,
            },
            filterValues: {
              code: displayCode,
              accessKey,
              number: nfDisplay || nfNumber,
              supplier: supplierName,
              total: totalDisplay,
              issueDate: issueInfo.display || issueInfo.dateInput || '',
              entryDate: entryInfo.display || entryInfo.dateInput || '',
              status: statusLabel,
            },
          };
        };

        const applyCodeLookupFiltersToRows = (entries) => {
          const filters = Object.entries(codeLookupTableState.filters || {}).filter(([, raw]) =>
            normalizeFilterText(raw).length > 0
          );
          if (!filters.length) {
            return entries.slice();
          }
          return entries.filter((entry) =>
            filters.every(([key, raw]) => {
              const normalizedFilter = normalizeFilterText(raw);
              if (!normalizedFilter) return true;
              const columnValue = entry.filterValues?.[key];
              const normalizedColumn = normalizeFilterText(columnValue);
              return normalizedColumn.includes(normalizedFilter);
            })
          );
        };

        const applyCodeLookupSortToRows = (entries) => {
          if (!Array.isArray(entries) || !entries.length) {
            return [];
          }
          const { sort } = codeLookupTableState;
          const sortKey = sort?.key || '';
          if (!sortKey) {
            return entries.slice();
          }
          const sortDirection = sort?.direction === 'desc' ? 'desc' : 'asc';
          const directionMultiplier = sortDirection === 'desc' ? -1 : 1;
          return entries
            .slice()
            .sort((a, b) => {
              const sortValuesA = a?.sortValues || {};
              const sortValuesB = b?.sortValues || {};
              const valueA = sortValuesA[sortKey];
              const valueB = sortValuesB[sortKey];
              const numericA = Number.isFinite(valueA) ? valueA : parseNumber(valueA);
              const numericB = Number.isFinite(valueB) ? valueB : parseNumber(valueB);
              if (Number.isFinite(numericA) || Number.isFinite(numericB)) {
                const safeA = Number.isFinite(numericA) ? numericA : Number.NEGATIVE_INFINITY;
                const safeB = Number.isFinite(numericB) ? numericB : Number.NEGATIVE_INFINITY;
                if (safeA === safeB) {
                  const indexA = Number.isFinite(a?.index) ? a.index : 0;
                  const indexB = Number.isFinite(b?.index) ? b.index : 0;
                  return indexA - indexB;
                }
                return safeA > safeB ? directionMultiplier : -directionMultiplier;
              }
              const textA = String(valueA ?? '').trim();
              const textB = String(valueB ?? '').trim();
              const comparison = textA.localeCompare(textB, 'pt-BR', {
                sensitivity: 'base',
                numeric: true,
              });
              if (comparison === 0) {
                const indexA = Number.isFinite(a?.index) ? a.index : 0;
                const indexB = Number.isFinite(b?.index) ? b.index : 0;
                return indexA - indexB;
              }
              return comparison * directionMultiplier;
            });
        };

        const updateCodeLookupSortButtons = () => {
          const { sort } = codeLookupTableState;
          const activeKey = sort?.key || '';
          const activeDirection = sort?.direction === 'desc' ? 'desc' : 'asc';

          codeLookupSortHeaders.forEach((header, key) => {
            if (!header) return;
            if (key === activeKey && activeKey) {
              header.setAttribute('aria-sort', activeDirection === 'desc' ? 'descending' : 'ascending');
            } else {
              header.removeAttribute('aria-sort');
            }
          });

          codeLookupSortButtons.forEach((meta, button) => {
            if (!button) return;
            const isActive = activeKey && meta.key === activeKey && meta.direction === activeDirection;
            button.classList.toggle('text-primary', isActive);
            button.classList.toggle('border-primary/60', isActive);
            button.classList.toggle('bg-primary/10', isActive);
            button.setAttribute('aria-pressed', isActive ? 'true' : 'false');
          });
        };

        const updateCodeLookupTableDisplay = () => {
          if (!codeLookupTableBody) return;

          updateCodeLookupSortButtons();

          if (codeLookupLoadingRow) {
            codeLookupLoadingRow.classList.toggle('hidden', !codeLookupIsLoading);
          }

          if (codeLookupErrorRow) {
            if (codeLookupLastError) {
              if (codeLookupErrorCell) {
                codeLookupErrorCell.textContent = codeLookupLastError;
              }
              codeLookupErrorRow.classList.remove('hidden');
            } else {
              codeLookupErrorRow.classList.add('hidden');
            }
          }

          const shouldHideData = codeLookupIsLoading || Boolean(codeLookupLastError);
          const existingRows = codeLookupTableBody.querySelectorAll('[data-code-row]');
          if (shouldHideData) {
            existingRows.forEach((row) => row.remove());
            if (codeLookupEmptyRow) codeLookupEmptyRow.classList.add('hidden');
            if (codeLookupFilteredEmptyRow) codeLookupFilteredEmptyRow.classList.add('hidden');
            return;
          }

          const items = Array.isArray(codeLookupTableState.items) ? codeLookupTableState.items : [];
          const hasItems = items.length > 0;

          if (codeLookupEmptyRow) {
            codeLookupEmptyRow.classList.toggle('hidden', hasItems);
          }
          if (codeLookupFilteredEmptyRow) {
            codeLookupFilteredEmptyRow.classList.add('hidden');
          }

          existingRows.forEach((row) => row.remove());

          if (!hasItems) {
            return;
          }

          const derivedEntries = items.map((item, index) => buildCodeLookupRowData(item, index));
          const filteredEntries = applyCodeLookupFiltersToRows(derivedEntries);
          const entriesToRender = applyCodeLookupSortToRows(filteredEntries);

          if (!entriesToRender.length) {
            if (codeLookupFilteredEmptyRow) {
              codeLookupFilteredEmptyRow.classList.remove('hidden');
            }
            return;
          }

          const fragment = document.createDocumentFragment();

          entriesToRender.forEach((entry) => {
            const { item, displays } = entry;
            const row = document.createElement('tr');
            row.dataset.codeRow = 'true';
            if (item && (item.id || item._id)) {
              row.dataset.codeRowId = String(item.id || item._id);
            }
            if (item && typeof item.code !== 'undefined') {
              row.dataset.codeRowCode = String(item.code);
            }
            row.className = 'cursor-pointer transition hover:bg-gray-50 focus-within:bg-gray-50';
            row.tabIndex = 0;

            const codeCell = document.createElement('td');
            codeCell.className = 'px-4 py-3 font-semibold text-gray-700';
            codeCell.textContent = displays.code;

            const accessKeyCell = document.createElement('td');
            accessKeyCell.className = 'px-4 py-3 font-mono text-xs text-gray-600';
            accessKeyCell.textContent = displays.accessKey || '—';

            const nfCell = document.createElement('td');
            nfCell.className = 'px-4 py-3 text-gray-600';
            nfCell.textContent = displays.nf;

            const supplierCell = document.createElement('td');
            supplierCell.className = 'px-4 py-3 text-gray-600';
            supplierCell.textContent = displays.supplier;
            if (displays.supplierDocument) {
              const docLine = document.createElement('p');
              docLine.className = 'text-xs text-gray-500';
              docLine.textContent = formatDocument(displays.supplierDocument);
              supplierCell.appendChild(docLine);
            }

            const totalCell = document.createElement('td');
            totalCell.className = 'px-4 py-3 text-right text-gray-800 font-semibold';
            totalCell.textContent = displays.total;

            const issueCell = document.createElement('td');
            issueCell.className = 'px-4 py-3 text-gray-600';
            issueCell.textContent = displays.issueDate;

            const entryCell = document.createElement('td');
            entryCell.className = 'px-4 py-3 text-gray-600';
            entryCell.textContent = displays.entryDate;

            const statusCell = document.createElement('td');
            statusCell.className = 'px-4 py-3 text-gray-600';
            const statusBadge = document.createElement('span');
            statusBadge.className =
              'inline-flex items-center rounded-full border px-2 py-0.5 text-[10px] font-semibold uppercase tracking-wide';
            statusBadge.textContent = displays.status;
            statusBadge.classList.add(...mapDraftStatusClasses(displays.status));
            statusCell.appendChild(statusBadge);

            row.append(codeCell, accessKeyCell, nfCell, supplierCell, totalCell, issueCell, entryCell, statusCell);
            fragment.appendChild(row);
          });

          codeLookupTableBody.appendChild(fragment);
        };

        const setCodeLookupTableFilter = (key, value) => {
          if (!key) return;
          const nextValue = value || '';
          if (codeLookupTableState.filters[key] === nextValue) {
            return;
          }
          codeLookupTableState.filters[key] = nextValue;
          updateCodeLookupTableDisplay();
        };

        const setCodeLookupSort = (key, direction) => {
          if (!key) return;
          const nextDirection = direction === 'desc' ? 'desc' : 'asc';
          const { sort } = codeLookupTableState;
          const currentKey = sort?.key || '';
          const currentDirection = sort?.direction || 'asc';
          if (currentKey === key && currentDirection === nextDirection) {
            codeLookupTableState.sort = { key: '', direction: 'asc' };
          } else {
            codeLookupTableState.sort = { key, direction: nextDirection };
          }
          updateCodeLookupTableDisplay();
        };

        const renderCodeLookupRows = (items = []) => {
          codeLookupTableState.items = Array.isArray(items) ? items : [];
          updateCodeLookupTableDisplay();
        };

        const resetCodeLookupFilters = () => {
          codeLookupTableState.filters = {};
          codeLookupFilterInputs.forEach((input) => {
            if (input) {
              input.value = '';
            }
          });
        };

        const findCodeLookupItemById = (id) => {
          if (!id) return null;
          const items = Array.isArray(codeLookupTableState.items) ? codeLookupTableState.items : [];
          return (
            items.find((entry) => {
              if (!entry) return false;
              const candidateId = entry.id || entry._id || '';
              return candidateId && String(candidateId) === String(id);
            }) || null
          );
        };

        document.querySelectorAll('[data-main-products-filter]').forEach((input) => {
          const key = input.dataset.mainProductsFilter;
          if (!key) return;
          mainProductTableFilterInputs.set(key, input);
          mainProductTableState.filters[key] = input.value || '';
          input.addEventListener('input', (event) => {
            setMainProductTableFilter(key, event.target.value || '');
          });
        });

        document.querySelectorAll('[data-main-products-sort]').forEach((button) => {
          const key = button.dataset.mainProductsSort;
          if (!key) return;
          const direction = button.dataset.sortDirection === 'desc' ? 'desc' : 'asc';
          const header = button.closest('th');
          mainProductSortButtons.set(button, { key, direction });
          if (header && !mainProductSortHeaders.has(key)) {
            mainProductSortHeaders.set(key, header);
          }
          button.addEventListener('click', (event) => {
            event.preventDefault();
            setMainProductSort(key, direction);
          });
        });

        updateMainProductSortButtons();

        document.querySelectorAll('[data-code-lookup-filter]').forEach((input) => {
          const key = input.dataset.codeLookupFilter;
          if (!key) return;
          codeLookupFilterInputs.set(key, input);
          codeLookupTableState.filters[key] = input.value || '';
          input.addEventListener('input', (event) => {
            setCodeLookupTableFilter(key, event.target.value || '');
          });
        });

        document.querySelectorAll('[data-code-lookup-sort]').forEach((button) => {
          const key = button.dataset.codeLookupSort;
          if (!key) return;
          const direction = button.dataset.sortDirection === 'desc' ? 'desc' : 'asc';
          const header = button.closest('[data-code-sort-header]') || button.closest('th');
          codeLookupSortButtons.set(button, { key, direction });
          if (header && !codeLookupSortHeaders.has(key)) {
            codeLookupSortHeaders.set(key, header);
          }
          button.addEventListener('click', (event) => {
            event.preventDefault();
            setCodeLookupSort(key, direction);
          });
        });

        updateCodeLookupSortButtons();

        const loadCodeLookupList = async (companyId, { forceReload = false } = {}) => {
          const normalized = companyId ? String(companyId) : '';
          if (!normalized) {
            codeLookupLastCompanyId = '';
            codeLookupTableState.items = [];
            codeLookupLastError = null;
            codeLookupIsLoading = false;
            updateCodeLookupTableDisplay();
            return [];
          }

          if (!forceReload && codeLookupCache.has(normalized)) {
            const cached = codeLookupCache.get(normalized) || [];
            codeLookupTableState.items = cached;
            codeLookupLastError = null;
            codeLookupIsLoading = false;
            codeLookupLastCompanyId = normalized;
            updateCodeLookupTableDisplay();
            return cached;
          }

          codeLookupIsLoading = true;
          codeLookupLastError = null;
          updateCodeLookupTableDisplay();

          try {
            const url = new URL(nfeDraftsEndpoint, window.location.origin);
            url.searchParams.set('companyId', normalized);
            const response = await fetch(url.toString(), { headers: buildAuthHeaders() });
            const payload = await response.json().catch(() => ({}));

            if (response.status === 401 || response.status === 403) {
              handleAuthError();
            }

            if (!response.ok) {
              const message =
                (payload && (payload.message || payload.error)) ||
                `Falha ao carregar as notas cadastradas (status ${response.status}).`;
              throw new Error(message);
            }

            const drafts = Array.isArray(payload?.drafts) ? payload.drafts : [];
            const normalizedDrafts = drafts.map((draft) => ({
              ...draft,
              id: draft.id || draft._id || '',
              code: draft.code ?? draft.headerCode ?? draft.header?.code ?? '',
              headerCode: draft.headerCode || draft.header?.code || '',
              number: draft.number || draft.header?.number || '',
              serie: draft.serie || draft.header?.serie || '',
              status: draft.status || 'draft',
              totalValue:
                draft.totalValue ?? draft.totals?.totalValue ?? (draft.totals && draft.totals.totalValue) ?? null,
              issueDate: draft.issueDate || draft.header?.issueDate || '',
              entryDate: draft.entryDate || draft.header?.entryDate || '',
              supplierName: draft.supplierName || '',
              supplierDocument: draft.supplierDocument || '',
              accessKey: draft.accessKey || draft.xml?.accessKey || '',
            }));

            codeLookupCache.set(normalized, normalizedDrafts);
            codeLookupTableState.items = normalizedDrafts;
            codeLookupLastError = null;
            codeLookupIsLoading = false;
            codeLookupLastCompanyId = normalized;
            updateCodeLookupTableDisplay();
            return normalizedDrafts;
          } catch (error) {
            console.error('Erro ao carregar notas cadastradas:', error);
            codeLookupLastError =
              error?.message || 'Não foi possível carregar as notas cadastradas para a empresa selecionada.';
            codeLookupIsLoading = false;
            codeLookupTableState.items = [];
            updateCodeLookupTableDisplay();
            return [];
          }
        };

        const fetchDraftById = async (id) => {
          const normalized = id ? String(id) : '';
          if (!normalized) return null;
          const endpoint = `${nfeDraftsEndpoint}/${normalized}`;
          const response = await fetch(endpoint, { headers: buildAuthHeaders() });
          const payload = await response.json().catch(() => ({}));

          if (response.status === 401 || response.status === 403) {
            handleAuthError();
          }

          if (!response.ok) {
            const message =
              (payload && (payload.message || payload.error)) ||
              `Falha ao carregar a nota selecionada (status ${response.status}).`;
            throw new Error(message);
          }

          const draft = payload?.draft || payload;
          if (draft && !draft.id && draft._id) {
            draft.id = String(draft._id);
          }
          return draft;
        };

        const DUPLICATE_IMPORT_STATUS_SET = new Set([
          'draft',
          'rascunho',
          'cadastrada',
          'approved',
          'aprovado',
          'aprovada',
        ]);

        const normalizeDraftStatus = (status) => String(status || '').trim().toLowerCase();

        const fetchDraftsByAccessKey = async (accessKey, { companyId } = {}) => {
          const normalizedKey = digitsOnly(accessKey);
          if (!normalizedKey) return [];

          const url = new URL(nfeDraftsEndpoint, window.location.origin);
          url.searchParams.set('accessKey', normalizedKey);
          if (companyId) {
            url.searchParams.set('companyId', String(companyId));
          }

          const response = await fetch(url.toString(), { headers: buildAuthHeaders() });
          const payload = await response.json().catch(() => ({}));

          if (response.status === 401 || response.status === 403) {
            handleAuthError();
          }

          if (!response.ok) {
            const message =
              (payload && (payload.message || payload.error)) ||
              `Falha ao consultar notas existentes para a chave ${normalizedKey} (status ${response.status}).`;
            throw new Error(message);
          }

          const drafts = Array.isArray(payload?.drafts) ? payload.drafts : [];
          return drafts;
        };

        const findExistingDraftByAccessKey = async (accessKey, { companyId } = {}) => {
          const drafts = await fetchDraftsByAccessKey(accessKey, { companyId });
          if (!drafts.length) return null;
          const matchingDraft = drafts.find((draft) =>
            DUPLICATE_IMPORT_STATUS_SET.has(normalizeDraftStatus(draft?.status))
          );
          return matchingDraft || drafts[0] || null;
        };

        const handleExistingEntryRedirect = async (data) => {
          if (!data) return false;

          try {
            const accessKeyDigits = digitsOnly(data.accessKey || data?.xml?.accessKey || '');
            if (!accessKeyDigits) return false;

            const selectedCompanyId = data.selectedCompanyId || companySelect?.value || pendingCompanyId || '';
            const existingDraft = await findExistingDraftByAccessKey(accessKeyDigits, {
              companyId: selectedCompanyId,
            });

            if (!existingDraft) {
              return false;
            }

            const draftId = existingDraft.id || existingDraft._id || '';
            if (!draftId) {
              return false;
            }

            if (currentDraftId && String(currentDraftId) === String(draftId)) {
              return false;
            }

            const draft = await fetchDraftById(draftId);
            if (!draft) {
              throw new Error('Não foi possível carregar a entrada já cadastrada para esta NF-e.');
            }

            applyDraftDataToForm(draft);

            const formattedCode = currentDraftCode ? formatDraftCode(currentDraftCode) : '';
            const statusLabel = mapDraftStatusLabel(existingDraft.status);
            const messageParts = ['Esta NF-e já possui uma entrada cadastrada.'];
            if (formattedCode) {
              messageParts.push(`Código ${formattedCode}.`);
            }
            if (statusLabel) {
              messageParts.push(`Status ${statusLabel}.`);
            }

            notify(messageParts.join(' '), 'warning');

            if (importFileInput) {
              importFileInput.value = '';
            }

            if (selectedCompanyId) {
              loadCodeLookupList(selectedCompanyId, { forceReload: true }).catch(() => {});
            }

            closeImportModal();
            return true;
          } catch (error) {
            console.error('Erro ao verificar existência da NF-e importada:', error);
            const message =
              error?.message || 'Não foi possível verificar se esta NF-e já está cadastrada.';
            throw new Error(message);
          }
        };

        const buildNoteDataFromDraft = (draft) => {
          if (!draft || typeof draft !== 'object') return null;
          const payload = clonePlainObject(draft.payload) || {};
          const importedData = clonePlainObject(payload.importedData) || {};
          const noteData = importedData && typeof importedData === 'object' ? importedData : {};
          const header = payload.header || {};

          if (!noteData.ide || typeof noteData.ide !== 'object') {
            noteData.ide = {};
          }
          noteData.ide.number = header.number || noteData.ide.number || '';
          noteData.ide.serie = header.serie || noteData.ide.serie || '';
          noteData.ide.model = header.model || noteData.ide.model || '';
          noteData.ide.type = header.type || noteData.ide.type || '';
          noteData.ide.emissionDate = header.issueDate || noteData.ide.emissionDate || '';
          noteData.ide.entryDate = header.entryDate || noteData.ide.entryDate || '';
          if (payload.transport?.mode) {
            noteData.ide.freightMode = payload.transport.mode;
          }

          noteData.totals = { ...(noteData.totals || {}), ...(payload.totals || {}) };
          noteData.transport = { ...(noteData.transport || {}), ...(payload.transport || {}) };
          noteData.duplicates = Array.isArray(payload.duplicates) ? payload.duplicates : noteData.duplicates || [];
          noteData.references = Array.isArray(payload.references) ? payload.references : noteData.references || [];
          noteData.payments = Array.isArray(payload.payments) ? payload.payments : noteData.payments || [];

          const additional = payload.additionalInfo || {};
          noteData.additionalInfo = {
            ...(noteData.additionalInfo || {}),
            complementary: additional.observation || noteData.additionalInfo?.complementary || '',
            fiscal: additional.complementaryFiscal || noteData.additionalInfo?.fiscal || '',
            paymentCondition: additional.paymentCondition || noteData.additionalInfo?.paymentCondition || '',
            paymentForm: additional.paymentForm || noteData.additionalInfo?.paymentForm || '',
          };

          if (Array.isArray(payload.items) && payload.items.length) {
            noteData.items = payload.items;
          }

          const selection = payload.selection || {};
          noteData.selection = { ...(noteData.selection || {}), ...selection };
          noteData.selectedCompanyId = selection.companyId || noteData.selectedCompanyId || '';
          noteData.selectedDepositId = selection.depositId || noteData.selectedDepositId || '';
          noteData.selectedBankAccountId = selection.bankAccountId || noteData.selectedBankAccountId || '';

          const supplier = payload.supplier || {};
          if (!noteData.emit || typeof noteData.emit !== 'object') {
            noteData.emit = {};
          }
          if (supplier.name && !noteData.emit.name) noteData.emit.name = supplier.name;
          if (supplier.document) noteData.emit.document = supplier.document;
          if (supplier.stateRegistration) noteData.emit.stateRegistration = supplier.stateRegistration;
          if (supplier.email) noteData.emit.email = supplier.email;
          if (supplier.addressText) {
            noteData.emit.address = noteData.emit.address || {};
            noteData.emit.address.text = supplier.addressText;
          }

          noteData.accessKey = payload.xml?.accessKey || noteData.accessKey || '';
          noteData.xml = payload.xml || noteData.xml || {};
          noteData.metadata = { ...(noteData.metadata || {}), ...(payload.metadata || {}), draftId: draft._id || draft.id || '' };
          noteData.importedData = payload.importedData || noteData.importedData || {};
          noteData.draftId = draft._id || draft.id || '';
          noteData.draftCode = draft.code || noteData.draftCode || '';
          noteData.paymentConditionHint = additional.paymentCondition || noteData.paymentConditionHint || '';
          noteData.paymentFormHint = additional.paymentForm || noteData.paymentFormHint || '';

          return noteData;
        };

        const applyDraftDataToForm = (draft) => {
          const noteData = buildNoteDataFromDraft(draft);
          if (!noteData) {
            throw new Error('Os dados retornados do rascunho estão incompletos.');
          }
          resetImportedNfeState();
          lastNfeData = noteData;
          applyImportedDataToMainForm(lastNfeData);
          applyDraftResponseToState(draft);
          updateSummaryFromData(lastNfeData);
        };

        const trapCodeLookupFocus = (event) => {
          if (!codeLookupModal || codeLookupModal.classList.contains('hidden')) return;
          if (event.key !== 'Tab') return;

          const focusableElements = codeLookupModalCard
            ? Array.from(codeLookupModalCard.querySelectorAll(MODAL_FOCUSABLE_SELECTORS)).filter(
                (element) => element instanceof HTMLElement && element.offsetParent !== null
              )
            : [];
          if (!focusableElements.length) return;

          const firstElement = focusableElements[0];
          const lastElement = focusableElements[focusableElements.length - 1];

          if (event.shiftKey && document.activeElement === firstElement) {
            event.preventDefault();
            lastElement.focus();
          } else if (!event.shiftKey && document.activeElement === lastElement) {
            event.preventDefault();
            firstElement.focus();
          }
        };

        const openCodeLookupModal = () => {
          if (!codeLookupModal || codeLookupIsOpen) return;

          codeLookupPreviousFocus = document.activeElement;
          codeLookupIsOpen = true;
          codeLookupModal.classList.remove('hidden');
          document.body.classList.add('overflow-hidden');

          if (codeLookupModalCard) {
            codeLookupModalCard.classList.add('opacity-0', 'scale-95');
            requestAnimationFrame(() => {
              codeLookupModalCard.classList.remove('opacity-0', 'scale-95');
              codeLookupModalCard.classList.add('opacity-100', 'scale-100');
            });

            const focusableElements = Array.from(
              codeLookupModalCard.querySelectorAll(MODAL_FOCUSABLE_SELECTORS)
            ).filter((element) => element instanceof HTMLElement && element.offsetParent !== null);
            if (focusableElements.length) {
              focusableElements[0].focus();
            }
          }

          document.addEventListener('keydown', trapCodeLookupFocus);

          resetCodeLookupFilters();
          codeLookupTableState.sort = { key: '', direction: 'asc' };
          codeLookupLastError = null;

          const activeCompanyId = companySelect ? companySelect.value || '' : '';
          if (codeLookupCompanySelect) {
            codeLookupCompanySelect.value = activeCompanyId || '';
          }

          if (activeCompanyId) {
            loadCodeLookupList(activeCompanyId).catch(() => {});
          } else {
            codeLookupTableState.items = [];
            codeLookupIsLoading = false;
            codeLookupLastError = null;
            updateCodeLookupTableDisplay();
          }
        };

        const closeCodeLookupModal = () => {
          if (!codeLookupModal || codeLookupModal.classList.contains('hidden')) return;

          codeLookupIsOpen = false;

          if (codeLookupModalCard) {
            codeLookupModalCard.classList.remove('opacity-100', 'scale-100');
            codeLookupModalCard.classList.add('opacity-0', 'scale-95');
          }

          setTimeout(() => {
            codeLookupModal.classList.add('hidden');
            if (codeLookupPreviousFocus && typeof codeLookupPreviousFocus.focus === 'function') {
              codeLookupPreviousFocus.focus();
            }
            codeLookupPreviousFocus = null;
          }, 180);

          if (!importModal || importModal.classList.contains('hidden')) {
            document.body.classList.remove('overflow-hidden');
          }

          document.removeEventListener('keydown', trapCodeLookupFocus);
        };

        const handleCodeLookupRowSelection = async (rowId) => {
          const normalizedId = rowId ? String(rowId) : '';
          if (!normalizedId || isLoadingDraftDetails) return;
          isLoadingDraftDetails = true;

          try {
            closeCodeLookupModal();
            notify('Carregando nota selecionada...', 'info');
            const draft = await fetchDraftById(normalizedId);
            if (!draft) {
              throw new Error('Não foi possível localizar a nota selecionada.');
            }
            applyDraftDataToForm(draft);
            const formattedCode = currentDraftCode ? formatDraftCode(currentDraftCode) : '';
            if (formattedCode) {
              notify(`Nota ${formattedCode} carregada a partir do rascunho.`, 'success');
            } else {
              notify('Nota carregada a partir do rascunho selecionado.', 'success');
            }
          } catch (error) {
            console.error('Erro ao carregar nota selecionada:', error);
            notify(error?.message || 'Não foi possível carregar a nota selecionada.', 'error');
          } finally {
            isLoadingDraftDetails = false;
          }
        };

        const updateDuplicataSummaryFromData = (data) => {
          const duplicates = Array.isArray(data?.duplicates) ? data.duplicates : [];
          const emission = normalizeDate(data?.ide?.emissionDate);
          const entry = normalizeDate(data?.ide?.entryDate);
          const baseDateInput = emission.dateInput || entry.dateInput || '';

          if (duplicataEmissionInput) {
            duplicataEmissionInput.value = emission.dateInput || '';
          }
          if (duplicataCountInput) {
            duplicataCountInput.value = duplicates.length ? String(duplicates.length) : '';
          }

          const firstDuplicate = duplicates[0];
          const firstManual = normalizeDate(firstDuplicate?.manualDueDate);
          const firstDue = firstManual.dateInput
            ? firstManual
            : normalizeDate(firstDuplicate?.dueDate);

          if (duplicataFirstDueInput) {
            if (firstDuplicate) {
              if (firstDue.dateInput) {
                duplicataFirstDueInput.value = firstDue.dateInput;
              } else if (Number.isFinite(firstDuplicate?.termDays) && baseDateInput) {
                const fallbackDue = addPaymentDaysToDateInput(baseDateInput, firstDuplicate.termDays);
                duplicataFirstDueInput.value = fallbackDue || '';
              } else {
                duplicataFirstDueInput.value = '';
              }
            } else {
              duplicataFirstDueInput.value = '';
            }
          }

          if (duplicataInitialDaysInput) {
            if (firstDuplicate) {
              if (Number.isFinite(firstDuplicate?.termDays)) {
                duplicataInitialDaysInput.value = String(firstDuplicate.termDays);
              } else if (baseDateInput && (firstDue.dateInput || firstManual.dateInput)) {
                const diffBase = firstDue.dateInput || firstManual.dateInput;
                const diff = computeInclusiveTermDays(baseDateInput, diffBase);
                duplicataInitialDaysInput.value = Number.isFinite(diff) ? String(diff) : '';
              } else {
                duplicataInitialDaysInput.value = '';
              }
            } else {
              duplicataInitialDaysInput.value = '';
            }
          }

          if (duplicataDaysInput) {
            duplicataDaysInput.value = '';
          }
          if (duplicataDaysTypeSelect) {
            setSelectValue(duplicataDaysTypeSelect, duplicates.length ? 'data' : 'dias');
          }
        };

        const fillDuplicatasFromNfeData = (data) => {
          const duplicates = Array.isArray(data?.duplicates) ? data.duplicates : [];
          updateDuplicataSummaryFromData(data);

          if (bankAccountSelect) {
            const desiredValue = data?.selectedBankAccountId || '';
            if (desiredValue) {
              const applied = setBankAccountSelectValue(desiredValue);
              if (!applied) {
                pendingBankAccountId = desiredValue;
              } else if (pendingBankAccountId === desiredValue) {
                pendingBankAccountId = '';
              }
            } else {
              bankAccountSelect.value = '';
              pendingBankAccountId = '';
            }
          }

          const activeBankAccountId = bankAccountSelect ? bankAccountSelect.value : '';
          if (data) {
            data.selectedBankAccountId = activeBankAccountId || pendingBankAccountId || '';
          }
          const supplierAccountDetails = resolveSupplierAccountingAccount();
          duplicates.forEach((duplicate) => {
            if (!duplicate || typeof duplicate !== 'object') return;
            if (!duplicate.originalDueDate) {
              duplicate.originalDueDate = duplicate.dueDate || '';
            }
            if (typeof duplicate.bankAccountIsManual !== 'boolean') {
              duplicate.bankAccountIsManual = Boolean(duplicate.bankAccount);
            }
            if (duplicate.bankAccountIsManual) {
              duplicate.bankAccount = duplicate.bankAccount ? String(duplicate.bankAccount) : null;
            } else {
              duplicate.bankAccount = activeBankAccountId ? String(activeBankAccountId) : null;
            }
            applyAccountingAccountToDuplicate(duplicate, supplierAccountDetails, {
              preserveExisting: true,
            });
          });

          renderDuplicatasFromNfe(duplicates, data);
        };

        const applyImportedDataToMainForm = (data) => {
          if (!data) return;
          fillMainFormFromNfeData(data);
          fillSupplierFieldsFromNfe(data);
          applySupplierSelectionFromData(data);
          fillTotalsFromNfeData(data);
          fillTransportFromNfeData(data);
          fillDepositSelectionFromNfeData(data);
          fillDuplicatasFromNfeData(data);
          fillAdditionalInfoFromNfeData(data);
          renderDocumentsFromNfe(data.references);
          renderMainProductsFromNfe(data.items);
          if (totalAmountDisplay) {
            totalAmountDisplay.textContent = formatCurrencyBRL(data.totals?.totalValue);
          }
        };

        const resetImportedNfeState = () => {
          lastNfeData = null;
          lastSupplierData = null;
          lastSupplierRecord = null;
          pendingBonusData = null;
          importModalContext = IMPORT_CONTEXT_FULL;
          supplierLinkErrorNotified = false;
          productValidationSequence += 1;
          resetDraftState();
          resetProductLookupCaches();
          productSupplierLinkCache.clear();
          productSupplierLinkPromises.clear();
          supplierReferenceLookupCache.clear();
          supplierReferenceLookupPromises.clear();
          if (refreshImportedProductsButton) {
            setRefreshImportedProductsButtonState(false);
          }
          if (importFileInput) {
            importFileInput.value = '';
          }
          clearStatusMessages();
          try {
            sessionStorage.removeItem(PRODUCT_DRAFT_STORAGE_KEY);
          } catch (error) {
            console.warn('Não foi possível limpar o rascunho de produtos da importação.', error);
          }

          const inputsToReset = [
            nfeNumberInput,
            nfeSeriesInput,
            issueDateInput,
            entryDateInput,
            importAccessKeyInput,
            accessKeyInput,
            supplierCnpjInput,
            supplierIeInput,
            supplierEmailInput,
            supplierAddressInput,
            transportCnpjInput,
            transportIeInput,
            transportPlateInput,
            transportNameInput,
            weightGrossInput,
            weightNetInput,
            totalsProductsInput,
            totalsBonificationInput,
            totalsIcmsBaseInput,
            totalsIcmsValueInput,
            totalsIcmsStInput,
            totalsFcpStInput,
            totalsDiscountInput,
            totalsOtherInput,
            totalsFreightInput,
            totalsIpiInput,
            totalsUnitDiscountInput,
            totalsInsuranceInput,
            totalsDollarInput,
            duplicataEmissionInput,
            duplicataCountInput,
            duplicataFirstDueInput,
            duplicataDaysInput,
            duplicataInitialDaysInput,
            accountingAccountInput,
            paymentConditionInput,
            paymentFormInput,
            observationInput,
            complementaryInfoInput,
          ];

          inputsToReset.forEach((input) => setInputValue(input, ''));

          const selectsToReset = [
            { element: supplierSelect, value: '' },
            { element: supplierUfSelect, value: '' },
            { element: companySelect, value: '' },
            { element: bankAccountSelect, value: '' },
            { element: nfeModelSelect, value: '55' },
            { element: nfeTypeSelect, value: 'NF' },
            { element: depositSelect, value: '' },
            { element: transportUfSelect, value: '' },
            { element: transportPlateUfSelect, value: '' },
            { element: freightModeSelect, value: '0' },
            { element: duplicataDaysTypeSelect, value: 'dias' },
          ];

          selectsToReset.forEach(({ element, value }) => resetSelectValue(element, value));

          pendingCompanyId = '';
          pendingCompanyDocumentDigits = '';
          pendingBankAccountId = '';
          pendingSupplierId = '';
          pendingSupplierDocument = '';
          setBankAccountPlaceholder('Selecione uma empresa para listar as contas correntes');
          pendingDepositId = '';
          setDepositPlaceholder('Selecione uma empresa para listar os depósitos');

          if (totalAmountDisplay) {
            totalAmountDisplay.textContent = 'R$ 0,00';
          }

          updateSummaryFromData(null);
          setSupplierSummary(null);
          renderDocumentsFromNfe([]);
          renderDuplicatasFromNfe([], null);
          renderMainProductsFromNfe([]);
        };

        const handleSupplierSelection = async (supplier) => {
          setSupplierSummary(supplier);
          lastSupplierData = supplier || null;
          lastSupplierRecord = null;
          if (!supplier || !supplier.document) {
            updateSupplierStatusCard(
              'warning',
              'Documento do emitente não encontrado no XML.',
              'Revise o arquivo para garantir que os dados do fornecedor estejam completos.'
            );
            syncAccountingAccountWithDuplicates();
            return;
          }
          const documentDigits = digitsOnly(supplier.document);
          if (!documentDigits) {
            updateSupplierStatusCard(
              'warning',
              'Documento do emitente não encontrado no XML.',
              'Revise o arquivo para garantir que os dados do fornecedor estejam completos.'
            );
            syncAccountingAccountWithDuplicates();
            return;
          }
          const formattedDocument = formatDocument(documentDigits);
          let matchedOption = supplierSelect ? findSupplierOptionByDocument(documentDigits) : null;

          await loadSuppliersFromApi();
          let registeredSupplier = supplierRegistry.byDocument.get(documentDigits) || null;
          lastSupplierRecord = registeredSupplier || null;

          if (!registeredSupplier && !matchedOption) {
            await loadSuppliersFromApi(true);
            registeredSupplier = supplierRegistry.byDocument.get(documentDigits) || null;
            lastSupplierRecord = registeredSupplier || null;
          }

          if (!matchedOption && registeredSupplier) {
            matchedOption = ensureSupplierOption(registeredSupplier, documentDigits);
          }

          if (!lastSupplierRecord && matchedOption) {
            const optionSupplierName =
              (matchedOption.dataset && matchedOption.dataset.supplierName) ||
              matchedOption.textContent ||
              '';
            lastSupplierRecord = {
              _id: matchedOption.dataset?.supplierId || null,
              legalName: optionSupplierName,
              cnpj: matchedOption.dataset?.supplierDocument || '',
            };
          }

          if (matchedOption) {
            pendingSupplierId = '';
            pendingSupplierDocument = '';
            supplierSelect.value = matchedOption.value;
            supplierSelect.dispatchEvent(new Event('change', { bubbles: true }));
            const supplierName =
              registeredSupplier?.legalName ||
              registeredSupplier?.fantasyName ||
              matchedOption.dataset?.supplierName ||
              supplier.name ||
              formattedDocument;
            updateSupplierStatusCard(
              'success',
              `Fornecedor localizado: ${supplierName}`,
              `Aplicamos automaticamente o fornecedor cadastrado (${formattedDocument}).`
            );
            syncAccountingAccountWithDuplicates();
            return;
          }
          const registerUrl = buildSupplierRegistrationUrl(supplier, lastNfeData);
          updateSupplierStatusCard(
            'warning',
            supplierRegistry.error
              ? `Não foi possível confirmar o cadastro do fornecedor (${formattedDocument}).`
              : `Fornecedor não cadastrado (${formattedDocument})`,
            supplierRegistry.error
              ? 'Tente novamente em instantes ou atualize a página para sincronizar a base de fornecedores.'
              : 'Abriremos o cadastro de fornecedores em nova aba com os dados importados do XML.',
            [
              {
                label: supplierRegistry.error ? 'Tentar novamente' : 'Cadastrar fornecedor',
                icon: supplierRegistry.error ? 'fas fa-sync' : 'fas fa-user-plus',
                variant: supplierRegistry.error ? 'secondary' : 'primary',
                action: () => {
                  if (supplierRegistry.error) {
                    loadSuppliersFromApi(true);
                  } else {
                    window.open(registerUrl, '_blank', 'noopener');
                  }
                },
              },
              !supplierRegistry.error
                ? null
                : {
                    label: 'Cadastrar fornecedor',
                    icon: 'fas fa-user-plus',
                    variant: 'primary',
                    action: () => {
                      window.open(registerUrl, '_blank', 'noopener');
                    },
                  },
            ].filter(Boolean)
          );
          syncAccountingAccountWithDuplicates();
        };

        const parseNfeXml = (xmlText) => {
          const parser = new DOMParser();
          const xml = parser.parseFromString(xmlText, 'application/xml');
          if (xml.querySelector('parsererror')) {
            throw new Error('O arquivo XML está inválido ou corrompido.');
          }
          const infNFe = xml.getElementsByTagName('infNFe')[0];
          if (!infNFe) {
            throw new Error('Não foi possível localizar os dados principais da NF-e (infNFe).');
          }
          const getText = (context, tagName) => {
            if (!context) return '';
            const element = context.getElementsByTagName(tagName)[0];
            return element ? element.textContent.trim() : '';
          };
          const ide = infNFe.getElementsByTagName('ide')[0];
          const emit = infNFe.getElementsByTagName('emit')[0];
          const dest = infNFe.getElementsByTagName('dest')[0];
          const total = infNFe.getElementsByTagName('ICMSTot')[0];
          const transp = infNFe.getElementsByTagName('transp')[0];
          const transporta = transp ? transp.getElementsByTagName('transporta')[0] : null;
          const veicTransp = transp ? transp.getElementsByTagName('veicTransp')[0] : null;
          const volElement = transp ? transp.getElementsByTagName('vol')[0] : null;
          const detElements = Array.from(infNFe.getElementsByTagName('det'));
          const prot = xml.getElementsByTagName('protNFe')[0];
          const infProt = prot ? prot.getElementsByTagName('infProt')[0] : null;
          const cobr = infNFe.getElementsByTagName('cobr')[0];
          const dupElements = cobr ? Array.from(cobr.getElementsByTagName('dup')) : [];
          const pagElements = Array.from(infNFe.getElementsByTagName('pag'));
          const detPagElements = pagElements.reduce((acc, pagElement) => {
            const detPagList = Array.from(pagElement.getElementsByTagName('detPag'));
            if (detPagList.length) {
              acc.push(...detPagList);
            }
            return acc;
          }, []);
          const nfRefElements = ide ? Array.from(ide.getElementsByTagName('NFref')) : [];
          const infAdic = infNFe.getElementsByTagName('infAdic')[0] || null;

          const accessKey = (infNFe.getAttribute('Id') || infNFe.getAttribute('id') || '').replace(/^NFe/i, '');
          const emissionDate = getText(ide, 'dhEmi') || getText(ide, 'dEmi');
          const entryDate = getText(ide, 'dhSaiEnt') || getText(ide, 'dSaiEnt');
          const items = detElements.map((detElement, index) => {
            const prod = detElement.getElementsByTagName('prod')[0];
            const imposto = detElement.getElementsByTagName('imposto')[0];
            const icms = imposto ? imposto.getElementsByTagName('ICMS')[0] : null;
            const icmsNode = icms
              ? Array.from(icms.children || []).find((child) => child.nodeType === 1)
              : null;
            const ipi = imposto ? imposto.getElementsByTagName('IPI')[0] : null;
            const ipiNode = ipi
              ? ipi.getElementsByTagName('IPITrib')[0] ||
                ipi.getElementsByTagName('IPINT')[0] ||
                ipi
              : null;
            const ii = imposto ? imposto.getElementsByTagName('II')[0] : null;
            const pis = imposto ? imposto.getElementsByTagName('PIS')[0] : null;
            const pisNode = pis
              ? Array.from(pis.children || []).find((child) => child.nodeType === 1)
              : null;
            const cofins = imposto ? imposto.getElementsByTagName('COFINS')[0] : null;
            const cofinsNode = cofins
              ? Array.from(cofins.children || []).find((child) => child.nodeType === 1)
              : null;

            const supplierCode = getText(prod, 'cProd');
            const description = getText(prod, 'xProd');
            const unit = getText(prod, 'uCom');
            const quantityRaw = parseNumber(getText(prod, 'qCom'));
            const quantity = Number.isFinite(quantityRaw) ? quantityRaw : 0;
            const unitPriceRaw = parseNumber(getText(prod, 'vUnCom'));
            const unitPrice = Number.isFinite(unitPriceRaw) ? unitPriceRaw : 0;
            const discountRaw = parseNumber(getText(prod, 'vDesc'));
            const discount = Number.isFinite(discountRaw) ? discountRaw : 0;
            const totalRaw = parseNumber(getText(prod, 'vProd'));
            const total = Number.isFinite(totalRaw) ? totalRaw : quantity * unitPrice;
            const ncm = getText(prod, 'NCM');
            const cfopItem = getText(prod, 'CFOP');
            const cest = getText(prod, 'CEST');
            const ean = getText(prod, 'cEAN');
            const eanTrib = getText(prod, 'cEANTrib');
            const barcodeCandidates = Array.from(new Set([normalizeGtin(ean), normalizeGtin(eanTrib)].filter(Boolean)));
            const barcodeDisplay = formatGtinDisplay(ean || eanTrib);
            const barcodeTribDisplay = formatGtinDisplay(eanTrib);
            const qTribRaw = parseNumber(getText(prod, 'qTrib'));
            const qTrib = Number.isFinite(qTribRaw) ? qTribRaw : quantity;
            const conversionMultiplier = Number.isFinite(qTrib) && qTrib > 0 ? qTrib : 1;
            const conversionDivider = Number.isFinite(quantity) && quantity > 0 ? quantity : 1;
            const conversion =
              Number.isFinite(conversionMultiplier) &&
              conversionMultiplier > 0 &&
              Number.isFinite(conversionDivider) &&
              conversionDivider > 0
                ? conversionMultiplier / conversionDivider
                : 1;
            const freightRaw = parseNumber(getText(prod, 'vFrete'));
            const freight = Number.isFinite(freightRaw) ? freightRaw : 0;
            const insuranceRaw = parseNumber(getText(prod, 'vSeg'));
            const insurance = Number.isFinite(insuranceRaw) ? insuranceRaw : 0;
            const otherRaw = parseNumber(getText(prod, 'vOutro'));
            const other = (Number.isFinite(otherRaw) ? otherRaw : 0) + (Number.isFinite(insurance) ? insurance : 0);
            const grossAmount = Number.isFinite(quantity) && Number.isFinite(unitPrice) ? quantity * unitPrice : total;
            const discountPercent =
              Number.isFinite(grossAmount) && grossAmount > 0 ? (discount / grossAmount) * 100 : 0;

            const icmsCst = getText(icmsNode, 'CST') || getText(icmsNode, 'CSOSN') || '';
            const icmsRateRaw = parseNumber(getText(icmsNode, 'pICMS'));
            const icmsRate = Number.isFinite(icmsRateRaw) ? icmsRateRaw : 0;
            const icmsBaseRaw = parseNumber(getText(icmsNode, 'vBC'));
            const icmsBase = Number.isFinite(icmsBaseRaw) ? icmsBaseRaw : 0;
            const icmsValueRaw = parseNumber(getText(icmsNode, 'vICMS'));
            const icmsValue = Number.isFinite(icmsValueRaw) ? icmsValueRaw : 0;
            const ivaRaw = parseNumber(getText(icmsNode, 'pMVAST'));
            const iva = Number.isFinite(ivaRaw) ? ivaRaw : 0;
            const icmsStRateRaw = parseNumber(getText(icmsNode, 'pICMSST'));
            const icmsStRate = Number.isFinite(icmsStRateRaw) ? icmsStRateRaw : 0;
            const icmsStValueRaw = parseNumber(getText(icmsNode, 'vICMSST'));
            const icmsStValue = Number.isFinite(icmsStValueRaw) ? icmsStValueRaw : 0;

            const fcpValueRaw = parseNumber(getText(icmsNode, 'vFCP'));
            const fcpValue = Number.isFinite(fcpValueRaw) ? fcpValueRaw : 0;
            const fcpStValueRaw = parseNumber(getText(icmsNode, 'vFCPST'));
            const fcpStValue = Number.isFinite(fcpStValueRaw) ? fcpStValueRaw : 0;
            const fcpStRetRaw = parseNumber(getText(icmsNode, 'vFCPSTRet'));
            const fcpStRetainedValue = Number.isFinite(fcpStRetRaw) ? fcpStRetRaw : 0;

            const ipiRateRaw = parseNumber(getText(ipiNode, 'pIPI'));
            const ipiRate = Number.isFinite(ipiRateRaw) ? ipiRateRaw : 0;
            const ipiBaseRaw = parseNumber(getText(ipiNode, 'vBC'));
            const ipiBase = Number.isFinite(ipiBaseRaw) ? ipiBaseRaw : 0;
            const ipiValueRaw = parseNumber(getText(ipiNode, 'vIPI'));
            const ipiValue = Number.isFinite(ipiValueRaw) ? ipiValueRaw : 0;
            const ipiCst = getText(ipiNode, 'CST') || getText(ipi, 'CST') || '';

            const iiValueRaw = parseNumber(getText(ii, 'vII'));
            const iiValue = Number.isFinite(iiValueRaw) ? iiValueRaw : 0;

            const pisRateRaw = parseNumber(getText(pisNode, 'pPIS'));
            const pisRate = Number.isFinite(pisRateRaw) ? pisRateRaw : 0;
            const pisBaseRaw = parseNumber(getText(pisNode, 'vBC'));
            const pisBase = Number.isFinite(pisBaseRaw) ? pisBaseRaw : 0;
            const pisValueRaw = parseNumber(getText(pisNode, 'vPIS'));
            const pisValue = Number.isFinite(pisValueRaw) ? pisValueRaw : 0;

            const cofinsRateRaw = parseNumber(getText(cofinsNode, 'pCOFINS'));
            const cofinsRate = Number.isFinite(cofinsRateRaw) ? cofinsRateRaw : 0;
            const cofinsBaseRaw = parseNumber(getText(cofinsNode, 'vBC'));
            const cofinsBase = Number.isFinite(cofinsBaseRaw) ? cofinsBaseRaw : 0;
            const cofinsValueRaw = parseNumber(getText(cofinsNode, 'vCOFINS'));
            const cofinsValue = Number.isFinite(cofinsValueRaw) ? cofinsValueRaw : 0;

            const itemData = {
              index,
              nItem: detElement.getAttribute('nItem') || String(index + 1),
              supplierCode,
              description,
              unit,
              quantity,
              unitPrice,
              discount,
              total,
              ncm,
              cfop: cfopItem,
              cest,
              cst: icmsCst,
              icmsRate,
              icmsBase,
              icmsValue,
              iva,
              icmsStRate,
              icmsStValue,
              fcpValue,
              fcpStValue,
              fcpStRetainedValue,
              ipiRate,
              ipiBase,
              ipiValue,
              ipiCst,
              iiValue,
              pisRate,
              pisBase,
              pisValue,
              cofinsRate,
              cofinsBase,
              cofinsValue,
              freight,
              other,
              barcodeDisplay,
              barcodeTribDisplay,
              barcodeCandidates,
              unitTrib: getText(prod, 'uTrib'),
              qTrib,
              discountPercent,
              ean,
              eanTrib,
              conversionMultiplier: Number.isFinite(conversionMultiplier) ? conversionMultiplier : 1,
              conversionDivider: Number.isFinite(conversionDivider) ? conversionDivider : 1,
              conversion: Number.isFinite(conversion) ? conversion : 1,
              originalConversionFactor: Number.isFinite(conversion) ? conversion : null,
              validationStatus: barcodeCandidates.length ? 'pending' : 'no-barcode',
              matchedProduct: null,
            };
            ensureItemCostWithTaxes(itemData);
            return itemData;
          });
          const cfop = items.find((item) => item.cfop)?.cfop || '';
          const addressFrom = (element) => {
            if (!element) return {};
            return {
              street: getText(element, 'xLgr'),
              number: getText(element, 'nro'),
              complement: getText(element, 'xCpl'),
              neighborhood: getText(element, 'xBairro'),
              city: getText(element, 'xMun'),
              state: getText(element, 'UF'),
              cep: getText(element, 'CEP'),
              country: getText(element, 'xPais') || 'Brasil',
            };
          };

          const duplicatesFromXml = dupElements.map((dup, index) => ({
            index,
            number: getText(dup, 'nDup'),
            dueDate: getText(dup, 'dVenc'),
            value: toNumeric(getText(dup, 'vDup')),
          }));

          const payments = detPagElements.map((detPag, index) => {
            const cardNode = detPag.getElementsByTagName('card')[0] || null;
            const methodCode = getText(detPag, 'tPag');
            const rawDueDate = getText(detPag, 'dVenc');
            let termDays = null;
            const emissionInfo = normalizeDate(emissionDate);
            const paymentDueInfo = normalizeDate(rawDueDate);
            if (emissionInfo.dateInput && paymentDueInfo.dateInput) {
              const diff = computeInclusiveTermDays(emissionInfo.dateInput, paymentDueInfo.dateInput);
              if (Number.isFinite(diff)) {
                termDays = diff;
              }
            }
            const payment = {
              index,
              method: methodCode,
              description: describePaymentMethod(methodCode),
              type: getText(detPag, 'indPag'),
              dueDate: rawDueDate,
              amount: toNumeric(getText(detPag, 'vPag')),
              integrationType: getText(cardNode, 'tpIntegra'),
              cardCnpj: getText(cardNode, 'CNPJ'),
              cardBrand: getText(cardNode, 'tBand'),
              termDays: Number.isFinite(termDays) ? termDays : null,
            };
            return payment;
          });

          const paymentsForDuplicates = payments.filter((payment) => {
            const amount = toNumeric(payment?.amount);
            const dueInfo = normalizeDate(payment?.dueDate);
            return (
              (Number.isFinite(amount) && Math.abs(amount) > 0.000001) ||
              dueInfo.dateInput ||
              Number.isFinite(payment?.termDays)
            );
          });

          let duplicates = duplicatesFromXml.length
            ? duplicatesFromXml
            : paymentsForDuplicates.map((payment) => ({
                index: payment.index,
                number: '',
                dueDate: payment.dueDate,
                value: payment.amount,
                paymentMethod: payment.method,
                paymentDescription: payment.description,
                paymentType: payment.type,
                termDays: payment.termDays,
              }));

          const emissionInfo = normalizeDate(emissionDate);
          const entryInfo = normalizeDate(entryDate);
          const fallbackBaseDateInput = entryInfo.dateInput || emissionInfo.dateInput || '';
          const paymentByIndex = new Map();
          payments.forEach((payment) => {
            const paymentIndex = Number.isFinite(payment.index) ? payment.index : paymentByIndex.size;
            paymentByIndex.set(paymentIndex, payment);
          });

          duplicates = duplicates.map((duplicate, position) => {
            const resolvedIndex = Number.isFinite(duplicate?.index) ? duplicate.index : position;
            const paymentRef = paymentByIndex.get(resolvedIndex) || paymentByIndex.get(position) || null;

            let amountValue = toNumeric(duplicate?.value);
            if (!Number.isFinite(amountValue) || Math.abs(amountValue) <= 0) {
              const paymentAmount = toNumeric(paymentRef?.amount);
              if (Number.isFinite(paymentAmount)) {
                amountValue = paymentAmount;
              }
            }

            let termDays = Number.isFinite(duplicate?.termDays) ? duplicate.termDays : null;
            if (!Number.isFinite(termDays) && Number.isFinite(paymentRef?.termDays)) {
              termDays = paymentRef.termDays;
            }

            let dueDateValue = duplicate?.dueDate || paymentRef?.dueDate || '';
            const dueInfo = normalizeDate(dueDateValue);
            if (!Number.isFinite(termDays) && emissionInfo.dateInput && dueInfo.dateInput) {
              const diff = computeInclusiveTermDays(emissionInfo.dateInput, dueInfo.dateInput);
              if (Number.isFinite(diff)) {
                termDays = diff;
              }
            }

            if ((!dueInfo.dateInput || !dueDateValue) && fallbackBaseDateInput) {
              let fallbackDays = Number.isFinite(termDays) ? termDays : null;
              if (!Number.isFinite(fallbackDays)) {
                if (Number.isFinite(paymentRef?.termDays)) {
                  fallbackDays = paymentRef.termDays;
                } else {
                  const paymentType = paymentRef?.type;
                  if (paymentType === '0') {
                    fallbackDays = 0;
                  } else if (paymentType === '1' || paymentType === '2') {
                    fallbackDays = (position + 1) * 30;
                  } else {
                    fallbackDays = position === 0 ? 0 : position * 30;
                  }
                }
              }
              if (Number.isFinite(fallbackDays)) {
                dueDateValue = addPaymentDaysToDateInput(fallbackBaseDateInput, fallbackDays);
                if (!Number.isFinite(termDays)) {
                  termDays = fallbackDays;
                }
              }
            }

            const normalizedDue = normalizeDate(dueDateValue);
            let resolvedTermDays = Number.isFinite(termDays) ? termDays : null;
            if (!Number.isFinite(resolvedTermDays) && emissionInfo.dateInput && normalizedDue.dateInput) {
              const diff = computeInclusiveTermDays(emissionInfo.dateInput, normalizedDue.dateInput);
              if (Number.isFinite(diff)) {
                resolvedTermDays = diff;
              }
            }

            const numberLabel = duplicate?.number || paymentRef?.number || `Parcela ${position + 1}`;
            const resolvedDueInput = normalizedDue.dateInput || dueDateValue || '';

            return {
              index: resolvedIndex,
              number: numberLabel,
              dueDate: resolvedDueInput,
              originalDueDate: resolvedDueInput,
              manualDueDate: duplicate?.manualDueDate || '',
              value: Number.isFinite(amountValue) ? amountValue : null,
              paymentMethod: duplicate?.paymentMethod || paymentRef?.method || '',
              paymentDescription:
                duplicate?.paymentDescription || paymentRef?.description || describePaymentMethod(paymentRef?.method),
              paymentType: duplicate?.paymentType || paymentRef?.type || '',
              termDays: Number.isFinite(resolvedTermDays) ? resolvedTermDays : null,
              bankAccount: duplicate?.bankAccount || null,
              bankAccountIsManual: Boolean(duplicate?.bankAccount),
            };
          });

          const references = nfRefElements
            .map((ref) => {
              const key = getText(ref, 'refNFe');
              if (key) {
                return {
                  type: 'NF-e referenciada',
                  model: '55',
                  accessKey: key,
                };
              }
              const refNF = ref.getElementsByTagName('refNF')[0];
              if (refNF) {
                return {
                  type: 'NF modelo 1/1A',
                  model: getText(refNF, 'mod'),
                  series: getText(refNF, 'serie'),
                  number: getText(refNF, 'nNF'),
                  emissionDate: getText(refNF, 'dEmi'),
                  issuerUf: getText(refNF, 'UF'),
                };
              }
              const refNFP = ref.getElementsByTagName('refNFP')[0];
              if (refNFP) {
                return {
                  type: 'NF produtor rural',
                  model: getText(refNFP, 'mod'),
                  series: getText(refNFP, 'serie'),
                  number: getText(refNFP, 'nNF'),
                  emissionDate: getText(refNFP, 'dEmi'),
                  issuerUf: getText(refNFP, 'UF'),
                  document: getText(refNFP, 'CPF') || getText(refNFP, 'CNPJ'),
                };
              }
              const refCTe = getText(ref, 'refCTe');
              if (refCTe) {
                return {
                  type: 'CT-e referenciado',
                  model: '57',
                  accessKey: refCTe,
                };
              }
              const refECF = ref.getElementsByTagName('refECF')[0];
              if (refECF) {
                return {
                  type: 'ECF referenciado',
                  model: getText(refECF, 'mod'),
                  number: getText(refECF, 'nECF'),
                  coo: getText(refECF, 'nCOO'),
                  series: getText(refECF, 'nserie'),
                };
              }
              return null;
            })
            .filter(Boolean);

          const totalsData = {
            totalValue: getText(total, 'vNF'),
            products: getText(total, 'vProd'),
            icmsBase: getText(total, 'vBC'),
            icmsValue: getText(total, 'vICMS'),
            icmsSt: getText(total, 'vST'),
            fcp: getText(total, 'vFCP'),
            fcpSt: getText(total, 'vFCPST'),
            fcpStRet: getText(total, 'vFCPSTRet'),
            discount: getText(total, 'vDesc'),
            other: getText(total, 'vOutro'),
            freight: getText(total, 'vFrete'),
            ipi: getText(total, 'vIPI'),
            ii: getText(total, 'vII'),
            insurance: getText(total, 'vSeg'),
            services: getText(total, 'vServ'),
          };

          const totalsNumeric = {
            totalValue: toNumeric(totalsData.totalValue),
            products: toNumeric(totalsData.products),
            freight: toNumeric(totalsData.freight),
            other: toNumeric(totalsData.other),
            insurance: toNumeric(totalsData.insurance),
            ipi: toNumeric(totalsData.ipi),
            ii: toNumeric(totalsData.ii),
            icmsSt: toNumeric(totalsData.icmsSt),
            fcp: toNumeric(totalsData.fcp),
            fcpSt: toNumeric(totalsData.fcpSt),
            fcpStRet: toNumeric(totalsData.fcpStRet),
          };

          const declaredCharges = [
            totalsNumeric.freight,
            totalsNumeric.other,
            totalsNumeric.insurance,
            totalsNumeric.ipi,
            totalsNumeric.ii,
            totalsNumeric.icmsSt,
            totalsNumeric.fcp,
            totalsNumeric.fcpSt,
            totalsNumeric.fcpStRet,
          ];

          const totalsMatchProducts =
            Number.isFinite(totalsNumeric.totalValue) &&
            Number.isFinite(totalsNumeric.products) &&
            Math.abs(totalsNumeric.totalValue - totalsNumeric.products) <= 0.0005;

          const hasDeclaredCharges = declaredCharges.some(
            (value) => Number.isFinite(value) && Math.abs(value) > 0.000001
          );

          const shouldSkipTaxComputation = totalsMatchProducts;

          alignItemsWithTotals(items, totalsData, { skipTaxComputation: shouldSkipTaxComputation });

          const processedItems = mergeItemsWithBonification(items);
          const bonificationTotal = computeBonificationTotal(processedItems);
          totalsData.bonification = Number.isFinite(bonificationTotal) ? bonificationTotal : null;

          const complementaryInfo = getText(infAdic, 'infCpl');
          const fiscalInfo = getText(infAdic, 'infAdFisco');
          const paymentConditionHint =
            extractPaymentConditionHint(complementaryInfo) || extractPaymentConditionHint(fiscalInfo);

          return {
            accessKey,
            ambient: getText(ide, 'tpAmb'),
            ide: {
              number: getText(ide, 'nNF'),
              serie: getText(ide, 'serie'),
              emissionDate,
              entryDate,
              natOp: getText(ide, 'natOp'),
              model: getText(ide, 'mod'),
              tpNF: getText(ide, 'tpNF'),
              tpEmis: getText(ide, 'tpEmis'),
              cfop,
              freightMode: getText(transp, 'modFrete'),
            },
            emit: {
              name: getText(emit, 'xNome'),
              fantasyName: getText(emit, 'xFant'),
              document: getText(emit, 'CNPJ') || getText(emit, 'CPF'),
              stateRegistration: getText(emit, 'IE'),
              email: getText(emit, 'email'),
              phone: getText(emit, 'fone'),
              address: addressFrom(emit?.getElementsByTagName('enderEmit')[0]),
            },
            dest: {
              name: getText(dest, 'xNome') || getText(dest, 'xFant'),
              document: getText(dest, 'CNPJ') || getText(dest, 'CPF'),
              stateRegistration: getText(dest, 'IE'),
              indIEDest: getText(dest, 'indIEDest'),
              email: getText(dest, 'email'),
              phone: getText(dest, 'fone'),
              address: addressFrom(dest?.getElementsByTagName('enderDest')[0]),
            },
            totals: totalsData,
            protocol: {
              number: getText(infProt, 'nProt'),
              receivedAt: getText(infProt, 'dhRecbto'),
              status: getText(infProt, 'cStat'),
            },
            transport: {
              mode: getText(transp, 'modFrete'),
              transporter: {
                name: getText(transporta, 'xNome'),
                document: getText(transporta, 'CNPJ') || getText(transporta, 'CPF'),
                stateRegistration: getText(transporta, 'IE'),
                uf: getText(transporta, 'UF'),
              },
              vehicle: {
                plate: getText(veicTransp, 'placa'),
                uf: getText(veicTransp, 'UF'),
              },
              volume: {
                quantity: getText(volElement, 'qVol'),
                species: getText(volElement, 'esp'),
                brand: getText(volElement, 'marca'),
                number: getText(volElement, 'nVol'),
                weightGross: getText(volElement, 'pesoB'),
                weightNet: getText(volElement, 'pesoL'),
              },
            },
            additionalInfo: {
              complementary: complementaryInfo,
              fiscal: fiscalInfo,
            },
            paymentConditionHint,
            payments,
            duplicates,
            references,
            items: processedItems,
          };
        };

        const processXmlFile = (file) => {
          if (!file) return;
          clearStatusMessages();
          productSupplierLinkCache.clear();
          productSupplierLinkPromises.clear();
          supplierReferenceLookupCache.clear();
          supplierReferenceLookupPromises.clear();
          supplierLinkErrorNotified = false;
          const extension = file.name.split('.').pop()?.toLowerCase();
          if (extension !== 'xml') {
            showFileFeedback('Selecione um arquivo XML autorizado pela SEFAZ (extensão .xml).', 'error');
            return;
          }
          showFileFeedback(`Lendo o arquivo ${file.name}...`, 'info');
          const reader = new FileReader();
          reader.onload = async () => {
            try {
              const result =
                typeof reader.result === 'string'
                  ? reader.result
                  : typeof TextDecoder !== 'undefined'
                  ? new TextDecoder('utf-8').decode(reader.result)
                  : '';
              if (!result) {
                throw new Error('Não foi possível interpretar o conteúdo do XML informado.');
              }
              const parsed = parseNfeXml(result);
              if (parsed && typeof parsed === 'object') {
                if (currentDraftId) parsed.draftId = currentDraftId;
                if (currentDraftCode) parsed.draftCode = currentDraftCode;
              }
              parsed.selectedCompanyId = companySelect ? companySelect.value || '' : '';
              parsed.selectedBankAccountId = bankAccountSelect ? bankAccountSelect.value || '' : '';
              parsed.selectedDepositId = depositSelect ? depositSelect.value || '' : '';
              const isBonusContext = importModalContext === IMPORT_CONTEXT_BONUS;

              if (!isBonusContext) {
                try {
                  const redirected = await handleExistingEntryRedirect(parsed);
                  if (redirected) {
                    return;
                  }
                } catch (duplicateError) {
                  console.error('Erro ao evitar importação duplicada da NF-e:', duplicateError);
                  showFileFeedback(
                    duplicateError?.message ||
                      'Não foi possível verificar se o XML já foi importado anteriormente.',
                    'error'
                  );
                  return;
                }
              }

              if (isBonusContext) {
                pendingBonusData = parsed;
              } else {
                lastNfeData = parsed;
              }
              updateSummaryFromData(parsed);
              if (isBonusContext) {
                showFileFeedback('Validando itens de bonificação...', 'info');
              } else {
                showFileFeedback('Validando fornecedor importado...', 'info');
                await handleSupplierSelection(parsed.emit);
                showFileFeedback('Validando produtos pelo fornecedor e código de barras...', 'info');
              }
              await validateImportedProducts(parsed);

              const nfNumberText = parsed.ide?.number ? `NF ${parsed.ide.number}` : 'NF-e';
              const emitterText = parsed.emit?.name || 'Emitente não identificado';
              const baseMessage = isBonusContext
                ? `XML de bonificação importado com sucesso. ${nfNumberText} - ${emitterText}.`
                : `XML importado com sucesso. ${nfNumberText} - ${emitterText}.`;
              const items = Array.isArray(parsed.items) ? parsed.items : [];
              const errorCount = items.filter((item) => item.validationStatus === 'error').length;
              const unmatchedCount = items.filter((item) => item.validationStatus === 'not-found').length;

              if (errorCount > 0) {
                const suffix = errorCount === 1 ? '' : 's';
                showFileFeedback(
                  `${baseMessage} Não foi possível validar ${errorCount} item${suffix} devido a uma falha na consulta.`,
                  'warning'
                );
              } else if (unmatchedCount > 0) {
                const suffix = unmatchedCount === 1 ? '' : 's';
                showFileFeedback(
                  `${baseMessage} ${unmatchedCount} produto${suffix} precisa${suffix ? 'm' : ''} ser cadastrado pelo código de barras.`,
                  'warning'
                );
              } else {
                showFileFeedback(baseMessage, 'success');
              }
            } catch (error) {
              console.error('Erro ao processar XML da NF-e:', error);
              showFileFeedback(error.message || 'Não foi possível processar o XML informado.', 'error');
            }
          };
          reader.onerror = () => {
            console.error('Erro ao ler o arquivo XML selecionado.', reader.error);
            showFileFeedback('Não foi possível ler o arquivo XML selecionado.', 'error');
          };
          reader.readAsText(file);
        };

        function trapFocus(event) {
          if (!importModal || importModal.classList.contains('hidden')) return;
          if (productIframeModal && !productIframeModal.classList.contains('hidden')) return;
          if (event.key !== 'Tab') return;

          const focusableElements = importModalCard
            ? Array.from(importModalCard.querySelectorAll(MODAL_FOCUSABLE_SELECTORS)).filter(
                (element) => element instanceof HTMLElement && element.offsetParent !== null
              )
            : [];
          if (focusableElements.length === 0) return;

          const firstElement = focusableElements[0];
          const lastElement = focusableElements[focusableElements.length - 1];

          if (event.shiftKey && document.activeElement === firstElement) {
            event.preventDefault();
            lastElement.focus();
          } else if (!event.shiftKey && document.activeElement === lastElement) {
            event.preventDefault();
            firstElement.focus();
          }
        }

        function openImportModal() {
          previouslyFocusedElement = document.activeElement;
          importModal.classList.remove('hidden');
          document.body.classList.add('overflow-hidden');
          setPendingPeriodDefaults();

          if (importModalCard) {
            importModalCard.classList.add('opacity-0', 'scale-95');
            requestAnimationFrame(() => {
              importModalCard.classList.remove('opacity-0', 'scale-95');
              importModalCard.classList.add('opacity-100', 'scale-100');
            });

            const focusableElements = importModalCard.querySelectorAll(MODAL_FOCUSABLE_SELECTORS);
            if (focusableElements.length) {
              focusableElements[0].focus();
            }
          }

          document.addEventListener('keydown', trapFocus);
        }

        function closeImportModal() {
          if (importModalCard) {
            importModalCard.classList.remove('opacity-100', 'scale-100');
            importModalCard.classList.add('opacity-0', 'scale-95');
          }

          if (!productIframeModal || productIframeModal.classList.contains('hidden')) {
            document.body.classList.remove('overflow-hidden');
          }
          document.removeEventListener('keydown', trapFocus);

          setTimeout(() => {
            importModal.classList.add('hidden');
            if (previouslyFocusedElement && typeof previouslyFocusedElement.focus === 'function') {
              previouslyFocusedElement.focus();
            }
          }, 180);
        }

        function activateImportTab(tabId) {
          importTabButtons.forEach((button) => {
            const isActive = button.dataset.importTab === tabId;
            button.classList.toggle('active', isActive);
            button.classList.toggle('bg-primary/10', isActive);
            button.classList.toggle('text-primary', isActive);
            button.classList.toggle('border', true);
            button.classList.toggle('border-transparent', isActive);
            button.classList.toggle('border-gray-200', !isActive);
            button.classList.toggle('text-gray-600', !isActive);
            button.classList.add('inline-flex', 'items-center', 'gap-2', 'rounded-lg', 'px-3', 'py-2', 'text-xs', 'font-semibold', 'transition');
          });

          importTabPanels.forEach((panel) => {
            panel.classList.toggle('hidden', panel.dataset.importTabPanel !== tabId);
          });
        }

        function updateImportMode() {
          const selectedRadio = importModal.querySelector('input[name="import-mode"]:checked');
          const selectedValue = selectedRadio ? selectedRadio.value : null;

          importModePanels.forEach((panel) => {
            const isActive = panel.dataset.importModePanel === selectedValue;
            panel.classList.toggle('hidden', !isActive);
          });

          clearStatusMessages();

          if (importFileInput) {
            importFileInput.value = '';
          }
        }

        const selectImportMode = (mode) => {
          let applied = false;
          importModeRadios.forEach((radio) => {
            if (radio.value === mode) {
              radio.checked = true;
              applied = true;
            } else if (radio.checked) {
              radio.checked = false;
            }
          });
          updateImportMode();
          return applied;
        };

        openImportModalButtons.forEach((button) => {
          button.addEventListener('click', (event) => {
            event.preventDefault();
            const context = button.dataset.importContext === IMPORT_CONTEXT_BONUS
              ? IMPORT_CONTEXT_BONUS
              : IMPORT_CONTEXT_FULL;
            setImportModalContext(context);
            openImportModal();
            activateImportTab('xml');
            if (context === IMPORT_CONTEXT_BONUS) {
              selectImportMode('file');
            } else {
              updateImportMode();
            }
          });
        });

        closeImportModalButtons.forEach((button) => {
          button.addEventListener('click', (event) => {
            event.preventDefault();
            closeImportModal();
          });
        });

        importModal.addEventListener('click', (event) => {
          const target = event.target;
          if (target instanceof Element && target.hasAttribute('data-close-import-modal')) {
            closeImportModal();
          }
        });

        document.addEventListener('keydown', (event) => {
          if (event.key === 'Escape') {
            if (codeLookupModal && !codeLookupModal.classList.contains('hidden')) {
              closeCodeLookupModal();
              return;
            }
            if (productIframeModal && !productIframeModal.classList.contains('hidden')) {
              return;
            }
            if (!importModal.classList.contains('hidden')) {
              closeImportModal();
            }
          }
        });

        if (refreshImportedProductsButton) {
          refreshImportedProductsButton.addEventListener('click', (event) => {
            event.preventDefault();
            refreshImportedProductsList();
          });
        }

        if (codeLookupModal) {
          codeLookupCloseTriggers.forEach((button) => {
            button.addEventListener('click', (event) => {
              event.preventDefault();
              closeCodeLookupModal();
            });
          });
          codeLookupModal.addEventListener('click', (event) => {
            const target = event.target;
            if (target instanceof Element && target.hasAttribute('data-close-code-modal')) {
              closeCodeLookupModal();
            }
          });
        }

        if (codeLookupTableBody) {
          codeLookupTableBody.addEventListener('click', (event) => {
            const row = event.target instanceof Element ? event.target.closest('[data-code-row]') : null;
            if (!row) return;
            const rowId = row.getAttribute('data-code-row-id');
            if (rowId) {
              event.preventDefault();
              handleCodeLookupRowSelection(rowId);
            }
          });
          codeLookupTableBody.addEventListener('keydown', (event) => {
            if (event.key !== 'Enter' && event.key !== ' ') return;
            const row = event.target instanceof Element ? event.target.closest('[data-code-row]') : null;
            if (!row) return;
            const rowId = row.getAttribute('data-code-row-id');
            if (rowId) {
              event.preventDefault();
              handleCodeLookupRowSelection(rowId);
            }
          });
        }

        if (codeLookupCompanySelect) {
          codeLookupCompanySelect.addEventListener('change', () => {
            const selectedCompany = codeLookupCompanySelect.value || '';
            codeLookupTableState.sort = { key: '', direction: 'asc' };
            loadCodeLookupList(selectedCompany).catch(() => {});
          });
        }

        if (nfeCodeInput) {
          const shouldOpenCodeLookup = (event) => {
            const ignoredKeys = ['Tab', 'Shift', 'Control', 'Alt', 'Meta', 'CapsLock', 'Escape'];
            if (ignoredKeys.includes(event.key)) return false;
            if (event.ctrlKey || event.metaKey || event.altKey) return false;
            return true;
          };

          nfeCodeInput.addEventListener('keydown', (event) => {
            if (!shouldOpenCodeLookup(event)) {
              return;
            }
            event.preventDefault();
            openCodeLookupModal();
          });

          nfeCodeInput.addEventListener('click', (event) => {
            event.preventDefault();
            openCodeLookupModal();
          });
        }

        if (companySelect) {
          companySelect.addEventListener('change', () => {
            const selectedCompany = companySelect.value || '';
            pendingCompanyId = '';
            if (lastNfeData) {
              lastNfeData.selectedCompanyId = selectedCompany;
            }
            pendingCompanyDocumentDigits = selectedCompany
              ? ''
              : lastNfeData && lastNfeData.dest?.document
              ? digitsOnly(lastNfeData.dest.document)
              : '';
            refreshDepositOptions({ preserveSelection: false }).catch(() => {});
            refreshBankAccountOptions({ preserveSelection: false }).catch(() => {});
          });
        }

        if (bankAccountSelect) {
          bankAccountSelect.addEventListener('change', () => {
            if (lastNfeData && Array.isArray(lastNfeData.duplicates)) {
              lastNfeData.selectedBankAccountId = bankAccountSelect.value || '';
            }
            syncBankAccountWithDuplicates();
          });
        }

        if (duplicataGenerateButton) {
          duplicataGenerateButton.addEventListener('click', (event) => {
            event.preventDefault();
            try {
              generateDuplicatasPreviewFromInputs();
            } catch (error) {
              console.error('Erro ao gerar a pré-visualização das duplicatas:', error);
              notify('Não foi possível gerar a pré-visualização das duplicatas. Verifique os campos e tente novamente.', 'error');
            }
          });
        }

        if (depositSelect) {
          depositSelect.addEventListener('change', () => {
            pendingDepositId = '';
            if (lastNfeData) {
              lastNfeData.selectedDepositId = depositSelect.value || '';
            }
          });
        }

        if (duplicatasTableBody) {
          duplicatasTableBody.addEventListener('change', (event) => {
            const target = event.target;
            if (
              !(
                target instanceof HTMLInputElement ||
                (typeof HTMLSelectElement !== 'undefined' && target instanceof HTMLSelectElement)
              )
            ) {
              return;
            }

            if (!lastNfeData || !Array.isArray(lastNfeData.duplicates)) return;

            const index = Number.parseInt(target.dataset.duplicateIndex || '', 10);
            if (!Number.isFinite(index)) return;
            const duplicate = lastNfeData.duplicates[index];
            if (!duplicate || typeof duplicate !== 'object') return;

            if (target.dataset.duplicateBankSelect === 'true') {
              const selectedValue = target.value ? String(target.value) : '';
              if (selectedValue) {
                duplicate.bankAccount = selectedValue;
                duplicate.bankAccountIsManual = true;
              } else {
                duplicate.bankAccount = null;
                duplicate.bankAccountIsManual = false;
              }
              return;
            }

            if (!(target instanceof HTMLInputElement)) return;

            if (target.dataset.duplicateValueInput === 'true') {
              const previousValue = Number.isFinite(toNumeric(duplicate?.value))
                ? toNumeric(duplicate.value)
                : Number.isFinite(toNumeric(duplicate?.originalValue))
                ? toNumeric(duplicate.originalValue)
                : null;

              const parsedValue = parseMoneyInputValue(target.value);
              if (!Number.isFinite(parsedValue) || parsedValue < 0) {
                if (Number.isFinite(previousValue)) {
                  target.value = formatMoneyValue(previousValue);
                } else {
                  target.value = '';
                }
                notify('Informe um valor válido para a parcela selecionada.', 'warning');
                return;
              }

              duplicate.value = parsedValue;
              duplicate.manualValue = parsedValue;
              if (!Number.isFinite(toNumeric(duplicate.originalValue))) {
                duplicate.originalValue = parsedValue;
              }

              target.value = formatMoneyValue(parsedValue);
              updateDuplicataSummaryFromData(lastNfeData);
              return;
            }

            if (target.dataset.duplicateDueInput !== 'true') return;

            const newDueValue = target.value || '';
            duplicate.manualDueDate = newDueValue || '';

            if (newDueValue) {
              duplicate.dueDate = newDueValue;
            } else if (duplicate.originalDueDate) {
              duplicate.dueDate = duplicate.originalDueDate;
            }

            const emissionInfo = normalizeDate(lastNfeData?.ide?.emissionDate);
            const entryInfo = normalizeDate(lastNfeData?.ide?.entryDate);
            const baseDateInput = emissionInfo.dateInput || entryInfo.dateInput || '';
            const effectiveDueInput = duplicate.dueDate || '';

            let computedTerm = null;
            if (baseDateInput && effectiveDueInput) {
              const diff = computeInclusiveTermDays(baseDateInput, effectiveDueInput);
              if (Number.isFinite(diff)) {
                computedTerm = diff;
              }
            }
            duplicate.termDays = Number.isFinite(computedTerm) ? computedTerm : null;

            const row = target.closest('tr');
            if (row) {
              const daysCell = row.querySelector('[data-duplicate-term]');
              if (daysCell) {
                const fallbackDiff = baseDateInput && effectiveDueInput
                  ? computeInclusiveTermDays(baseDateInput, effectiveDueInput)
                  : null;
                daysCell.textContent = Number.isFinite(duplicate.termDays)
                  ? String(duplicate.termDays)
                  : Number.isFinite(fallbackDiff)
                  ? String(fallbackDiff)
                  : '—';
              }
            }

            updateDuplicataSummaryFromData(lastNfeData);
          });
        }

        if (registerEntryButton) {
          registerEntryButton.addEventListener('click', async (event) => {
            event.preventDefault();
            if (isFormLocked) {
              notify('Esta NF-e já está aprovada e não pode ser alterada.', 'info');
              return;
            }
            if (isApprovingDraft) return;

            if (!companySelect || !companySelect.value) {
              notify('Selecione a empresa responsável antes de aprovar a nota.', 'warning');
              activateTab('dados');
              companySelect?.focus();
              return;
            }

            if (!depositSelect || !depositSelect.value) {
              notify('Selecione o depósito para lançar o estoque de entrada.', 'warning');
              activateTab('dados');
              depositSelect?.focus();
              return;
            }

            const supplierValue = supplierSelect?.value ? String(supplierSelect.value).trim() : '';
            if (!supplierValue) {
              notify('Associe o fornecedor cadastrado antes de aprovar a nota.', 'warning');
              activateTab('dados');
              supplierSelect?.focus();
              return;
            }

            const itemsSource =
              (Array.isArray(mainProductTableState.items) && mainProductTableState.items.length
                ? mainProductTableState.items
                : Array.isArray(lastNfeData?.items)
                ? lastNfeData.items
                : []) || [];

            if (!itemsSource.length) {
              notify('Nenhum item foi importado do XML. Revise os produtos antes de aprovar.', 'warning');
              activateTab('produtos');
              return;
            }

            const pendingItems = itemsSource.filter(
              (item) => !item || item.validationStatus !== 'matched' || !item.matchedProduct
            );
            if (pendingItems.length) {
              notify('Existem produtos sem vinculação ao cadastro. Resolva todos os itens antes de aprovar.', 'warning');
              activateTab('produtos');
              return;
            }

            const hasEntryStockDefined = itemsSource.some((item) =>
              Number.isFinite(toNumeric(item?.entryStockQuantity))
            );
            if (!hasEntryStockDefined) {
              notify('Revise o estoque de entrada dos produtos antes de aprovar.', 'warning');
              activateTab('produtos');
              return;
            }

            const duplicates = Array.isArray(lastNfeData?.duplicates) ? lastNfeData.duplicates : [];
            if (!duplicates.length) {
              notify('Informe as duplicatas da nota antes de aprovar.', 'warning');
              activateTab('duplicatas');
              return;
            }

            const supplierAccount = resolveSupplierAccountingAccount();
            if (!supplierAccount || !supplierAccount.id) {
              notify('Defina a conta contábil vinculada ao fornecedor antes de aprovar.', 'warning');
              activateTab('duplicatas');
              accountingAccountInput?.focus();
              return;
            }

            for (let index = 0; index < duplicates.length; index += 1) {
              const duplicate = duplicates[index];
              const dueInfo = normalizeDate(
                duplicate?.manualDueDate || duplicate?.dueDate || duplicate?.originalDueDate || ''
              );
              if (!dueInfo.dateInput) {
                notify(`Informe o vencimento da parcela ${duplicate?.number || index + 1}.`, 'warning');
                activateTab('duplicatas');
                focusDuplicateField(index, 'dueDate');
                return;
              }

              const valueNumeric = toNumeric(duplicate?.value);
              if (!Number.isFinite(valueNumeric) || valueNumeric <= 0) {
                notify(`Informe um valor válido para a parcela ${duplicate?.number || index + 1}.`, 'warning');
                activateTab('duplicatas');
                focusDuplicateField(index, 'value');
                return;
              }

              const duplicateBank = duplicate?.bankAccount || bankAccountSelect?.value || '';
              if (!duplicateBank) {
                notify(`Selecione a conta corrente da parcela ${duplicate?.number || index + 1}.`, 'warning');
                activateTab('duplicatas');
                focusDuplicateField(index, 'bankAccount');
                return;
              }
            }

            isApprovingDraft = true;
            setApproveButtonState(true);

            try {
              let payload = buildDraftPayloadFromForm();
              if (!currentDraftId) {
                const createHeaders = buildAuthHeaders();
                createHeaders.set('Content-Type', 'application/json');
                const createResponse = await fetch(nfeDraftsEndpoint, {
                  method: 'POST',
                  headers: createHeaders,
                  body: JSON.stringify(payload),
                });
                const createPayload = await createResponse.json().catch(() => ({}));
                if (createResponse.status === 401 || createResponse.status === 403) {
                  handleAuthError();
                }
                if (!createResponse.ok) {
                  const message =
                    createPayload?.message ||
                    createPayload?.error ||
                    `Não foi possível salvar o rascunho antes da aprovação (status ${createResponse.status}).`;
                  throw new Error(message);
                }
                const createdDraft = createPayload?.draft || null;
                if (!createdDraft) {
                  throw new Error('Resposta inesperada ao salvar o rascunho antes da aprovação.');
                }
                applyDraftResponseToState(createdDraft);
                payload = buildDraftPayloadFromForm();
              }

              const approvalHeaders = buildAuthHeaders();
              approvalHeaders.set('Content-Type', 'application/json');
              const approvalEndpoint = `${nfeDraftsEndpoint}/${currentDraftId}`;
              const approvalResponse = await fetch(`${approvalEndpoint}/approve`, {
                method: 'POST',
                headers: approvalHeaders,
                body: JSON.stringify(payload),
              });
              const approvalData = await approvalResponse.json().catch(() => ({}));

              if (approvalResponse.status === 401 || approvalResponse.status === 403) {
                handleAuthError();
              }

              if (!approvalResponse.ok) {
                const message =
                  approvalData?.message ||
                  approvalData?.error ||
                  `Não foi possível aprovar a entrada da NF-e (status ${approvalResponse.status}).`;
                if (approvalData?.details?.focusTab) {
                  activateTab(approvalData.details.focusTab);
                  if (
                    approvalData.details.focusTab === 'duplicatas' &&
                    Number.isInteger(approvalData.details.duplicateIndex) &&
                    approvalData.details.field
                  ) {
                    focusDuplicateField(approvalData.details.duplicateIndex, approvalData.details.field);
                  }
                }
                if (approvalData?.draft) {
                  applyDraftResponseToState(approvalData.draft);
                }
                throw new Error(message);
              }

              const approvedDraft = approvalData?.draft || null;
              if (approvedDraft) {
                applyDraftResponseToState(approvedDraft);
              } else {
                setDraftStatus('approved');
              }

              if (companySelect?.value) {
                loadCodeLookupList(companySelect.value, { forceReload: true }).catch(() => {});
              }

              notify('Entrada da NF-e aprovada com sucesso.', 'success');
            } catch (error) {
              console.error('Erro ao aprovar a entrada da NF-e:', error);
              notify(error?.message || 'Não foi possível aprovar a entrada da NF-e.', 'error');
              setFormLockState(determineDraftStatusKey(currentDraftStatus) === 'approved');
            } finally {
              isApprovingDraft = false;
              setApproveButtonState(false);
            }
          });
        }

        if (deleteEntryButton) {
          deleteEntryButton.addEventListener('click', async (event) => {
            event.preventDefault();
            if (isDeletingDraft) return;

            if (!currentDraftId) {
              notify('Nenhuma nota carregada para exclusão.', 'warning');
              return;
            }

            const statusKey = determineDraftStatusKey(currentDraftStatus);
            const confirmationMessage =
              statusKey === 'approved'
                ? 'Tem certeza que deseja excluir esta entrada de NF-e aprovada? As contas a pagar serão removidas e o estoque será estornado.'
                : 'Tem certeza que deseja excluir esta nota?';
            const confirmed = typeof window !== 'undefined' && typeof window.confirm === 'function'
              ? window.confirm(confirmationMessage)
              : true;
            if (!confirmed) {
              return;
            }

            try {
              isDeletingDraft = true;
              setDeleteButtonState(true);

              const headers = buildAuthHeaders();
              const response = await fetch(`${nfeDraftsEndpoint}/${currentDraftId}`, {
                method: 'DELETE',
                headers,
              });
              const result = await response.json().catch(() => ({}));

              if (response.status === 401 || response.status === 403) {
                handleAuthError();
              }

              if (!response.ok) {
                const message =
                  result?.message || `Falha ao excluir a entrada da NF-e (status ${response.status}).`;
                throw new Error(message);
              }

              const successMessage =
                statusKey === 'approved'
                  ? 'Entrada da NF-e aprovada excluída com sucesso.'
                  : 'Nota excluída com sucesso.';
              notify(successMessage, 'success');

              const activeCompanyId = companySelect?.value || '';
              resetImportedNfeState();
              if (activeCompanyId) {
                codeLookupCache.delete(activeCompanyId);
                loadCodeLookupList(activeCompanyId, { forceReload: true }).catch(() => {});
              }
            } catch (error) {
              console.error('Erro ao excluir a entrada da NF-e:', error);
              notify(error?.message || 'Não foi possível excluir a entrada da NF-e.', 'error');
            } finally {
              isDeletingDraft = false;
              setDeleteButtonState(false);
              updateDeleteButtonState(currentDraftStatus);
            }
          });
        }

        if (saveDraftButton) {
          saveDraftButton.addEventListener('click', async (event) => {
            event.preventDefault();
            if (isSavingDraft) return;

            if (!companySelect || !companySelect.value) {
              notify('Selecione a empresa responsável antes de salvar o rascunho.', 'warning');
              companySelect?.focus();
              return;
            }

            const payload = buildDraftPayloadFromForm();
            const headers = buildAuthHeaders();
            headers.set('Content-Type', 'application/json');

            const endpointUrl = currentDraftId
              ? `${nfeDraftsEndpoint}/${currentDraftId}`
              : nfeDraftsEndpoint;
            const method = currentDraftId ? 'PUT' : 'POST';

            const setSavingState = (isSaving) => {
              isSavingDraft = Boolean(isSaving);
              saveDraftButton.disabled = Boolean(isSaving);
              saveDraftButton.classList.toggle('opacity-60', Boolean(isSaving));
              saveDraftButton.classList.toggle('cursor-wait', Boolean(isSaving));
            };

            try {
              setSavingState(true);
              const response = await fetch(endpointUrl, {
                method,
                headers,
                body: JSON.stringify(payload),
              });
              const result = await response.json().catch(() => ({}));
              if (!response.ok) {
                const message =
                  result?.message ||
                  `Falha ao salvar o rascunho da NF-e (status ${response.status}).`;
                throw new Error(message);
              }

              const draftData = result?.draft || result;
              applyDraftResponseToState(draftData);
              if (companySelect && companySelect.value) {
                codeLookupCache.delete(companySelect.value);
              }
              const formattedCode = currentDraftCode ? formatDraftCode(currentDraftCode) : '';
              const successMessage = formattedCode
                ? `Rascunho salvo como código ${formattedCode}.`
                : 'Rascunho da nota salvo com sucesso.';
              notify(successMessage, 'success');
            } catch (error) {
              console.error('Erro ao salvar rascunho da NF-e:', error);
              notify(
                error?.message ||
                  'Não foi possível salvar o rascunho da nota. Verifique os dados e tente novamente.',
                'error'
              );
            } finally {
              setSavingState(false);
            }
          });
        }

        if (clearImportButton) {
          clearImportButton.addEventListener('click', (event) => {
            event.preventDefault();
            try {
              resetImportedNfeState();
              notify('Campos limpos. Pronto para uma nova importação.', 'info');
            } catch (error) {
              console.error('Erro ao limpar os dados importados da nota:', error);
              notify('Não foi possível limpar os dados importados. Atualize a página e tente novamente.', 'error');
            }
          });
        }

        if (pendingGenerateButton) {
          pendingGenerateButton.addEventListener('click', (event) => {
            event.preventDefault();
            requestPendingDocuments();
          });
        }

        if (pendingFiltersForm) {
          pendingFiltersForm.addEventListener('submit', (event) => {
            event.preventDefault();
            requestPendingDocuments();
          });
        }

        importTabButtons.forEach((button) => {
          button.addEventListener('click', () => {
            activateImportTab(button.dataset.importTab);
          });
        });

        importModeRadios.forEach((radio) => {
          radio.addEventListener('change', updateImportMode);
        });

        if (importFilePanel && importFileInput) {
          const toggleHover = (isActive) => {
            importFilePanel.classList.toggle('border-primary/60', isActive);
            importFilePanel.classList.toggle('bg-primary/5', isActive);
          };

          ['dragenter', 'dragover'].forEach((eventName) => {
            importFilePanel.addEventListener(eventName, (event) => {
              event.preventDefault();
              toggleHover(true);
            });
          });

          ['dragleave', 'dragend'].forEach((eventName) => {
            importFilePanel.addEventListener(eventName, (event) => {
              event.preventDefault();
              toggleHover(false);
            });
          });

          importFilePanel.addEventListener('drop', (event) => {
            event.preventDefault();
            toggleHover(false);
            if (!event.dataTransfer) return;
            const [file] = event.dataTransfer.files;
            if (file) {
              importFileInput.files = event.dataTransfer.files;
              processXmlFile(file);
            } else {
              clearStatusMessages();
            }
          });

          importFileInput.addEventListener('change', () => {
            const file = importFileInput.files && importFileInput.files[0];
            if (file) {
              processXmlFile(file);
            } else {
              clearStatusMessages();
            }
          });
        }

        const confirmImportButton = importModal.querySelector('[data-confirm-import]');
        const confirmImportIcon = confirmImportButton?.querySelector('[data-confirm-import-icon]') || null;
        const confirmImportText = confirmImportButton?.querySelector('[data-confirm-import-text]') || null;
        const defaultConfirmIconClass = confirmImportIcon ? confirmImportIcon.className : '';
        const defaultConfirmText = confirmImportText ? confirmImportText.textContent || '' : '';
        if (confirmImportButton) {
          const disableConfirmButton = () => {
            confirmImportButton.disabled = true;
            confirmImportButton.classList.add('cursor-wait', 'opacity-60');
          };
          const restoreConfirmButton = () => {
            confirmImportButton.disabled = false;
            confirmImportButton.classList.remove('cursor-wait', 'opacity-60');
          };

          confirmImportButton.addEventListener('click', async (event) => {
            event.preventDefault();
            if (importModalContext === IMPORT_CONTEXT_BONUS) {
              const bonusItems = Array.isArray(pendingBonusData?.items) ? pendingBonusData.items : [];
              if (!bonusItems.length) {
                notify('Importe um XML de bonificação válido antes de aplicar os itens.', 'warning');
                return;
              }

              disableConfirmButton();

              try {
                const merged = mergeBonusItemsIntoCurrentNote(pendingBonusData);
                if (!merged) {
                  notify('O XML de bonificação não possui itens aplicáveis.', 'warning');
                  return;
                }
                pendingBonusData = null;
                notify('Itens de bonificação adicionados à nota.', 'success');
                closeImportModal();
              } catch (error) {
                console.error('Erro ao aplicar bonificação na nota:', error);
                notify('Não foi possível aplicar os itens de bonificação. Tente novamente.', 'error');
              } finally {
                restoreConfirmButton();
              }
              return;
            }

            if (!lastNfeData) {
              notify('Importe um XML autorizado antes de aplicar os dados na nota.', 'warning');
              return;
            }

            const items = Array.isArray(lastNfeData.items) ? lastNfeData.items : [];
            if (!items.length) {
              notify('O XML informado não possui itens para importar.', 'warning');
              return;
            }

            const unresolvedItems = items.filter(
              (item) => item?.validationStatus !== 'matched' || !item?.matchedProduct
            );
            if (unresolvedItems.length) {
              notify(
                'Existem produtos sem cadastro confirmado. Cadastre ou vincule todos os itens antes de importar.',
                'warning'
              );
              return;
            }

            disableConfirmButton();

            try {
              await syncSupplierFactorsForItems(items, lastNfeData);
            } catch (error) {
              console.error('Erro ao atualizar fator dos produtos cadastrados:', error);
              notify(
                error?.message ||
                  'Não foi possível atualizar o fator dos produtos no cadastro. Tente novamente.',
                'error'
              );
              restoreConfirmButton();
              return;
            }

            try {
              applyImportedDataToMainForm(lastNfeData);
              notify('Dados do XML aplicados à entrada da nota.', 'success');
              closeImportModal();
            } catch (error) {
              console.error('Erro ao aplicar dados importados na nota:', error);
              notify('Não foi possível aplicar os dados do XML na nota. Tente novamente.', 'error');
            } finally {
              restoreConfirmButton();
            }
          });
        }

        indexExistingSupplierOptions();
        loadSuppliersFromApi().catch(() => {});
        refreshCompanyOptions({ preserveSelection: true })
          .then((result) => {
            const resolved = result || { value: '', changed: false };
            const selectedValue = resolved.value || '';
            const selectionChanged = Boolean(resolved.changed);
            if (!selectionChanged || !selectedValue) {
              refreshDepositOptions({ preserveSelection: true }).catch(() => {});
              refreshBankAccountOptions({ preserveSelection: true }).catch(() => {});
            }
          })
          .catch(() => {
            refreshDepositOptions({ preserveSelection: true }).catch(() => {});
            refreshBankAccountOptions({ preserveSelection: true }).catch(() => {});
          });

        window.addEventListener('focus', () => {
          const now = Date.now();
          if (now - supplierRegistry.lastLoadedAt > 15000) {
            loadSuppliersFromApi(true).catch(() => {});
          }
        });

        resetDraftState();
        updateSummaryFromData(null);
        setSupplierSummary(null);
        applyValidationStyles('info');
        activateImportTab('pending');
        updateImportMode();
      }
    });
  </script>
</body>
</html>
