{
    "sourceFile": "servidor/routes/shipping.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1756768887785,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1756768924285,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -195,8 +195,9 @@\n       for (const z of zones) {\r\n         if (z.tipo === 'bairro' && Array.isArray(z.bairros) && z.bairros.length) {\r\n           const ok = z.bairros.some(b => {\r\n             const bn = normalize(b);\r\n+            // bate exato ou por “contém” (cobre casos com sufixos como “RJ” etc.)\r\n             return bn === bNorm || bn.includes(bNorm) || bNorm.includes(bn);\r\n           });\r\n           if (ok) { freeReason = 'bairro'; break; }\r\n         }\r\n"
                }
            ],
            "date": 1756768887785,
            "name": "Commit-0",
            "content": "const express = require('express');\r\nconst router = express.Router();\r\nconst https = require('https');\r\nconst Store = require('../models/Store');\r\nconst Vehicle = require('../models/Vehicle');\r\nconst DeliveryZone = require('../models/DeliveryZone');\r\n\r\n// ===== Helpers =====\r\nconst geoCache = new Map(); // CEP(dígitos) -> { lat, lng }\r\n\r\nfunction toRad(x) { return x * Math.PI / 180; }\r\nfunction haversine(lat1, lon1, lat2, lon2) {\r\n  const R = 6371;\r\n  const dLat = toRad(lat2 - lat1);\r\n  const dLon = toRad(lon2 - lon1);\r\n  const a = Math.sin(dLat/2)**2 +\r\n    Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon/2)**2;\r\n  return 2 * R * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\r\n}\r\nfunction normalize(s = '') {\r\n  return s.toString()\r\n    .normalize('NFD').replace(/[\\u0300-\\u036f]/g, '') // tira acento\r\n    .toLowerCase()\r\n    .replace(/[^a-z0-9]/g, ''); // remove espaços, hífen, pontuação etc.\r\n}\r\nfunction pointInPolygon(point, polygon) {\r\n  if (!Array.isArray(polygon) || polygon.length < 3) return false;\r\n  const x = Number(point.lng), y = Number(point.lat);\r\n  let inside = false;\r\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\r\n    const xi = Number(polygon[i].lng), yi = Number(polygon[i].lat);\r\n    const xj = Number(polygon[j].lng), yj = Number(polygon[j].lat);\r\n    const intersect = ((yi > y) !== (yj > y)) &&\r\n      (x < (xj - xi) * (y - yi) / ((yj - yi) || 1e-12) + xi);\r\n    if (intersect) inside = !inside;\r\n  }\r\n  return inside;\r\n}\r\nfunction httpsJson(url, headers={}) {\r\n  return new Promise((resolve, reject) => {\r\n    https.get(url, { headers }, (res) => {\r\n      let data = '';\r\n      res.on('data', c => data += c);\r\n      res.on('end', () => {\r\n        try { resolve(JSON.parse(data)); }\r\n        catch (e) { reject(e); }\r\n      });\r\n    }).on('error', reject);\r\n  });\r\n}\r\n\r\n// OpenStreetMap (Nominatim)\r\nasync function geocodeByPostalCode(cepDigits) {\r\n  const url = `https://nominatim.openstreetmap.org/search?format=json&country=Brazil&postalcode=${encodeURIComponent(cepDigits)}&limit=1`;\r\n  const headers = { 'User-Agent': 'EoBichoShipping/1.0 (frete@eobicho.local)' };\r\n  const json = await httpsJson(url, headers);\r\n  if (Array.isArray(json) && json.length) {\r\n    return { lat: parseFloat(json[0].lat), lng: parseFloat(json[0].lon) };\r\n  }\r\n  throw new Error('CEP sem resultado no Nominatim (postalcode).');\r\n}\r\nasync function geocodeByAddress(q) {\r\n  const url = `https://nominatim.openstreetmap.org/search?format=json&limit=1&q=${encodeURIComponent(q)}`;\r\n  const headers = { 'User-Agent': 'EoBichoShipping/1.0 (frete@eobicho.local)' };\r\n  const json = await httpsJson(url, headers);\r\n  if (Array.isArray(json) && json.length) {\r\n    return { lat: parseFloat(json[0].lat), lng: parseFloat(json[0].lon) };\r\n  }\r\n  throw new Error('Endereço sem resultado no Nominatim (q).');\r\n}\r\n\r\n// ViaCEP\r\nasync function viaCep(cepDigits) {\r\n  const url = `https://viacep.com.br/ws/${encodeURIComponent(cepDigits)}/json/`;\r\n  const json = await httpsJson(url);\r\n  if (json && !json.erro) return json;\r\n  throw new Error('CEP não encontrado no ViaCEP.');\r\n}\r\n\r\n// Resolve coords + bairro com múltiplos fallbacks\r\nasync function resolveCoordsAndBairro(cepRaw, bairroFromQuery) {\r\n  const cepDigits = (cepRaw || '').replace(/\\D/g, '');\r\n  if (!cepDigits || cepDigits.length !== 8) {\r\n    throw new Error('CEP inválido.');\r\n  }\r\n  if (geoCache.has(cepDigits)) {\r\n    const cached = geoCache.get(cepDigits);\r\n    return { ...cached, bairro: bairroFromQuery || cached.bairro || '' };\r\n  }\r\n\r\n  let bairro = bairroFromQuery || '';\r\n  let coords = null;\r\n\r\n  // 1) tenta por postalcode\r\n  try {\r\n    coords = await geocodeByPostalCode(cepDigits);\r\n  } catch (_) { /* continua */ }\r\n\r\n  // 2) ViaCEP -> endereço completo\r\n  let vc = null;\r\n  try {\r\n    vc = await viaCep(cepDigits);\r\n    if (!bairro) bairro = vc.bairro || '';\r\n    if (!coords) {\r\n      const parts = [\r\n        vc.logradouro || '',\r\n        bairro || vc.bairro || '',\r\n        vc.localidade || '',\r\n        vc.uf || '',\r\n        'Brasil',\r\n        cepDigits\r\n      ].filter(Boolean).join(', ');\r\n      coords = await geocodeByAddress(parts);\r\n    }\r\n  } catch (_) { /* continua */ }\r\n\r\n  // 3) Centro da cidade (fallback final)\r\n  if (!coords && vc && (vc.localidade || vc.uf)) {\r\n    const partsCity = [vc.localidade || '', vc.uf || '', 'Brasil'].filter(Boolean).join(', ');\r\n    coords = await geocodeByAddress(partsCity);\r\n  }\r\n\r\n  if (!coords) {\r\n    throw new Error('Não foi possível geocodificar o CEP.');\r\n  }\r\n\r\n  geoCache.set(cepDigits, { ...coords, bairro: bairro || (vc && vc.bairro) || '' });\r\n  return { ...coords, bairro: bairro || (vc && vc.bairro) || '' };\r\n}\r\n\r\n// ===== Rota principal =====\r\nrouter.get('/quote', async (req, res) => {\r\n  try {\r\n    const cepRaw = (req.query.cep || '').trim();\r\n    let bairro = (req.query.bairro || '').trim();\r\n    let lat = req.query.lat ? parseFloat(req.query.lat) : null;\r\n    let lng = req.query.lng ? parseFloat(req.query.lng) : null;\r\n\r\n    if (!cepRaw) return res.status(400).json({ message: 'Informe o CEP.' });\r\n\r\n    // Resolve coords/bairro (com fallbacks)\r\n    if (!(lat && lng) || !bairro) {\r\n      const r = await resolveCoordsAndBairro(cepRaw, bairro);\r\n      lat = lat ?? r.lat;\r\n      lng = lng ?? r.lng;\r\n      bairro = bairro || r.bairro || '';\r\n    }\r\n\r\n    // Lojas com geo\r\n    const stores = await Store.find({\r\n      latitude: { $ne: null },\r\n      longitude: { $ne: null }\r\n    });\r\n    if (!stores.length) {\r\n      return res.status(400).json({ message: 'Nenhuma loja com localização cadastrada.' });\r\n    }\r\n\r\n    // Loja mais próxima\r\n    let nearest = null, minDist = Infinity;\r\n    stores.forEach(st => {\r\n      if (typeof st.latitude === 'number' && typeof st.longitude === 'number') {\r\n        const d = haversine(lat, lng, st.latitude, st.longitude);\r\n        if (d < minDist) { minDist = d; nearest = st; }\r\n      }\r\n    });\r\n    if (!nearest) {\r\n      return res.status(400).json({ message: 'Não foi possível determinar a loja mais próxima.' });\r\n    }\r\n\r\n    // Zonas grátis (raio, polígono, bairro) da loja\r\n    const zones = await DeliveryZone.find({ store: nearest._id, gratis: true });\r\n\r\n    const p = { lat, lng };\r\n    let freeReason = null;\r\n\r\n    // 1) Raio\r\n    for (const z of zones) {\r\n      if ((z.tipo === 'raio' || z.raioKm) && Number(z.raioKm) > 0) {\r\n        if (minDist <= Number(z.raioKm) + 1e-9) { freeReason = 'raio'; break; }\r\n      }\r\n    }\r\n    // 2) Polígono (mapa)\r\n    if (!freeReason) {\r\n      for (const z of zones) {\r\n        const poly = Array.isArray(z.polygon) ? z.polygon\r\n                  : (Array.isArray(z.poligono) ? z.poligono : null);\r\n        if (poly && poly.length >= 3 && pointInPolygon(p, poly)) {\r\n          freeReason = 'mapa'; break;\r\n        }\r\n      }\r\n    }\r\n    // 3) Bairro\r\n    if (!freeReason && bairro) {\r\n      const bNorm = normalize(bairro);\r\n      for (const z of zones) {\r\n        if (z.tipo === 'bairro' && Array.isArray(z.bairros) && z.bairros.length) {\r\n          const ok = z.bairros.some(b => {\r\n            const bn = normalize(b);\r\n            return bn === bNorm || bn.includes(bNorm) || bNorm.includes(bn);\r\n          });\r\n          if (ok) { freeReason = 'bairro'; break; }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Veículo mais barato (taxaMin + taxaKm * km)\r\n    const vehicles = await Vehicle.find({});\r\n    if (!vehicles.length) {\r\n      return res.status(400).json({ message: 'Nenhum veículo configurado no admin.' });\r\n    }\r\n\r\n    const distKm = minDist;\r\n    const arred2 = (n) => Math.round((Number(n) + Number.EPSILON) * 100) / 100;\r\n\r\n    let padrao = Infinity;\r\n    vehicles.forEach(v => {\r\n      const custo = Number(v.taxaMin || 0) + Number(v.taxaKm || 0) * distKm;\r\n      if (custo < padrao) padrao = custo;\r\n    });\r\n    if (!isFinite(padrao)) padrao = 0;\r\n    if (freeReason) padrao = 0;\r\n\r\n    const express  = freeReason ? 0 : padrao * 2;\r\n    const agendada = freeReason ? 0 : padrao * 0.9;\r\n\r\n    res.json({\r\n      store: {\r\n        id: nearest._id,\r\n        nome: nearest.nome,\r\n        latitude: nearest.latitude,\r\n        longitude: nearest.longitude,\r\n        endereco: nearest.endereco,\r\n        cep: nearest.cep\r\n      },\r\n      address: { cep: cepRaw, bairro, lat, lng },\r\n      distanceKm: arred2(distKm),\r\n      freeReason,\r\n      methods: {\r\n        padrao:   { label: 'Padrão',   price: arred2(padrao) },\r\n        express:  { label: 'Express',  price: arred2(express) },\r\n        agendada: { label: 'Agendada', price: arred2(agendada) },\r\n        pickup:   { label: 'Retire na loja', price: 0 }\r\n      }\r\n    });\r\n  } catch (err) {\r\n    console.error('Erro em /shipping/quote:', err);\r\n    const msg = /geocodificar|CEP inválido|ViaCEP/.test(String(err && err.message))\r\n      ? (err.message || 'CEP inválido.')\r\n      : 'Erro ao calcular frete.';\r\n    // 400 para erros de CEP, 500 para demais\r\n    const status = /geocodificar|CEP inválido|ViaCEP/.test(String(err && err.message)) ? 400 : 500;\r\n    res.status(status).json({ message: msg });\r\n  }\r\n});\r\n\r\nmodule.exports = router;\r\n"
        }
    ]
}