{
    "sourceFile": "servidor/routes/auth.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 10,
            "patches": [
                {
                    "date": 1756570256421,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1756570316140,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -113,9 +113,9 @@\n         user: {\r\n             id: user._id,\r\n             nome: user.nomeCompleto || user.razaoSocial || user.username,\r\n             email: user.email,\r\n-            role: user.role   // <-- ADICIONE ESTA LINHA\r\n+            role: user.role\r\n         }\r\n         });\r\n     } catch (error) {\r\n         res.status(500).json({ message: 'Erro no servidor.' });\r\n"
                },
                {
                    "date": 1756579207235,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,164 +1,183 @@\n const express = require('express');\r\n const router = express.Router();\r\n const bcrypt = require('bcryptjs');\r\n+const jwt = require('jsonwebtoken');\r\n const User = require('../models/User');\r\n const { body, validationResult } = require('express-validator');\r\n-const { cpf, cnpj } = require('cpf-cnpj-validator'); \r\n+const { cpf, cnpj } = require('cpf-cnpj-validator');\r\n+const requireAuth = require('../middlewares/requireAuth');\r\n \r\n const registerValidationRules = [\r\n-    body('nomeCompleto').if(body('tipoConta').equals('pessoa_fisica')).notEmpty().withMessage('O nome completo é obrigatório.').isLength({ min: 3 }).withMessage('O nome deve ter pelo menos 3 caracteres.'),\r\n-    body('razaoSocial').if(body('tipoConta').equals('pessoa_juridica')).notEmpty().withMessage('A razão social é obrigatória.'),\r\n-    body('email').notEmpty().withMessage('O e-mail é obrigatório.').isEmail().withMessage('Por favor, insira um e-mail válido.').normalizeEmail(),\r\n-    body('celular').notEmpty().withMessage('O número de celular é obrigatório.'),\r\n-    body('senha').isLength({ min: 8 }).withMessage('A senha deve ter no mínimo 8 caracteres.').matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d).+$/).withMessage('A senha deve conter pelo menos uma letra maiúscula, uma minúscula e um número.'),\r\n-    body('confirm_password').notEmpty().withMessage('A confirmação de senha é obrigatória.').custom((value, { req }) => { if (value !== req.body.senha) { throw new Error('As senhas não coincidem. Por favor, tente novamente.'); } return true; }),\r\n-    body('cpf').if(body('tipoConta').equals('pessoa_fisica')).notEmpty().withMessage('O CPF é obrigatório.').custom((value) => { if (!cpf.isValid(value)) { throw new Error('O CPF inserido não é válido.'); } return true; }),\r\n-    body('cnpj').if(body('tipoConta').equals('pessoa_juridica')).notEmpty().withMessage('O CNPJ é obrigatório.').custom((value) => { if (!cnpj.isValid(value)) { throw new Error('O CNPJ inserido não é válido.'); } return true; }),\r\n-    body('terms').equals('on').withMessage('Você deve concordar com os termos e condições para se registar.'),\r\n-    body('inscricaoEstadual').if(body('tipoConta').equals('pessoa_juridica')).if(body('isentoIE').not().exists()).notEmpty().withMessage('A Inscrição Estadual é obrigatória quando não isento.'),\r\n+  body('nomeCompleto').if(body('tipoConta').equals('pessoa_fisica')).notEmpty().withMessage('O nome completo é obrigatório.').isLength({ min: 3 }).withMessage('O nome deve ter pelo menos 3 caracteres.'),\r\n+  body('razaoSocial').if(body('tipoConta').equals('pessoa_juridica')).notEmpty().withMessage('A razão social é obrigatória.'),\r\n+  body('email').notEmpty().withMessage('O e-mail é obrigatório.').isEmail().withMessage('Por favor, insira um e-mail válido.').normalizeEmail(),\r\n+  body('celular').notEmpty().withMessage('O número de celular é obrigatório.'),\r\n+  body('senha').isLength({ min: 8 }).withMessage('A senha deve ter no mínimo 8 caracteres.').matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d).+$/).withMessage('A senha deve conter pelo menos uma letra maiúscula, uma minúscula e um número.'),\r\n+  body('confirm_password').notEmpty().withMessage('A confirmação de senha é obrigatória.').custom((value, { req }) => { if (value !== req.body.senha) { throw new Error('As senhas não coincidem. Por favor, tente novamente.'); } return true; }),\r\n+  body('cpf').if(body('tipoConta').equals('pessoa_fisica')).notEmpty().withMessage('O CPF é obrigatório.').custom((value) => { if (!cpf.isValid(value)) { throw new Error('O CPF inserido não é válido.'); } return true; }),\r\n+  body('cnpj').if(body('tipoConta').equals('pessoa_juridica')).notEmpty().withMessage('O CNPJ é obrigatório.').custom((value) => { if (!cnpj.isValid(value)) { throw new Error('O CNPJ inserido não é válido.'); } return true; }),\r\n+  body('terms').equals('on').withMessage('Você deve concordar com os termos e condições para se registar.'),\r\n+  body('inscricaoEstadual').if(body('tipoConta').equals('pessoa_juridica')).if(body('isentoIE').not().exists()).notEmpty().withMessage('A Inscrição Estadual é obrigatória quando não isento.'),\r\n ];\r\n \r\n+// ROTA: POST /api/register\r\n router.post('/register', registerValidationRules, async (req, res) => {\r\n-    const errors = validationResult(req);\r\n-    if (!errors.isEmpty()) {\r\n-        return res.status(400).json({ errors: errors.array() });\r\n-    }\r\n+  const errors = validationResult(req);\r\n+  if (!errors.isEmpty()) {\r\n+    return res.status(400).json({ errors: errors.array() });\r\n+  }\r\n \r\n-    try {\r\n-        const { email, celular, cpf: reqCpf, cnpj: reqCnpj } = req.body;\r\n+  try {\r\n+    const { email, celular, cpf: reqCpf, cnpj: reqCnpj } = req.body;\r\n \r\n-        const conditions = [{ email }, { celular }];\r\n-        if (reqCpf) conditions.push({ cpf: reqCpf });\r\n-        if (reqCnpj) conditions.push({ cnpj: reqCnpj });\r\n+    const conditions = [{ email }, { celular }];\r\n+    if (reqCpf) conditions.push({ cpf: reqCpf });\r\n+    if (reqCnpj) conditions.push({ cnpj: reqCnpj });\r\n \r\n-        const userExists = await User.findOne({ $or: conditions });\r\n+    const userExists = await User.findOne({ $or: conditions });\r\n \r\n-        if (userExists) {\r\n-            let field, message;\r\n-            if (userExists.email === email) {\r\n-                field = 'email';\r\n-                message = 'Este email já está a ser utilizado.';\r\n-            } else if (userExists.celular === celular) {\r\n-                field = 'celular';\r\n-                message = 'Este número de celular já está a ser utilizado.';\r\n-            } else if (reqCpf && userExists.cpf === reqCpf) {\r\n-                field = 'cpf';\r\n-                message = 'Este CPF já está a ser utilizado.';\r\n-            } else if (reqCnpj && userExists.cnpj === reqCnpj) {\r\n-                field = 'cnpj';\r\n-                message = 'Este CNPJ já está a ser utilizado.';\r\n-            }\r\n+    if (userExists) {\r\n+      let field, message;\r\n+      if (userExists.email === email) {\r\n+        field = 'email';\r\n+        message = 'Este email já está a ser utilizado.';\r\n+      } else if (userExists.celular === celular) {\r\n+        field = 'celular';\r\n+        message = 'Este número de celular já está a ser utilizado.';\r\n+      } else if (reqCpf && userExists.cpf === reqCpf) {\r\n+        field = 'cpf';\r\n+        message = 'Este CPF já está a ser utilizado.';\r\n+      } else if (reqCnpj && userExists.cnpj === reqCnpj) {\r\n+        field = 'cnpj';\r\n+        message = 'Este CNPJ já está a ser utilizado.';\r\n+      }\r\n \r\n-            if (field) {\r\n-                return res.status(400).json({\r\n-                    errors: [{\r\n-                        path: field,\r\n-                        msg: message,\r\n-                    }]\r\n-                });\r\n-            }\r\n-        }\r\n-        \r\n-        const salt = await bcrypt.genSalt(10);\r\n-        const hashedPassword = await bcrypt.hash(req.body.senha, salt);\r\n-        const isento = req.body.isentoIE === 'on';\r\n-        const newUser = new User({\r\n-            tipoConta: req.body.tipoConta,\r\n-            email: req.body.email,\r\n-            senha: hashedPassword,\r\n-            celular: req.body.celular,\r\n-            telefone: req.body.telefone,\r\n-            nomeCompleto: req.body.nomeCompleto,\r\n-            cpf: req.body.cpf,\r\n-            genero: req.body.genero,\r\n-            dataNascimento: req.body.dataNascimento,\r\n-            razaoSocial: req.body.razaoSocial,\r\n-            cnpj: req.body.cnpj,\r\n-            nomeContato: req.body.nomeContato,\r\n-            inscricaoEstadual: req.body.inscricaoEstadual,\r\n-            estadoIE: req.body.estadoIE,\r\n-            isentoIE: isento,\r\n+      if (field) {\r\n+        return res.status(400).json({\r\n+          errors: [{ path: field, msg: message }]\r\n         });\r\n+      }\r\n+    }\r\n \r\n-        const savedUser = await newUser.save();\r\n+    const salt = await bcrypt.genSalt(10);\r\n+    const hashedPassword = await bcrypt.hash(req.body.senha, salt);\r\n+    const isento = req.body.isentoIE === 'on';\r\n \r\n-        res.status(201).json({ \r\n-            message: 'Utilizador registado com sucesso!', \r\n-            user: { id: savedUser._id, nome: savedUser.nomeCompleto || savedUser.razaoSocial } \r\n-        });\r\n+    const newUser = new User({\r\n+      tipoConta: req.body.tipoConta,\r\n+      email: req.body.email,\r\n+      senha: hashedPassword,\r\n+      celular: req.body.celular,\r\n+      telefone: req.body.telefone,\r\n+      nomeCompleto: req.body.nomeCompleto,\r\n+      cpf: req.body.cpf,\r\n+      genero: req.body.genero,\r\n+      dataNascimento: req.body.dataNascimento,\r\n+      razaoSocial: req.body.razaoSocial,\r\n+      cnpj: req.body.cnpj,\r\n+      nomeContato: req.body.nomeContato,\r\n+      inscricaoEstadual: req.body.inscricaoEstadual,\r\n+      estadoIE: req.body.estadoIE,\r\n+      isentoIE: isento,\r\n+      role: 'cliente' // sempre cliente por padrão\r\n+    });\r\n \r\n-    } catch (error) {\r\n-        console.error(error);\r\n-        if (error.code === 11000) {\r\n-            return res.status(400).json({ errors: [{ path: 'geral', msg: 'Um dos dados inseridos (email, CPF, CNPJ ou celular) já está em uso.' }] });\r\n-        }\r\n-        res.status(500).json({ message: 'Erro no servidor. Tente novamente mais tarde.' });\r\n+    const savedUser = await newUser.save();\r\n+\r\n+    res.status(201).json({\r\n+      message: 'Utilizador registado com sucesso!',\r\n+      user: {\r\n+        id: savedUser._id,\r\n+        nome: savedUser.nomeCompleto || savedUser.razaoSocial,\r\n+        role: savedUser.role\r\n+      }\r\n+    });\r\n+\r\n+  } catch (error) {\r\n+    console.error(error);\r\n+    if (error.code === 11000) {\r\n+      return res.status(400).json({\r\n+        errors: [{ path: 'geral', msg: 'Um dos dados inseridos (email, CPF, CNPJ ou celular) já está em uso.' }]\r\n+      });\r\n     }\r\n+    res.status(500).json({ message: 'Erro no servidor. Tente novamente mais tarde.' });\r\n+  }\r\n });\r\n \r\n-\r\n // ROTA: POST /api/login\r\n router.post('/login', async (req, res) => {\r\n-    const { identifier, senha } = req.body;\r\n-    try {\r\n-        const user = await User.findOne({\r\n-            $or: [{ email: identifier }, { cpf: identifier }, { cnpj: identifier }]\r\n-        });\r\n-        if (!user || !(await bcrypt.compare(senha, user.senha))) {\r\n-            return res.status(400).json({ message: 'Credenciais inválidas.' });\r\n-        }\r\n-        res.status(200).json({\r\n-        message: 'Login bem-sucedido!',\r\n-        token,\r\n-        user: {\r\n-            id: user._id,\r\n-            nome: user.nomeCompleto || user.razaoSocial || user.username,\r\n-            email: user.email,\r\n-            role: user.role\r\n-        }\r\n-        });\r\n-    } catch (error) {\r\n-        res.status(500).json({ message: 'Erro no servidor.' });\r\n+  const { identifier, senha } = req.body;\r\n+  try {\r\n+    const user = await User.findOne({\r\n+      $or: [{ email: identifier }, { cpf: identifier }, { cnpj: identifier }]\r\n+    });\r\n+    if (!user || !(await bcrypt.compare(senha, user.senha))) {\r\n+      return res.status(400).json({ message: 'Credenciais inválidas.' });\r\n     }\r\n+\r\n+    // gera JWT com id, email e role\r\n+    const payload = { id: user._id, email: user.email, role: user.role };\r\n+    const token = jwt.sign(payload, process.env.JWT_SECRET, { expiresIn: '7d' });\r\n+\r\n+    res.status(200).json({\r\n+      message: 'Login bem-sucedido!',\r\n+      token,\r\n+      user: {\r\n+        id: user._id,\r\n+        nome: user.nomeCompleto || user.razaoSocial || user.username,\r\n+        email: user.email,\r\n+        role: user.role\r\n+      }\r\n+    });\r\n+  } catch (error) {\r\n+    console.error('Erro no login:', error);\r\n+    res.status(500).json({ message: 'Erro no servidor.' });\r\n+  }\r\n });\r\n \r\n-// DESCRIÇÃO: Busca os dados de um utilizador específico pelo seu ID\r\n-router.get('/users/:id', async (req, res) => {\r\n+// GET /api/users/:id -> Busca os dados de um utilizador\r\n+router.get('/users/:id', requireAuth, async (req, res) => {\r\n   try {\r\n+    if (req.user.id !== req.params.id && req.user.role !== 'admin_master') {\r\n+      return res.status(403).json({ message: 'Acesso negado' });\r\n+    }\r\n+\r\n     const user = await User.findById(req.params.id).select('-senha');\r\n     if (!user) {\r\n       return res.status(404).json({ message: 'Utilizador não encontrado.' });\r\n     }\r\n \r\n     res.status(200).json(user);\r\n-    \r\n+\r\n   } catch (error) {\r\n     console.error(error);\r\n     res.status(500).json({ message: 'Erro no servidor.' });\r\n   }\r\n });\r\n \r\n-// DESCRIÇÃO: Atualiza os dados de um utilizador existente\r\n-router.put('/users/:id', async (req, res) => {\r\n+// PUT /api/users/:id -> Atualiza utilizador\r\n+router.put('/users/:id', requireAuth, async (req, res) => {\r\n   try {\r\n+    if (req.user.id !== req.params.id && req.user.role !== 'admin_master') {\r\n+      return res.status(403).json({ message: 'Acesso negado' });\r\n+    }\r\n+\r\n     const userId = req.params.id;\r\n     const updateData = req.body;\r\n \r\n-    // Encontra o utilizador pelo ID e atualiza-o com os novos dados\r\n-    // { new: true } garante que a variável updatedUser contenha o documento já atualizado\r\n     const updatedUser = await User.findByIdAndUpdate(userId, updateData, { new: true }).select('-senha');\r\n \r\n     if (!updatedUser) {\r\n-      return res.status(404).json({ message: 'Utilizador não encontrado.' });\r\n+      return res.status(404).json({ message: 'Utilizador não encontrado' });\r\n     }\r\n \r\n-    // Se a atualização for bem-sucedida, envia uma resposta de sucesso com os dados atualizados\r\n     res.status(200).json({\r\n       message: 'Dados atualizados com sucesso!',\r\n       user: {\r\n         id: updatedUser._id,\r\n-        nome: updatedUser.nomeCompleto || updatedUser.razaoSocial\r\n+        nome: updatedUser.nomeCompleto || updatedUser.razaoSocial,\r\n+        role: updatedUser.role\r\n       }\r\n     });\r\n \r\n   } catch (error) {\r\n@@ -166,6 +185,5 @@\n     res.status(500).json({ message: 'Erro no servidor. Tente novamente mais tarde.' });\r\n   }\r\n });\r\n \r\n-// Exporta o router para que o nosso server.js o possa usar\r\n-module.exports = router;\n\\ No newline at end of file\n+module.exports = router;\r\n"
                },
                {
                    "date": 1756582355794,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -105,35 +105,38 @@\n });\r\n \r\n // ROTA: POST /api/login\r\n router.post('/login', async (req, res) => {\r\n-  const { identifier, senha } = req.body;\r\n-  try {\r\n-    const user = await User.findOne({\r\n-      $or: [{ email: identifier }, { cpf: identifier }, { cnpj: identifier }]\r\n-    });\r\n-    if (!user || !(await bcrypt.compare(senha, user.senha))) {\r\n-      return res.status(400).json({ message: 'Credenciais inválidas.' });\r\n-    }\r\n+    const { identifier, senha } = req.body;\r\n+    try {\r\n+        const user = await User.findOne({\r\n+            $or: [{ email: identifier }, { cpf: identifier }, { cnpj: identifier }]\r\n+        });\r\n \r\n-    // gera JWT com id, email e role\r\n-    const payload = { id: user._id, email: user.email, role: user.role };\r\n-    const token = jwt.sign(payload, process.env.JWT_SECRET, { expiresIn: '7d' });\r\n+        if (!user || !(await bcrypt.compare(senha, user.senha))) {\r\n+            return res.status(400).json({ message: 'Credenciais inválidas.' });\r\n+        }\r\n \r\n-    res.status(200).json({\r\n-      message: 'Login bem-sucedido!',\r\n-      token,\r\n-      user: {\r\n-        id: user._id,\r\n-        nome: user.nomeCompleto || user.razaoSocial || user.username,\r\n-        email: user.email,\r\n-        role: user.role\r\n-      }\r\n-    });\r\n-  } catch (error) {\r\n-    console.error('Erro no login:', error);\r\n-    res.status(500).json({ message: 'Erro no servidor.' });\r\n-  }\r\n+        // Gera o token JWT\r\n+        const token = jwt.sign(\r\n+            { id: user._id, role: user.role },\r\n+            process.env.JWT_SECRET,\r\n+            { expiresIn: '7d' }\r\n+        );\r\n+\r\n+        res.status(200).json({\r\n+            message: 'Login bem-sucedido!',\r\n+            token, // <-- agora existe\r\n+            user: {\r\n+                id: user._id,\r\n+                nome: user.nomeCompleto || user.razaoSocial || user.username,\r\n+                email: user.email,\r\n+                role: user.role\r\n+            }\r\n+        });\r\n+    } catch (error) {\r\n+        res.status(500).json({ message: 'Erro no servidor.' });\r\n+    }\r\n });\r\n \r\n // GET /api/users/:id -> Busca os dados de um utilizador\r\n router.get('/users/:id', requireAuth, async (req, res) => {\r\n"
                },
                {
                    "date": 1756592591371,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -188,5 +188,18 @@\n     res.status(500).json({ message: 'Erro no servidor. Tente novamente mais tarde.' });\r\n   }\r\n });\r\n \r\n+// GET /api/auth/check -> Verifica token e retorna role\r\n+router.get('/check', authMiddleware, (req, res) => {\r\n+    if (!req.user) {\r\n+        return res.status(401).json({ message: 'Não autenticado' });\r\n+    }\r\n+\r\n+    if (req.user.email !== process.env.ADMIN_EMAIL) {\r\n+        return res.status(403).json({ message: 'Acesso negado: não é administrador' });\r\n+    }\r\n+\r\n+    res.json({ success: true, user: req.user });\r\n+});\r\n+\r\n module.exports = router;\r\n"
                },
                {
                    "date": 1756593036174,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,8 +4,9 @@\n const jwt = require('jsonwebtoken');\r\n const User = require('../models/User');\r\n const { body, validationResult } = require('express-validator');\r\n const { cpf, cnpj } = require('cpf-cnpj-validator');\r\n+const authMiddleware = require('../middlewares/authMiddleware');\r\n const requireAuth = require('../middlewares/requireAuth');\r\n \r\n const registerValidationRules = [\r\n   body('nomeCompleto').if(body('tipoConta').equals('pessoa_fisica')).notEmpty().withMessage('O nome completo é obrigatório.').isLength({ min: 3 }).withMessage('O nome deve ter pelo menos 3 caracteres.'),\r\n"
                },
                {
                    "date": 1756593436202,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -195,12 +195,14 @@\n     if (!req.user) {\r\n         return res.status(401).json({ message: 'Não autenticado' });\r\n     }\r\n \r\n-    if (req.user.email !== process.env.ADMIN_EMAIL) {\r\n-        return res.status(403).json({ message: 'Acesso negado: não é administrador' });\r\n-    }\r\n-\r\n-    res.json({ success: true, user: req.user });\r\n+    // Exemplo: o authMiddleware adiciona req.user com { id, email, role }\r\n+    res.json({\r\n+        success: true,\r\n+        id: req.user.id,\r\n+        email: req.user.email,\r\n+        role: req.user.role   // <<-- importante!\r\n+    });\r\n });\r\n \r\n module.exports = router;\r\n"
                },
                {
                    "date": 1756831790799,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,8 +6,10 @@\n const { body, validationResult } = require('express-validator');\r\n const { cpf, cnpj } = require('cpf-cnpj-validator');\r\n const authMiddleware = require('../middlewares/authMiddleware');\r\n const requireAuth = require('../middlewares/requireAuth');\r\n+const crypto = require('crypto');\r\n+const { sendMail } = require('../utils/mailer');\r\n \r\n const registerValidationRules = [\r\n   body('nomeCompleto').if(body('tipoConta').equals('pessoa_fisica')).notEmpty().withMessage('O nome completo é obrigatório.').isLength({ min: 3 }).withMessage('O nome deve ter pelo menos 3 caracteres.'),\r\n   body('razaoSocial').if(body('tipoConta').equals('pessoa_juridica')).notEmpty().withMessage('A razão social é obrigatória.'),\r\n"
                },
                {
                    "date": 1756831838344,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -206,5 +206,126 @@\n         role: req.user.role   // <<-- importante!\r\n     });\r\n });\r\n \r\n+// POST /api/auth/email/send-verification  (precisa estar logado)\r\n+router.post('/auth/email/send-verification', requireAuth, async (req, res) => {\r\n+  try {\r\n+    const user = await User.findById(req.user.id);\r\n+    if (!user) return res.status(404).json({ message: 'Usuário não encontrado' });\r\n+    if (user.emailVerified) return res.status(400).json({ message: 'E-mail já verificado' });\r\n+\r\n+    const token = crypto.randomBytes(32).toString('hex');\r\n+    user.emailVerificationToken = token;\r\n+    user.emailVerificationExpires = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24h\r\n+    await user.save();\r\n+\r\n+    const FRONT = process.env.FRONTEND_URL || 'http://localhost:5500';\r\n+    const link = `${FRONT}/pages/verificar-email.html?token=${token}`;\r\n+\r\n+    await sendMail({\r\n+      to: user.email,\r\n+      subject: 'Verifique seu e-mail',\r\n+      html: `\r\n+        <h2>Olá, ${user.nomeCompleto || user.razaoSocial || ''}</h2>\r\n+        <p>Clique para confirmar seu e-mail:</p>\r\n+        <p><a href=\"${link}\" target=\"_blank\">${link}</a></p>\r\n+        <p>O link expira em 24 horas.</p>\r\n+      `,\r\n+    });\r\n+\r\n+    res.json({ ok: true });\r\n+  } catch (err) {\r\n+    console.error(err);\r\n+    res.status(500).json({ message: 'Falha ao enviar e-mail de verificação' });\r\n+  }\r\n+});\r\n+\r\n+// GET /api/auth/email/verify?token=...\r\n+router.get('/auth/email/verify', async (req, res) => {\r\n+  try {\r\n+    const { token } = req.query;\r\n+    if (!token) return res.status(400).json({ message: 'Token ausente' });\r\n+\r\n+    const user = await User.findOne({\r\n+      emailVerificationToken: token,\r\n+      emailVerificationExpires: { $gt: new Date() }\r\n+    });\r\n+    if (!user) return res.status(400).json({ message: 'Token inválido ou expirado' });\r\n+\r\n+    user.emailVerified = true;\r\n+    user.emailVerificationToken = undefined;\r\n+    user.emailVerificationExpires = undefined;\r\n+    await user.save();\r\n+\r\n+    res.json({ ok: true });\r\n+  } catch (err) {\r\n+    console.error(err);\r\n+    res.status(500).json({ message: 'Falha ao verificar e-mail' });\r\n+  }\r\n+});\r\n+\r\n+// POST /api/auth/password/request  (precisa estar logado)\r\n+router.post('/auth/password/request', requireAuth, async (req, res) => {\r\n+  try {\r\n+    const user = await User.findById(req.user.id);\r\n+    if (!user) return res.status(404).json({ message: 'Usuário não encontrado' });\r\n+    if (!user.emailVerified) return res.status(400).json({ message: 'E-mail não verificado' });\r\n+\r\n+    const token = crypto.randomBytes(32).toString('hex');\r\n+    user.passwordResetToken = token;\r\n+    user.passwordResetExpires = new Date(Date.now() + 60 * 60 * 1000); // 1h\r\n+    await user.save();\r\n+\r\n+    const FRONT = process.env.FRONTEND_URL || 'http://localhost:5500';\r\n+    const link = `${FRONT}/pages/resetar-senha.html?token=${token}`;\r\n+\r\n+    await sendMail({\r\n+      to: user.email,\r\n+      subject: 'Redefinição de senha',\r\n+      html: `\r\n+        <h2>Olá, ${user.nomeCompleto || user.razaoSocial || ''}</h2>\r\n+        <p>Para definir uma nova senha, clique no link abaixo:</p>\r\n+        <p><a href=\"${link}\" target=\"_blank\">${link}</a></p>\r\n+        <p>O link expira em 1 hora.</p>\r\n+      `,\r\n+    });\r\n+\r\n+    res.json({ ok: true });\r\n+  } catch (err) {\r\n+    console.error(err);\r\n+    res.status(500).json({ message: 'Falha ao solicitar alteração de senha' });\r\n+  }\r\n+});\r\n+\r\n+// POST /api/auth/password/reset  { token, password }\r\n+router.post('/auth/password/reset', async (req, res) => {\r\n+  try {\r\n+    const { token, password } = req.body || {};\r\n+    if (!token || !password) return res.status(400).json({ message: 'Dados inválidos' });\r\n+\r\n+    const user = await User.findOne({\r\n+      passwordResetToken: token,\r\n+      passwordResetExpires: { $gt: new Date() }\r\n+    });\r\n+    if (!user) return res.status(400).json({ message: 'Token inválido ou expirado' });\r\n+\r\n+    // força de senha: 8+ com maiúscula, minúscula e número (mesmo padrão do cadastro)\r\n+    const strong = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d).{8,}$/;\r\n+    if (!strong.test(password)) {\r\n+      return res.status(400).json({ message: 'A senha deve ter 8+ caracteres, com maiúscula, minúscula e número.' });\r\n+    }\r\n+\r\n+    const salt = await bcrypt.genSalt(10);\r\n+    user.senha = await bcrypt.hash(password, salt);\r\n+    user.passwordResetToken = undefined;\r\n+    user.passwordResetExpires = undefined;\r\n+    await user.save();\r\n+\r\n+    res.json({ ok: true });\r\n+  } catch (err) {\r\n+    console.error(err);\r\n+    res.status(500).json({ message: 'Falha ao redefinir senha' });\r\n+  }\r\n+});\r\n+\r\n module.exports = router;\r\n"
                },
                {
                    "date": 1756832831080,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,324 @@\n+const express = require('express');\r\n+const router = express.Router();\r\n+const bcrypt = require('bcryptjs');\r\n+const jwt = require('jsonwebtoken');\r\n+const User = require('../models/User');\r\n+const { body, validationResult } = require('express-validator');\r\n+const { cpf, cnpj } = require('cpf-cnpj-validator');\r\n+const authMiddleware = require('../middlewares/authMiddleware');\r\n+const requireAuth = require('../middlewares/requireAuth');\r\n+const crypto = require('crypto');\r\n+const { sendMail } = require('../utils/mailer');\r\n+\r\n+const registerValidationRules = [\r\n+  body('nomeCompleto').if(body('tipoConta').equals('pessoa_fisica')).notEmpty().withMessage('O nome completo é obrigatório.').isLength({ min: 3 }).withMessage('O nome deve ter pelo menos 3 caracteres.'),\r\n+  body('razaoSocial').if(body('tipoConta').equals('pessoa_juridica')).notEmpty().withMessage('A razão social é obrigatória.'),\r\n+  body('email').notEmpty().withMessage('O e-mail é obrigatório.').isEmail().withMessage('Por favor, insira um e-mail válido.').normalizeEmail(),\r\n+  body('celular').notEmpty().withMessage('O número de celular é obrigatório.'),\r\n+  body('senha').isLength({ min: 8 }).withMessage('A senha deve ter no mínimo 8 caracteres.').matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d).+$/).withMessage('A senha deve conter pelo menos uma letra maiúscula, uma minúscula e um número.'),\r\n+  body('confirm_password').notEmpty().withMessage('A confirmação de senha é obrigatória.').custom((value, { req }) => { if (value !== req.body.senha) { throw new Error('As senhas não coincidem. Por favor, tente novamente.'); } return true; }),\r\n+  body('cpf').if(body('tipoConta').equals('pessoa_fisica')).notEmpty().withMessage('O CPF é obrigatório.').custom((value) => { if (!cpf.isValid(value)) { throw new Error('O CPF inserido não é válido.'); } return true; }),\r\n+  body('cnpj').if(body('tipoConta').equals('pessoa_juridica')).notEmpty().withMessage('O CNPJ é obrigatório.').custom((value) => { if (!cnpj.isValid(value)) { throw new Error('O CNPJ inserido não é válido.'); } return true; }),\r\n+  body('terms').equals('on').withMessage('Você deve concordar com os termos e condições para se registar.'),\r\n+  body('inscricaoEstadual').if(body('tipoConta').equals('pessoa_juridica')).if(body('isentoIE').not().exists()).notEmpty().withMessage('A Inscrição Estadual é obrigatória quando não isento.'),\r\n+];\r\n+\r\n+// ROTA: POST /api/register\r\n+router.post('/register', registerValidationRules, async (req, res) => {\r\n+  const errors = validationResult(req);\r\n+  if (!errors.isEmpty()) {\r\n+    return res.status(400).json({ errors: errors.array() });\r\n+  }\r\n+\r\n+  try {\r\n+    const { email, celular, cpf: reqCpf, cnpj: reqCnpj } = req.body;\r\n+\r\n+    const conditions = [{ email }, { celular }];\r\n+    if (reqCpf) conditions.push({ cpf: reqCpf });\r\n+    if (reqCnpj) conditions.push({ cnpj: reqCnpj });\r\n+\r\n+    const userExists = await User.findOne({ $or: conditions });\r\n+\r\n+    if (userExists) {\r\n+      let field, message;\r\n+      if (userExists.email === email) {\r\n+        field = 'email';\r\n+        message = 'Este email já está a ser utilizado.';\r\n+      } else if (userExists.celular === celular) {\r\n+        field = 'celular';\r\n+        message = 'Este número de celular já está a ser utilizado.';\r\n+      } else if (reqCpf && userExists.cpf === reqCpf) {\r\n+        field = 'cpf';\r\n+        message = 'Este CPF já está a ser utilizado.';\r\n+      } else if (reqCnpj && userExists.cnpj === reqCnpj) {\r\n+        field = 'cnpj';\r\n+        message = 'Este CNPJ já está a ser utilizado.';\r\n+      }\r\n+\r\n+      if (field) {\r\n+        return res.status(400).json({\r\n+          errors: [{ path: field, msg: message }]\r\n+        });\r\n+      }\r\n+    }\r\n+\r\n+    const salt = await bcrypt.genSalt(10);\r\n+    const hashedPassword = await bcrypt.hash(req.body.senha, salt);\r\n+    const isento = req.body.isentoIE === 'on';\r\n+\r\n+    const newUser = new User({\r\n+      tipoConta: req.body.tipoConta,\r\n+      email: req.body.email,\r\n+      senha: hashedPassword,\r\n+      celular: req.body.celular,\r\n+      telefone: req.body.telefone,\r\n+      nomeCompleto: req.body.nomeCompleto,\r\n+      cpf: req.body.cpf,\r\n+      genero: req.body.genero,\r\n+      dataNascimento: req.body.dataNascimento,\r\n+      razaoSocial: req.body.razaoSocial,\r\n+      cnpj: req.body.cnpj,\r\n+      nomeContato: req.body.nomeContato,\r\n+      inscricaoEstadual: req.body.inscricaoEstadual,\r\n+      estadoIE: req.body.estadoIE,\r\n+      isentoIE: isento,\r\n+      role: 'cliente' // sempre cliente por padrão\r\n+    });\r\n+\r\n+    const savedUser = await newUser.save();\r\n+\r\n+    res.status(201).json({\r\n+      message: 'Utilizador registado com sucesso!',\r\n+      user: {\r\n+        id: savedUser._id,\r\n+        nome: savedUser.nomeCompleto || savedUser.razaoSocial,\r\n+        role: savedUser.role\r\n+      }\r\n+    });\r\n+\r\n+  } catch (error) {\r\n+    console.error(error);\r\n+    if (error.code === 11000) {\r\n+      return res.status(400).json({\r\n+        errors: [{ path: 'geral', msg: 'Um dos dados inseridos (email, CPF, CNPJ ou celular) já está em uso.' }]\r\n+      });\r\n+    }\r\n+    res.status(500).json({ message: 'Erro no servidor. Tente novamente mais tarde.' });\r\n+  }\r\n+});\r\n+\r\n+// ROTA: POST /api/login\r\n+router.post('/login', async (req, res) => {\r\n+    const { identifier, senha } = req.body;\r\n+    try {\r\n+        const user = await User.findOne({\r\n+            $or: [{ email: identifier }, { cpf: identifier }, { cnpj: identifier }]\r\n+        });\r\n+\r\n+        if (!user || !(await bcrypt.compare(senha, user.senha))) {\r\n+            return res.status(400).json({ message: 'Credenciais inválidas.' });\r\n+        }\r\n+\r\n+        // Gera o token JWT\r\n+        const token = jwt.sign(\r\n+            { id: user._id, role: user.role },\r\n+            process.env.JWT_SECRET,\r\n+            { expiresIn: '7d' }\r\n+        );\r\n+\r\n+        res.status(200).json({\r\n+            message: 'Login bem-sucedido!',\r\n+            token, // <-- agora existe\r\n+            user: {\r\n+                id: user._id,\r\n+                nome: user.nomeCompleto || user.razaoSocial || user.username,\r\n+                email: user.email,\r\n+                role: user.role\r\n+            }\r\n+        });\r\n+    } catch (error) {\r\n+        res.status(500).json({ message: 'Erro no servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// GET /api/users/:id -> Busca os dados de um utilizador\r\n+router.get('/users/:id', requireAuth, async (req, res) => {\r\n+  try {\r\n+    if (req.user.id !== req.params.id && req.user.role !== 'admin_master') {\r\n+      return res.status(403).json({ message: 'Acesso negado' });\r\n+    }\r\n+\r\n+    const user = await User.findById(req.params.id).select('-senha');\r\n+    if (!user) {\r\n+      return res.status(404).json({ message: 'Utilizador não encontrado.' });\r\n+    }\r\n+\r\n+    res.status(200).json(user);\r\n+\r\n+  } catch (error) {\r\n+    console.error(error);\r\n+    res.status(500).json({ message: 'Erro no servidor.' });\r\n+  }\r\n+});\r\n+\r\n+// PUT /api/users/:id -> Atualiza utilizador\r\n+router.put('/users/:id', requireAuth, async (req, res) => {\r\n+  try {\r\n+    if (req.user.id !== req.params.id && req.user.role !== 'admin_master') {\r\n+      return res.status(403).json({ message: 'Acesso negado' });\r\n+    }\r\n+\r\n+    const userId = req.params.id;\r\n+    const updateData = req.body;\r\n+\r\n+    const updatedUser = await User.findByIdAndUpdate(userId, updateData, { new: true }).select('-senha');\r\n+\r\n+    if (!updatedUser) {\r\n+      return res.status(404).json({ message: 'Utilizador não encontrado' });\r\n+    }\r\n+\r\n+    res.status(200).json({\r\n+      message: 'Dados atualizados com sucesso!',\r\n+      user: {\r\n+        id: updatedUser._id,\r\n+        nome: updatedUser.nomeCompleto || updatedUser.razaoSocial,\r\n+        role: updatedUser.role\r\n+      }\r\n+    });\r\n+\r\n+  } catch (error) {\r\n+    console.error('Erro ao atualizar utilizador:', error);\r\n+    res.status(500).json({ message: 'Erro no servidor. Tente novamente mais tarde.' });\r\n+  }\r\n+});\r\n+\r\n+// GET /api/auth/check -> Verifica token e retorna role\r\n+router.get('/check', authMiddleware, (req, res) => {\r\n+    if (!req.user) {\r\n+        return res.status(401).json({ message: 'Não autenticado' });\r\n+    }\r\n+\r\n+    // Exemplo: o authMiddleware adiciona req.user com { id, email, role }\r\n+    res.json({\r\n+        success: true,\r\n+        id: req.user.id,\r\n+        email: req.user.email,\r\n+        role: req.user.role   // <<-- importante!\r\n+    });\r\n+});\r\n+\r\n+// POST /api/auth/email/send-verification\r\n+router.post('/email/send-verification', requireAuth, async (req, res) => {\r\n+  try {\r\n+    const user = await User.findById(req.user.id);\r\n+    if (!user) return res.status(404).json({ message: 'Usuário não encontrado' });\r\n+    if (user.emailVerified) return res.status(400).json({ message: 'E-mail já verificado' });\r\n+\r\n+    const token = crypto.randomBytes(32).toString('hex');\r\n+    user.emailVerificationToken = token;\r\n+    user.emailVerificationExpires = new Date(Date.now() + 24*60*60*1000);\r\n+    await user.save();\r\n+\r\n+    const FRONT = process.env.FRONTEND_URL || 'http://localhost:5500';\r\n+    const link = `${FRONT}/pages/verificar-email.html?token=${token}`;\r\n+\r\n+    await sendMail({\r\n+      to: user.email,\r\n+      subject: 'Verifique seu e-mail',\r\n+      html: `<p>Olá, ${user.nomeCompleto || user.razaoSocial || ''}</p>\r\n+             <p>Clique para confirmar seu e-mail:</p>\r\n+             <p><a href=\"${link}\" target=\"_blank\">${link}</a></p>`\r\n+    });\r\n+\r\n+    res.json({ ok: true });\r\n+  } catch (err) {\r\n+    console.error(err);\r\n+    res.status(500).json({ message: 'Falha ao enviar e-mail de verificação' });\r\n+  }\r\n+});\r\n+\r\n+// GET /api/auth/email/verify?token=...\r\n+router.get('/email/verify', async (req, res) => {\r\n+  try {\r\n+    const { token } = req.query;\r\n+    if (!token) return res.status(400).json({ message: 'Token ausente' });\r\n+\r\n+    const user = await User.findOne({\r\n+      emailVerificationToken: token,\r\n+      emailVerificationExpires: { $gt: new Date() }\r\n+    });\r\n+    if (!user) return res.status(400).json({ message: 'Token inválido ou expirado' });\r\n+\r\n+    user.emailVerified = true;\r\n+    user.emailVerificationToken = undefined;\r\n+    user.emailVerificationExpires = undefined;\r\n+    await user.save();\r\n+\r\n+    res.json({ ok: true });\r\n+  } catch (err) {\r\n+    console.error(err);\r\n+    res.status(500).json({ message: 'Falha ao verificar e-mail' });\r\n+  }\r\n+});\r\n+\r\n+// POST /api/auth/password/request\r\n+router.post('/password/request', requireAuth, async (req, res) => {\r\n+  try {\r\n+    const user = await User.findById(req.user.id);\r\n+    if (!user) return res.status(404).json({ message: 'Usuário não encontrado' });\r\n+    if (!user.emailVerified) return res.status(400).json({ message: 'E-mail não verificado' });\r\n+\r\n+    const token = crypto.randomBytes(32).toString('hex');\r\n+    user.passwordResetToken = token;\r\n+    user.passwordResetExpires = new Date(Date.now() + 60*60*1000);\r\n+    await user.save();\r\n+\r\n+    const FRONT = process.env.FRONTEND_URL || 'http://localhost:5500';\r\n+    const link = `${FRONT}/pages/resetar-senha.html?token=${token}`;\r\n+\r\n+    await sendMail({\r\n+      to: user.email,\r\n+      subject: 'Redefinição de senha',\r\n+      html: `<p>Olá, ${user.nomeCompleto || user.razaoSocial || ''}</p>\r\n+             <p>Para definir uma nova senha clique:</p>\r\n+             <p><a href=\"${link}\" target=\"_blank\">${link}</a></p>`\r\n+    });\r\n+\r\n+    res.json({ ok: true });\r\n+  } catch (err) {\r\n+    console.error(err);\r\n+    res.status(500).json({ message: 'Falha ao solicitar alteração de senha' });\r\n+  }\r\n+});\r\n+\r\n+// POST /api/auth/password/reset\r\n+router.post('/password/reset', async (req, res) => {\r\n+  try {\r\n+    const { token, password } = req.body || {};\r\n+    if (!token || !password) return res.status(400).json({ message: 'Dados inválidos' });\r\n+\r\n+    const user = await User.findOne({\r\n+      passwordResetToken: token,\r\n+      passwordResetExpires: { $gt: new Date() }\r\n+    });\r\n+    if (!user) return res.status(400).json({ message: 'Token inválido ou expirado' });\r\n+\r\n+    const strong = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d).{8,}$/;\r\n+    if (!strong.test(password)) {\r\n+      return res.status(400).json({ message: 'A senha deve ter 8+ caracteres, com maiúscula, minúscula e número.' });\r\n+    }\r\n+\r\n+    const salt = await bcrypt.genSalt(10);\r\n+    user.senha = await bcrypt.hash(password, salt);\r\n+    user.passwordResetToken = undefined;\r\n+    user.passwordResetExpires = undefined;\r\n+    await user.save();\r\n+\r\n+    res.json({ ok: true });\r\n+  } catch (err) {\r\n+    console.error(err);\r\n+    res.status(500).json({ message: 'Falha ao redefinir senha' });\r\n+  }\r\n+});\r\n+\r\n+module.exports = router;\r\n"
                },
                {
                    "date": 1756833632951,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -215,346 +215,21 @@\n     if (user.emailVerified) return res.status(400).json({ message: 'E-mail já verificado' });\r\n \r\n     const token = crypto.randomBytes(32).toString('hex');\r\n     user.emailVerificationToken = token;\r\n-    user.emailVerificationExpires = new Date(Date.now() + 24*60*60*1000);\r\n+    user.emailVerificationExpires = new Date(Date.now() + 2 * 60 * 60 * 1000); // 2h\r\n     await user.save();\r\n \r\n     const FRONT = process.env.FRONTEND_URL || 'http://localhost:5500';\r\n     const link = `${FRONT}/pages/verificar-email.html?token=${token}`;\r\n \r\n     await sendMail({\r\n       to: user.email,\r\n       subject: 'Verifique seu e-mail',\r\n-      html: `<p>Olá, ${user.nomeCompleto || user.razaoSocial || ''}</p>\r\n-             <p>Clique para confirmar seu e-mail:</p>\r\n-             <p><a href=\"${link}\" target=\"_blank\">${link}</a></p>`\r\n-    });\r\n-\r\n-    res.json({ ok: true });\r\n-  } catch (err) {\r\n-    console.error(err);\r\n-    res.status(500).json({ message: 'Falha ao enviar e-mail de verificação' });\r\n-  }\r\n-});\r\n-\r\n-// GET /api/auth/email/verify?token=...\r\n-router.get('/email/verify', async (req, res) => {\r\n-  try {\r\n-    const { token } = req.query;\r\n-    if (!token) return res.status(400).json({ message: 'Token ausente' });\r\n-\r\n-    const user = await User.findOne({\r\n-      emailVerificationToken: token,\r\n-      emailVerificationExpires: { $gt: new Date() }\r\n-    });\r\n-    if (!user) return res.status(400).json({ message: 'Token inválido ou expirado' });\r\n-\r\n-    user.emailVerified = true;\r\n-    user.emailVerificationToken = undefined;\r\n-    user.emailVerificationExpires = undefined;\r\n-    await user.save();\r\n-\r\n-    res.json({ ok: true });\r\n-  } catch (err) {\r\n-    console.error(err);\r\n-    res.status(500).json({ message: 'Falha ao verificar e-mail' });\r\n-  }\r\n-});\r\n-\r\n-// POST /api/auth/password/request\r\n-router.post('/password/request', requireAuth, async (req, res) => {\r\n-  try {\r\n-    const user = await User.findById(req.user.id);\r\n-    if (!user) return res.status(404).json({ message: 'Usuário não encontrado' });\r\n-    if (!user.emailVerified) return res.status(400).json({ message: 'E-mail não verificado' });\r\n-\r\n-    const token = crypto.randomBytes(32).toString('hex');\r\n-    user.passwordResetToken = token;\r\n-    user.passwordResetExpires = new Date(Date.now() + 60*60*1000);\r\n-    await user.save();\r\n-\r\n-    const FRONT = process.env.FRONTEND_URL || 'http://localhost:5500';\r\n-    const link = `${FRONT}/pages/resetar-senha.html?token=${token}`;\r\n-\r\n-    await sendMail({\r\n-      to: user.email,\r\n-      subject: 'Redefinição de senha',\r\n-      html: `<p>Olá, ${user.nomeCompleto || user.razaoSocial || ''}</p>\r\n-             <p>Para definir uma nova senha clique:</p>\r\n-             <p><a href=\"${link}\" target=\"_blank\">${link}</a></p>`\r\n-    });\r\n-\r\n-    res.json({ ok: true });\r\n-  } catch (err) {\r\n-    console.error(err);\r\n-    res.status(500).json({ message: 'Falha ao solicitar alteração de senha' });\r\n-  }\r\n-});\r\n-\r\n-// POST /api/auth/password/reset\r\n-router.post('/password/reset', async (req, res) => {\r\n-  try {\r\n-    const { token, password } = req.body || {};\r\n-    if (!token || !password) return res.status(400).json({ message: 'Dados inválidos' });\r\n-\r\n-    const user = await User.findOne({\r\n-      passwordResetToken: token,\r\n-      passwordResetExpires: { $gt: new Date() }\r\n-    });\r\n-    if (!user) return res.status(400).json({ message: 'Token inválido ou expirado' });\r\n-\r\n-    const strong = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d).{8,}$/;\r\n-    if (!strong.test(password)) {\r\n-      return res.status(400).json({ message: 'A senha deve ter 8+ caracteres, com maiúscula, minúscula e número.' });\r\n-    }\r\n-\r\n-    const salt = await bcrypt.genSalt(10);\r\n-    user.senha = await bcrypt.hash(password, salt);\r\n-    user.passwordResetToken = undefined;\r\n-    user.passwordResetExpires = undefined;\r\n-    await user.save();\r\n-\r\n-    res.json({ ok: true });\r\n-  } catch (err) {\r\n-    console.error(err);\r\n-    res.status(500).json({ message: 'Falha ao redefinir senha' });\r\n-  }\r\n-});\r\n-\r\n-module.exports = router;\r\n-const express = require('express');\r\n-const router = express.Router();\r\n-const bcrypt = require('bcryptjs');\r\n-const jwt = require('jsonwebtoken');\r\n-const User = require('../models/User');\r\n-const { body, validationResult } = require('express-validator');\r\n-const { cpf, cnpj } = require('cpf-cnpj-validator');\r\n-const authMiddleware = require('../middlewares/authMiddleware');\r\n-const requireAuth = require('../middlewares/requireAuth');\r\n-const crypto = require('crypto');\r\n-const { sendMail } = require('../utils/mailer');\r\n-\r\n-const registerValidationRules = [\r\n-  body('nomeCompleto').if(body('tipoConta').equals('pessoa_fisica')).notEmpty().withMessage('O nome completo é obrigatório.').isLength({ min: 3 }).withMessage('O nome deve ter pelo menos 3 caracteres.'),\r\n-  body('razaoSocial').if(body('tipoConta').equals('pessoa_juridica')).notEmpty().withMessage('A razão social é obrigatória.'),\r\n-  body('email').notEmpty().withMessage('O e-mail é obrigatório.').isEmail().withMessage('Por favor, insira um e-mail válido.').normalizeEmail(),\r\n-  body('celular').notEmpty().withMessage('O número de celular é obrigatório.'),\r\n-  body('senha').isLength({ min: 8 }).withMessage('A senha deve ter no mínimo 8 caracteres.').matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d).+$/).withMessage('A senha deve conter pelo menos uma letra maiúscula, uma minúscula e um número.'),\r\n-  body('confirm_password').notEmpty().withMessage('A confirmação de senha é obrigatória.').custom((value, { req }) => { if (value !== req.body.senha) { throw new Error('As senhas não coincidem. Por favor, tente novamente.'); } return true; }),\r\n-  body('cpf').if(body('tipoConta').equals('pessoa_fisica')).notEmpty().withMessage('O CPF é obrigatório.').custom((value) => { if (!cpf.isValid(value)) { throw new Error('O CPF inserido não é válido.'); } return true; }),\r\n-  body('cnpj').if(body('tipoConta').equals('pessoa_juridica')).notEmpty().withMessage('O CNPJ é obrigatório.').custom((value) => { if (!cnpj.isValid(value)) { throw new Error('O CNPJ inserido não é válido.'); } return true; }),\r\n-  body('terms').equals('on').withMessage('Você deve concordar com os termos e condições para se registar.'),\r\n-  body('inscricaoEstadual').if(body('tipoConta').equals('pessoa_juridica')).if(body('isentoIE').not().exists()).notEmpty().withMessage('A Inscrição Estadual é obrigatória quando não isento.'),\r\n-];\r\n-\r\n-// ROTA: POST /api/register\r\n-router.post('/register', registerValidationRules, async (req, res) => {\r\n-  const errors = validationResult(req);\r\n-  if (!errors.isEmpty()) {\r\n-    return res.status(400).json({ errors: errors.array() });\r\n-  }\r\n-\r\n-  try {\r\n-    const { email, celular, cpf: reqCpf, cnpj: reqCnpj } = req.body;\r\n-\r\n-    const conditions = [{ email }, { celular }];\r\n-    if (reqCpf) conditions.push({ cpf: reqCpf });\r\n-    if (reqCnpj) conditions.push({ cnpj: reqCnpj });\r\n-\r\n-    const userExists = await User.findOne({ $or: conditions });\r\n-\r\n-    if (userExists) {\r\n-      let field, message;\r\n-      if (userExists.email === email) {\r\n-        field = 'email';\r\n-        message = 'Este email já está a ser utilizado.';\r\n-      } else if (userExists.celular === celular) {\r\n-        field = 'celular';\r\n-        message = 'Este número de celular já está a ser utilizado.';\r\n-      } else if (reqCpf && userExists.cpf === reqCpf) {\r\n-        field = 'cpf';\r\n-        message = 'Este CPF já está a ser utilizado.';\r\n-      } else if (reqCnpj && userExists.cnpj === reqCnpj) {\r\n-        field = 'cnpj';\r\n-        message = 'Este CNPJ já está a ser utilizado.';\r\n-      }\r\n-\r\n-      if (field) {\r\n-        return res.status(400).json({\r\n-          errors: [{ path: field, msg: message }]\r\n-        });\r\n-      }\r\n-    }\r\n-\r\n-    const salt = await bcrypt.genSalt(10);\r\n-    const hashedPassword = await bcrypt.hash(req.body.senha, salt);\r\n-    const isento = req.body.isentoIE === 'on';\r\n-\r\n-    const newUser = new User({\r\n-      tipoConta: req.body.tipoConta,\r\n-      email: req.body.email,\r\n-      senha: hashedPassword,\r\n-      celular: req.body.celular,\r\n-      telefone: req.body.telefone,\r\n-      nomeCompleto: req.body.nomeCompleto,\r\n-      cpf: req.body.cpf,\r\n-      genero: req.body.genero,\r\n-      dataNascimento: req.body.dataNascimento,\r\n-      razaoSocial: req.body.razaoSocial,\r\n-      cnpj: req.body.cnpj,\r\n-      nomeContato: req.body.nomeContato,\r\n-      inscricaoEstadual: req.body.inscricaoEstadual,\r\n-      estadoIE: req.body.estadoIE,\r\n-      isentoIE: isento,\r\n-      role: 'cliente' // sempre cliente por padrão\r\n-    });\r\n-\r\n-    const savedUser = await newUser.save();\r\n-\r\n-    res.status(201).json({\r\n-      message: 'Utilizador registado com sucesso!',\r\n-      user: {\r\n-        id: savedUser._id,\r\n-        nome: savedUser.nomeCompleto || savedUser.razaoSocial,\r\n-        role: savedUser.role\r\n-      }\r\n-    });\r\n-\r\n-  } catch (error) {\r\n-    console.error(error);\r\n-    if (error.code === 11000) {\r\n-      return res.status(400).json({\r\n-        errors: [{ path: 'geral', msg: 'Um dos dados inseridos (email, CPF, CNPJ ou celular) já está em uso.' }]\r\n-      });\r\n-    }\r\n-    res.status(500).json({ message: 'Erro no servidor. Tente novamente mais tarde.' });\r\n-  }\r\n-});\r\n-\r\n-// ROTA: POST /api/login\r\n-router.post('/login', async (req, res) => {\r\n-    const { identifier, senha } = req.body;\r\n-    try {\r\n-        const user = await User.findOne({\r\n-            $or: [{ email: identifier }, { cpf: identifier }, { cnpj: identifier }]\r\n-        });\r\n-\r\n-        if (!user || !(await bcrypt.compare(senha, user.senha))) {\r\n-            return res.status(400).json({ message: 'Credenciais inválidas.' });\r\n-        }\r\n-\r\n-        // Gera o token JWT\r\n-        const token = jwt.sign(\r\n-            { id: user._id, role: user.role },\r\n-            process.env.JWT_SECRET,\r\n-            { expiresIn: '7d' }\r\n-        );\r\n-\r\n-        res.status(200).json({\r\n-            message: 'Login bem-sucedido!',\r\n-            token, // <-- agora existe\r\n-            user: {\r\n-                id: user._id,\r\n-                nome: user.nomeCompleto || user.razaoSocial || user.username,\r\n-                email: user.email,\r\n-                role: user.role\r\n-            }\r\n-        });\r\n-    } catch (error) {\r\n-        res.status(500).json({ message: 'Erro no servidor.' });\r\n-    }\r\n-});\r\n-\r\n-// GET /api/users/:id -> Busca os dados de um utilizador\r\n-router.get('/users/:id', requireAuth, async (req, res) => {\r\n-  try {\r\n-    if (req.user.id !== req.params.id && req.user.role !== 'admin_master') {\r\n-      return res.status(403).json({ message: 'Acesso negado' });\r\n-    }\r\n-\r\n-    const user = await User.findById(req.params.id).select('-senha');\r\n-    if (!user) {\r\n-      return res.status(404).json({ message: 'Utilizador não encontrado.' });\r\n-    }\r\n-\r\n-    res.status(200).json(user);\r\n-\r\n-  } catch (error) {\r\n-    console.error(error);\r\n-    res.status(500).json({ message: 'Erro no servidor.' });\r\n-  }\r\n-});\r\n-\r\n-// PUT /api/users/:id -> Atualiza utilizador\r\n-router.put('/users/:id', requireAuth, async (req, res) => {\r\n-  try {\r\n-    if (req.user.id !== req.params.id && req.user.role !== 'admin_master') {\r\n-      return res.status(403).json({ message: 'Acesso negado' });\r\n-    }\r\n-\r\n-    const userId = req.params.id;\r\n-    const updateData = req.body;\r\n-\r\n-    const updatedUser = await User.findByIdAndUpdate(userId, updateData, { new: true }).select('-senha');\r\n-\r\n-    if (!updatedUser) {\r\n-      return res.status(404).json({ message: 'Utilizador não encontrado' });\r\n-    }\r\n-\r\n-    res.status(200).json({\r\n-      message: 'Dados atualizados com sucesso!',\r\n-      user: {\r\n-        id: updatedUser._id,\r\n-        nome: updatedUser.nomeCompleto || updatedUser.razaoSocial,\r\n-        role: updatedUser.role\r\n-      }\r\n-    });\r\n-\r\n-  } catch (error) {\r\n-    console.error('Erro ao atualizar utilizador:', error);\r\n-    res.status(500).json({ message: 'Erro no servidor. Tente novamente mais tarde.' });\r\n-  }\r\n-});\r\n-\r\n-// GET /api/auth/check -> Verifica token e retorna role\r\n-router.get('/check', authMiddleware, (req, res) => {\r\n-    if (!req.user) {\r\n-        return res.status(401).json({ message: 'Não autenticado' });\r\n-    }\r\n-\r\n-    // Exemplo: o authMiddleware adiciona req.user com { id, email, role }\r\n-    res.json({\r\n-        success: true,\r\n-        id: req.user.id,\r\n-        email: req.user.email,\r\n-        role: req.user.role   // <<-- importante!\r\n-    });\r\n-});\r\n-\r\n-// POST /api/auth/email/send-verification  (precisa estar logado)\r\n-router.post('/auth/email/send-verification', requireAuth, async (req, res) => {\r\n-  try {\r\n-    const user = await User.findById(req.user.id);\r\n-    if (!user) return res.status(404).json({ message: 'Usuário não encontrado' });\r\n-    if (user.emailVerified) return res.status(400).json({ message: 'E-mail já verificado' });\r\n-\r\n-    const token = crypto.randomBytes(32).toString('hex');\r\n-    user.emailVerificationToken = token;\r\n-    user.emailVerificationExpires = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24h\r\n-    await user.save();\r\n-\r\n-    const FRONT = process.env.FRONTEND_URL || 'http://localhost:5500';\r\n-    const link = `${FRONT}/pages/verificar-email.html?token=${token}`;\r\n-\r\n-    await sendMail({\r\n-      to: user.email,\r\n-      subject: 'Verifique seu e-mail',\r\n       html: `\r\n         <h2>Olá, ${user.nomeCompleto || user.razaoSocial || ''}</h2>\r\n-        <p>Clique para confirmar seu e-mail:</p>\r\n+        <p>Confirme seu e-mail clicando no link abaixo (válido por <b>2 horas</b>):</p>\r\n         <p><a href=\"${link}\" target=\"_blank\">${link}</a></p>\r\n-        <p>O link expira em 24 horas.</p>\r\n       `,\r\n     });\r\n \r\n     res.json({ ok: true });\r\n@@ -564,21 +239,21 @@\n   }\r\n });\r\n \r\n // GET /api/auth/email/verify?token=...\r\n-router.get('/auth/email/verify', async (req, res) => {\r\n+router.get('/email/verify', async (req, res) => {\r\n   try {\r\n     const { token } = req.query;\r\n     if (!token) return res.status(400).json({ message: 'Token ausente' });\r\n \r\n     const user = await User.findOne({\r\n       emailVerificationToken: token,\r\n-      emailVerificationExpires: { $gt: new Date() }\r\n+      emailVerificationExpires: { $gt: new Date() }, // ainda válido (2h)\r\n     });\r\n     if (!user) return res.status(400).json({ message: 'Token inválido ou expirado' });\r\n \r\n     user.emailVerified = true;\r\n-    user.emailVerificationToken = undefined;\r\n+    user.emailVerificationToken = undefined; // -> uso único\r\n     user.emailVerificationExpires = undefined;\r\n     await user.save();\r\n \r\n     res.json({ ok: true });\r\n@@ -587,18 +262,18 @@\n     res.status(500).json({ message: 'Falha ao verificar e-mail' });\r\n   }\r\n });\r\n \r\n-// POST /api/auth/password/request  (precisa estar logado)\r\n-router.post('/auth/password/request', requireAuth, async (req, res) => {\r\n+// POST /api/auth/password/request\r\n+router.post('/password/request', requireAuth, async (req, res) => {\r\n   try {\r\n     const user = await User.findById(req.user.id);\r\n     if (!user) return res.status(404).json({ message: 'Usuário não encontrado' });\r\n     if (!user.emailVerified) return res.status(400).json({ message: 'E-mail não verificado' });\r\n \r\n     const token = crypto.randomBytes(32).toString('hex');\r\n     user.passwordResetToken = token;\r\n-    user.passwordResetExpires = new Date(Date.now() + 60 * 60 * 1000); // 1h\r\n+    user.passwordResetExpires = new Date(Date.now() + 2 * 60 * 60 * 1000); // 2h\r\n     await user.save();\r\n \r\n     const FRONT = process.env.FRONTEND_URL || 'http://localhost:5500';\r\n     const link = `${FRONT}/pages/resetar-senha.html?token=${token}`;\r\n@@ -607,11 +282,11 @@\n       to: user.email,\r\n       subject: 'Redefinição de senha',\r\n       html: `\r\n         <h2>Olá, ${user.nomeCompleto || user.razaoSocial || ''}</h2>\r\n-        <p>Para definir uma nova senha, clique no link abaixo:</p>\r\n+        <p>Para definir uma nova senha, use o link abaixo (válido por <b>2 horas</b>):</p>\r\n         <p><a href=\"${link}\" target=\"_blank\">${link}</a></p>\r\n-        <p>O link expira em 1 hora.</p>\r\n+        <p>Este link é de <b>uso único</b>.</p>\r\n       `,\r\n     });\r\n \r\n     res.json({ ok: true });\r\n@@ -620,32 +295,34 @@\n     res.status(500).json({ message: 'Falha ao solicitar alteração de senha' });\r\n   }\r\n });\r\n \r\n-// POST /api/auth/password/reset  { token, password }\r\n-router.post('/auth/password/reset', async (req, res) => {\r\n+\r\n+// POST /api/auth/password/reset\r\n+router.post('/password/reset', async (req, res) => {\r\n   try {\r\n     const { token, password } = req.body || {};\r\n     if (!token || !password) return res.status(400).json({ message: 'Dados inválidos' });\r\n \r\n     const user = await User.findOne({\r\n       passwordResetToken: token,\r\n-      passwordResetExpires: { $gt: new Date() }\r\n+      passwordResetExpires: { $gt: new Date() }, // ainda válido (2h)\r\n     });\r\n     if (!user) return res.status(400).json({ message: 'Token inválido ou expirado' });\r\n \r\n-    // força de senha: 8+ com maiúscula, minúscula e número (mesmo padrão do cadastro)\r\n     const strong = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d).{8,}$/;\r\n     if (!strong.test(password)) {\r\n       return res.status(400).json({ message: 'A senha deve ter 8+ caracteres, com maiúscula, minúscula e número.' });\r\n     }\r\n \r\n     const salt = await bcrypt.genSalt(10);\r\n     user.senha = await bcrypt.hash(password, salt);\r\n+\r\n+    // -> uso único: ao usar, removemos o token\r\n     user.passwordResetToken = undefined;\r\n     user.passwordResetExpires = undefined;\r\n+\r\n     await user.save();\r\n-\r\n     res.json({ ok: true });\r\n   } catch (err) {\r\n     console.error(err);\r\n     res.status(500).json({ message: 'Falha ao redefinir senha' });\r\n"
                }
            ],
            "date": 1756570256421,
            "name": "Commit-0",
            "content": "const express = require('express');\r\nconst router = express.Router();\r\nconst bcrypt = require('bcryptjs');\r\nconst User = require('../models/User');\r\nconst { body, validationResult } = require('express-validator');\r\nconst { cpf, cnpj } = require('cpf-cnpj-validator'); \r\n\r\nconst registerValidationRules = [\r\n    body('nomeCompleto').if(body('tipoConta').equals('pessoa_fisica')).notEmpty().withMessage('O nome completo é obrigatório.').isLength({ min: 3 }).withMessage('O nome deve ter pelo menos 3 caracteres.'),\r\n    body('razaoSocial').if(body('tipoConta').equals('pessoa_juridica')).notEmpty().withMessage('A razão social é obrigatória.'),\r\n    body('email').notEmpty().withMessage('O e-mail é obrigatório.').isEmail().withMessage('Por favor, insira um e-mail válido.').normalizeEmail(),\r\n    body('celular').notEmpty().withMessage('O número de celular é obrigatório.'),\r\n    body('senha').isLength({ min: 8 }).withMessage('A senha deve ter no mínimo 8 caracteres.').matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d).+$/).withMessage('A senha deve conter pelo menos uma letra maiúscula, uma minúscula e um número.'),\r\n    body('confirm_password').notEmpty().withMessage('A confirmação de senha é obrigatória.').custom((value, { req }) => { if (value !== req.body.senha) { throw new Error('As senhas não coincidem. Por favor, tente novamente.'); } return true; }),\r\n    body('cpf').if(body('tipoConta').equals('pessoa_fisica')).notEmpty().withMessage('O CPF é obrigatório.').custom((value) => { if (!cpf.isValid(value)) { throw new Error('O CPF inserido não é válido.'); } return true; }),\r\n    body('cnpj').if(body('tipoConta').equals('pessoa_juridica')).notEmpty().withMessage('O CNPJ é obrigatório.').custom((value) => { if (!cnpj.isValid(value)) { throw new Error('O CNPJ inserido não é válido.'); } return true; }),\r\n    body('terms').equals('on').withMessage('Você deve concordar com os termos e condições para se registar.'),\r\n    body('inscricaoEstadual').if(body('tipoConta').equals('pessoa_juridica')).if(body('isentoIE').not().exists()).notEmpty().withMessage('A Inscrição Estadual é obrigatória quando não isento.'),\r\n];\r\n\r\nrouter.post('/register', registerValidationRules, async (req, res) => {\r\n    const errors = validationResult(req);\r\n    if (!errors.isEmpty()) {\r\n        return res.status(400).json({ errors: errors.array() });\r\n    }\r\n\r\n    try {\r\n        const { email, celular, cpf: reqCpf, cnpj: reqCnpj } = req.body;\r\n\r\n        const conditions = [{ email }, { celular }];\r\n        if (reqCpf) conditions.push({ cpf: reqCpf });\r\n        if (reqCnpj) conditions.push({ cnpj: reqCnpj });\r\n\r\n        const userExists = await User.findOne({ $or: conditions });\r\n\r\n        if (userExists) {\r\n            let field, message;\r\n            if (userExists.email === email) {\r\n                field = 'email';\r\n                message = 'Este email já está a ser utilizado.';\r\n            } else if (userExists.celular === celular) {\r\n                field = 'celular';\r\n                message = 'Este número de celular já está a ser utilizado.';\r\n            } else if (reqCpf && userExists.cpf === reqCpf) {\r\n                field = 'cpf';\r\n                message = 'Este CPF já está a ser utilizado.';\r\n            } else if (reqCnpj && userExists.cnpj === reqCnpj) {\r\n                field = 'cnpj';\r\n                message = 'Este CNPJ já está a ser utilizado.';\r\n            }\r\n\r\n            if (field) {\r\n                return res.status(400).json({\r\n                    errors: [{\r\n                        path: field,\r\n                        msg: message,\r\n                    }]\r\n                });\r\n            }\r\n        }\r\n        \r\n        const salt = await bcrypt.genSalt(10);\r\n        const hashedPassword = await bcrypt.hash(req.body.senha, salt);\r\n        const isento = req.body.isentoIE === 'on';\r\n        const newUser = new User({\r\n            tipoConta: req.body.tipoConta,\r\n            email: req.body.email,\r\n            senha: hashedPassword,\r\n            celular: req.body.celular,\r\n            telefone: req.body.telefone,\r\n            nomeCompleto: req.body.nomeCompleto,\r\n            cpf: req.body.cpf,\r\n            genero: req.body.genero,\r\n            dataNascimento: req.body.dataNascimento,\r\n            razaoSocial: req.body.razaoSocial,\r\n            cnpj: req.body.cnpj,\r\n            nomeContato: req.body.nomeContato,\r\n            inscricaoEstadual: req.body.inscricaoEstadual,\r\n            estadoIE: req.body.estadoIE,\r\n            isentoIE: isento,\r\n        });\r\n\r\n        const savedUser = await newUser.save();\r\n\r\n        res.status(201).json({ \r\n            message: 'Utilizador registado com sucesso!', \r\n            user: { id: savedUser._id, nome: savedUser.nomeCompleto || savedUser.razaoSocial } \r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(error);\r\n        if (error.code === 11000) {\r\n            return res.status(400).json({ errors: [{ path: 'geral', msg: 'Um dos dados inseridos (email, CPF, CNPJ ou celular) já está em uso.' }] });\r\n        }\r\n        res.status(500).json({ message: 'Erro no servidor. Tente novamente mais tarde.' });\r\n    }\r\n});\r\n\r\n\r\n// ROTA: POST /api/login\r\nrouter.post('/login', async (req, res) => {\r\n    const { identifier, senha } = req.body;\r\n    try {\r\n        const user = await User.findOne({\r\n            $or: [{ email: identifier }, { cpf: identifier }, { cnpj: identifier }]\r\n        });\r\n        if (!user || !(await bcrypt.compare(senha, user.senha))) {\r\n            return res.status(400).json({ message: 'Credenciais inválidas.' });\r\n        }\r\n        res.status(200).json({\r\n        message: 'Login bem-sucedido!',\r\n        token,\r\n        user: {\r\n            id: user._id,\r\n            nome: user.nomeCompleto || user.razaoSocial || user.username,\r\n            email: user.email,\r\n            role: user.role   // <-- ADICIONE ESTA LINHA\r\n        }\r\n        });\r\n    } catch (error) {\r\n        res.status(500).json({ message: 'Erro no servidor.' });\r\n    }\r\n});\r\n\r\n// DESCRIÇÃO: Busca os dados de um utilizador específico pelo seu ID\r\nrouter.get('/users/:id', async (req, res) => {\r\n  try {\r\n    const user = await User.findById(req.params.id).select('-senha');\r\n    if (!user) {\r\n      return res.status(404).json({ message: 'Utilizador não encontrado.' });\r\n    }\r\n\r\n    res.status(200).json(user);\r\n    \r\n  } catch (error) {\r\n    console.error(error);\r\n    res.status(500).json({ message: 'Erro no servidor.' });\r\n  }\r\n});\r\n\r\n// DESCRIÇÃO: Atualiza os dados de um utilizador existente\r\nrouter.put('/users/:id', async (req, res) => {\r\n  try {\r\n    const userId = req.params.id;\r\n    const updateData = req.body;\r\n\r\n    // Encontra o utilizador pelo ID e atualiza-o com os novos dados\r\n    // { new: true } garante que a variável updatedUser contenha o documento já atualizado\r\n    const updatedUser = await User.findByIdAndUpdate(userId, updateData, { new: true }).select('-senha');\r\n\r\n    if (!updatedUser) {\r\n      return res.status(404).json({ message: 'Utilizador não encontrado.' });\r\n    }\r\n\r\n    // Se a atualização for bem-sucedida, envia uma resposta de sucesso com os dados atualizados\r\n    res.status(200).json({\r\n      message: 'Dados atualizados com sucesso!',\r\n      user: {\r\n        id: updatedUser._id,\r\n        nome: updatedUser.nomeCompleto || updatedUser.razaoSocial\r\n      }\r\n    });\r\n\r\n  } catch (error) {\r\n    console.error('Erro ao atualizar utilizador:', error);\r\n    res.status(500).json({ message: 'Erro no servidor. Tente novamente mais tarde.' });\r\n  }\r\n});\r\n\r\n// Exporta o router para que o nosso server.js o possa usar\r\nmodule.exports = router;"
        }
    ]
}