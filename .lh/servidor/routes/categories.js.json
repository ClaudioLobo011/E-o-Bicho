{
    "sourceFile": "servidor/routes/categories.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1756571367520,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1756571424629,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,238 @@\n+const express = require('express');\r\n+const router = express.Router();\r\n+const Category = require('../models/Category');\r\n+const authorizeRoles = require('../middlewares/authorizeRoles');\r\n+\r\n+// ROTA: GET /api/categories\r\n+// DESCRIÇÃO: Busca todas as categorias\r\n+router.get('/', async (req, res) => {\r\n+    try {\r\n+        const categories = await Category.find({}).sort({ nome: 1 }); // .sort({ nome: 1 }) para ordem alfabética\r\n+        res.json(categories);\r\n+    } catch (error) {\r\n+        res.status(500).json({ message: 'Erro no servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// ROTA: POST /api/categories\r\n+// DESCRIÇÃO: Cria uma nova categoria\r\n+router.post('/', authorizeRoles('admin', 'admin_master'), async (req, res) => {\r\n+    const { nome, parent } = req.body;\r\n+\r\n+    if (!nome) {\r\n+        return res.status(400).json({ message: 'O nome da categoria é obrigatório.' });\r\n+    }\r\n+\r\n+    try {\r\n+        const newCategory = new Category({\r\n+            nome,\r\n+            // Se 'parent' for uma string vazia ou nula, o Mongoose não a define, usando o 'default: null' do Schema\r\n+            parent: parent || null\r\n+        });\r\n+\r\n+        const savedCategory = await newCategory.save();\r\n+        res.status(201).json(savedCategory); // Responde com a categoria criada\r\n+\r\n+    } catch (error) {\r\n+        // O erro 11000 é o código do MongoDB para chaves duplicadas\r\n+        if (error.code === 11000) {\r\n+            return res.status(400).json({ message: 'Já existe uma categoria com este nome dentro da mesma categoria pai.' });\r\n+        }\r\n+        console.error(\"Erro ao criar categoria:\", error);\r\n+        res.status(500).json({ message: 'Erro no servidor ao criar a categoria.' });\r\n+    }\r\n+});\r\n+\r\n+router.get('/hierarchical', async (req, res) => {\r\n+    try {\r\n+        const allCategories = await Category.find({});\r\n+        \r\n+        // Função para construir a árvore\r\n+        const buildHierarchy = (categories, parentId = null) => {\r\n+            const result = [];\r\n+            const children = categories.filter(cat => String(cat.parent) === String(parentId));\r\n+            \r\n+            for (const child of children) {\r\n+                const grandchildren = buildHierarchy(categories, child._id);\r\n+                const categoryNode = {\r\n+                    _id: child._id,\r\n+                    nome: child.nome,\r\n+                    children: grandchildren\r\n+                };\r\n+                result.push(categoryNode);\r\n+            }\r\n+            return result;\r\n+        };\r\n+\r\n+        const hierarchicalCategories = buildHierarchy(allCategories);\r\n+        res.json(hierarchicalCategories);\r\n+\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao buscar categorias hierárquicas:\", error);\r\n+        res.status(500).json({ message: 'Erro no servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// DESCRIÇÃO: Busca as sub-categorias diretas de uma categoria pai, usando o nome do pai.\r\n+router.get('/subcategories', async (req, res) => {\r\n+    try {\r\n+        const { name: parentName, parent: grandParentName, grandparent: greatGrandParentName } = req.query;\r\n+        let parentQuery = { nome: new RegExp('^' + parentName + '$', 'i') };\r\n+\r\n+        if (grandParentName) {\r\n+            const grandParent = await Category.findOne({ nome: new RegExp('^' + grandParentName + '$', 'i') });\r\n+            if (grandParent) {\r\n+                parentQuery.parent = grandParent._id;\r\n+\r\n+                if (greatGrandParentName) {\r\n+                    const greatGrandParent = await Category.findOne({ nome: new RegExp('^' + greatGrandParentName + '$', 'i') });\r\n+                    if (greatGrandParent) {\r\n+                        const confirmedGrandParent = await Category.findOne({ nome: new RegExp('^' + grandParentName + '$', 'i'), parent: greatGrandParent._id });\r\n+                        if (confirmedGrandParent) {\r\n+                            parentQuery.parent = confirmedGrandParent._id;\r\n+                        }\r\n+                    }\r\n+                }\r\n+            }\r\n+        }\r\n+\r\n+        const parentCategory = await Category.findOne(parentQuery);\r\n+        if (!parentCategory) return res.json([]);\r\n+        \r\n+        const subCategories = await Category.find({ parent: parentCategory._id }).sort({ nome: 1 });\r\n+        res.json(subCategories);\r\n+    } catch (error) {\r\n+        console.error('Erro ao buscar sub-categorias:', error);\r\n+        res.status(500).json({ message: 'Erro no servidor' });\r\n+    }\r\n+});\r\n+\r\n+// DESCRIÇÃO: Encontra o caminho completo de uma categoria usando o nome e, opcionalmente, o nome do pai.\r\n+router.get('/path', async (req, res) => {\r\n+    try {\r\n+        const { name, parent: parentName, grandparent: grandParentName } = req.query;\r\n+        if (!name) return res.status(400).json({ message: 'O nome da categoria é obrigatório.' });\r\n+\r\n+        let query = { nome: new RegExp('^' + name + '$', 'i') };\r\n+\r\n+        if (parentName) {\r\n+            let parentCandidates = await Category.find({ nome: new RegExp('^' + parentName + '$', 'i') });\r\n+            if (grandParentName) {\r\n+                const grandParent = await Category.findOne({ nome: new RegExp('^' + grandParentName + '$', 'i') });\r\n+                if (grandParent) {\r\n+                    parentCandidates = await Category.find({ nome: new RegExp('^' + parentName + '$', 'i'), parent: grandParent._id });\r\n+                }\r\n+            }\r\n+            if (parentCandidates.length > 0) {\r\n+                query.parent = { $in: parentCandidates.map(p => p._id) };\r\n+            }\r\n+        } else {\r\n+            query.parent = null;\r\n+        }\r\n+\r\n+        let currentCategory = await Category.findOne(query);\r\n+        if (!currentCategory && !parentName) {\r\n+             currentCategory = await Category.findOne({ nome: new RegExp('^' + name + '$', 'i'), parent: null });\r\n+        }\r\n+        if (!currentCategory) return res.json([]);\r\n+\r\n+        const path = [];\r\n+        while (currentCategory) {\r\n+            path.unshift(currentCategory);\r\n+            currentCategory = currentCategory.parent ? await Category.findById(currentCategory.parent) : null;\r\n+        }\r\n+        \r\n+        res.json(path);\r\n+    } catch (error) {\r\n+        console.error('Erro ao buscar caminho da categoria:', error);\r\n+        res.status(500).json({ message: 'Erro no servidor' });\r\n+    }\r\n+});\r\n+\r\n+// ROTA: PUT /api/categories/:id\r\n+// DESCRIÇÃO: Atualiza uma categoria existente\r\n+router.put('/:id', authorizeRoles('admin', 'admin_master'), async (req, res) => {\r\n+    try {\r\n+        const {\r\n+            nome,\r\n+            parent\r\n+        } = req.body;\r\n+        const categoryId = req.params.id;\r\n+\r\n+        if (!nome) {\r\n+            return res.status(400).json({\r\n+                message: 'O nome da categoria é obrigatório.'\r\n+            });\r\n+        }\r\n+\r\n+        const updatedCategory = await Category.findByIdAndUpdate(\r\n+            categoryId, {\r\n+                nome,\r\n+                parent: parent || null\r\n+            }, {\r\n+                new: true, // Retorna o documento atualizado\r\n+                runValidators: true // Roda as validações do schema\r\n+            }\r\n+        );\r\n+\r\n+        if (!updatedCategory) {\r\n+            return res.status(404).json({\r\n+                message: 'Categoria não encontrada.'\r\n+            });\r\n+        }\r\n+\r\n+        res.json(updatedCategory);\r\n+\r\n+    } catch (error) {\r\n+        // Trata erro de duplicado (mesmo nome + mesmo pai)\r\n+        if (error.code === 11000) {\r\n+            return res.status(400).json({\r\n+                message: 'Já existe uma categoria com este nome dentro da mesma categoria pai.'\r\n+            });\r\n+        }\r\n+        console.error('Erro ao atualizar categoria:', error);\r\n+        res.status(500).json({\r\n+            message: 'Erro no servidor ao atualizar a categoria.'\r\n+        });\r\n+    }\r\n+});\r\n+\r\n+// ROTA: DELETE /api/categories/:id\r\n+// DESCRIÇÃO: Apaga uma categoria\r\n+router.delete('/:id', authorizeRoles('admin', 'admin_master'), async (req, res) => {\r\n+    try {\r\n+        const categoryId = req.params.id;\r\n+\r\n+        // 1. VERIFICAÇÃO DE SEGURANÇA: procurar se alguma categoria tem esta como pai\r\n+        const childCategory = await Category.findOne({ parent: categoryId });\r\n+\r\n+        if (childCategory) {\r\n+            // Se encontrou uma filha, retorna um erro e não apaga\r\n+            return res.status(400).json({\r\n+                message: 'Não é possível apagar esta categoria, pois ela contém sub-categorias.'\r\n+            });\r\n+        }\r\n+\r\n+        // 2. Se não encontrou filhas, apaga a categoria\r\n+        const deletedCategory = await Category.findByIdAndDelete(categoryId);\r\n+\r\n+        if (!deletedCategory) {\r\n+            return res.status(404).json({\r\n+                message: 'Categoria não encontrada.'\r\n+            });\r\n+        }\r\n+\r\n+        res.json({\r\n+            message: 'Categoria apagada com sucesso.'\r\n+        });\r\n+\r\n+    } catch (error) {\r\n+        console.error('Erro ao apagar categoria:', error);\r\n+        res.status(500).json({\r\n+            message: 'Erro no servidor ao apagar a categoria.'\r\n+        });\r\n+    }\r\n+});\r\n+\r\n+\r\n+module.exports = router;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1756579564141,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,23 +1,25 @@\n const express = require('express');\r\n const router = express.Router();\r\n const Category = require('../models/Category');\r\n+const requireAuth = require('../middlewares/requireAuth');\r\n const authorizeRoles = require('../middlewares/authorizeRoles');\r\n \r\n-// ROTA: GET /api/categories\r\n+// ROTA: GET /api/categories (pública)\r\n // DESCRIÇÃO: Busca todas as categorias\r\n router.get('/', async (req, res) => {\r\n     try {\r\n-        const categories = await Category.find({}).sort({ nome: 1 }); // .sort({ nome: 1 }) para ordem alfabética\r\n+        const categories = await Category.find({}).sort({ nome: 1 });\r\n         res.json(categories);\r\n     } catch (error) {\r\n+        console.error('Erro ao buscar categorias:', error);\r\n         res.status(500).json({ message: 'Erro no servidor.' });\r\n     }\r\n });\r\n \r\n-// ROTA: POST /api/categories\r\n+// ROTA: POST /api/categories (restrita a admin/admin_master)\r\n // DESCRIÇÃO: Cria uma nova categoria\r\n-router.post('/', authorizeRoles('admin', 'admin_master'), async (req, res) => {\r\n+router.post('/', requireAuth, authorizeRoles('admin', 'admin_master'), async (req, res) => {\r\n     const { nome, parent } = req.body;\r\n \r\n     if (!nome) {\r\n         return res.status(400).json({ message: 'O nome da categoria é obrigatório.' });\r\n@@ -25,56 +27,48 @@\n \r\n     try {\r\n         const newCategory = new Category({\r\n             nome,\r\n-            // Se 'parent' for uma string vazia ou nula, o Mongoose não a define, usando o 'default: null' do Schema\r\n             parent: parent || null\r\n         });\r\n \r\n         const savedCategory = await newCategory.save();\r\n-        res.status(201).json(savedCategory); // Responde com a categoria criada\r\n+        res.status(201).json(savedCategory);\r\n \r\n     } catch (error) {\r\n-        // O erro 11000 é o código do MongoDB para chaves duplicadas\r\n         if (error.code === 11000) {\r\n             return res.status(400).json({ message: 'Já existe uma categoria com este nome dentro da mesma categoria pai.' });\r\n         }\r\n         console.error(\"Erro ao criar categoria:\", error);\r\n         res.status(500).json({ message: 'Erro no servidor ao criar a categoria.' });\r\n     }\r\n });\r\n \r\n+// ROTA: GET /api/categories/hierarchical (pública)\r\n router.get('/hierarchical', async (req, res) => {\r\n     try {\r\n         const allCategories = await Category.find({});\r\n-        \r\n-        // Função para construir a árvore\r\n         const buildHierarchy = (categories, parentId = null) => {\r\n             const result = [];\r\n             const children = categories.filter(cat => String(cat.parent) === String(parentId));\r\n-            \r\n             for (const child of children) {\r\n                 const grandchildren = buildHierarchy(categories, child._id);\r\n-                const categoryNode = {\r\n+                result.push({\r\n                     _id: child._id,\r\n                     nome: child.nome,\r\n                     children: grandchildren\r\n-                };\r\n-                result.push(categoryNode);\r\n+                });\r\n             }\r\n             return result;\r\n         };\r\n-\r\n-        const hierarchicalCategories = buildHierarchy(allCategories);\r\n-        res.json(hierarchicalCategories);\r\n-\r\n+        res.json(buildHierarchy(allCategories));\r\n     } catch (error) {\r\n         console.error(\"Erro ao buscar categorias hierárquicas:\", error);\r\n         res.status(500).json({ message: 'Erro no servidor.' });\r\n     }\r\n });\r\n \r\n-// DESCRIÇÃO: Busca as sub-categorias diretas de uma categoria pai, usando o nome do pai.\r\n+// ROTA: GET /api/categories/subcategories (pública)\r\n router.get('/subcategories', async (req, res) => {\r\n     try {\r\n         const { name: parentName, parent: grandParentName, grandparent: greatGrandParentName } = req.query;\r\n         let parentQuery = { nome: new RegExp('^' + parentName + '$', 'i') };\r\n@@ -82,9 +76,8 @@\n         if (grandParentName) {\r\n             const grandParent = await Category.findOne({ nome: new RegExp('^' + grandParentName + '$', 'i') });\r\n             if (grandParent) {\r\n                 parentQuery.parent = grandParent._id;\r\n-\r\n                 if (greatGrandParentName) {\r\n                     const greatGrandParent = await Category.findOne({ nome: new RegExp('^' + greatGrandParentName + '$', 'i') });\r\n                     if (greatGrandParent) {\r\n                         const confirmedGrandParent = await Category.findOne({ nome: new RegExp('^' + grandParentName + '$', 'i'), parent: greatGrandParent._id });\r\n@@ -97,18 +90,18 @@\n         }\r\n \r\n         const parentCategory = await Category.findOne(parentQuery);\r\n         if (!parentCategory) return res.json([]);\r\n-        \r\n+\r\n         const subCategories = await Category.find({ parent: parentCategory._id }).sort({ nome: 1 });\r\n         res.json(subCategories);\r\n     } catch (error) {\r\n         console.error('Erro ao buscar sub-categorias:', error);\r\n         res.status(500).json({ message: 'Erro no servidor' });\r\n     }\r\n });\r\n \r\n-// DESCRIÇÃO: Encontra o caminho completo de uma categoria usando o nome e, opcionalmente, o nome do pai.\r\n+// ROTA: GET /api/categories/path (pública)\r\n router.get('/path', async (req, res) => {\r\n     try {\r\n         const { name, parent: parentName, grandparent: grandParentName } = req.query;\r\n         if (!name) return res.status(400).json({ message: 'O nome da categoria é obrigatório.' });\r\n@@ -131,346 +124,73 @@\n         }\r\n \r\n         let currentCategory = await Category.findOne(query);\r\n         if (!currentCategory && !parentName) {\r\n-             currentCategory = await Category.findOne({ nome: new RegExp('^' + name + '$', 'i'), parent: null });\r\n+            currentCategory = await Category.findOne({ nome: new RegExp('^' + name + '$', 'i'), parent: null });\r\n         }\r\n         if (!currentCategory) return res.json([]);\r\n \r\n         const path = [];\r\n         while (currentCategory) {\r\n             path.unshift(currentCategory);\r\n             currentCategory = currentCategory.parent ? await Category.findById(currentCategory.parent) : null;\r\n         }\r\n-        \r\n         res.json(path);\r\n     } catch (error) {\r\n         console.error('Erro ao buscar caminho da categoria:', error);\r\n         res.status(500).json({ message: 'Erro no servidor' });\r\n     }\r\n });\r\n \r\n-// ROTA: PUT /api/categories/:id\r\n-// DESCRIÇÃO: Atualiza uma categoria existente\r\n-router.put('/:id', authorizeRoles('admin', 'admin_master'), async (req, res) => {\r\n+// ROTA: PUT /api/categories/:id (restrita a admin/admin_master)\r\n+router.put('/:id', requireAuth, authorizeRoles('admin', 'admin_master'), async (req, res) => {\r\n     try {\r\n-        const {\r\n-            nome,\r\n-            parent\r\n-        } = req.body;\r\n+        const { nome, parent } = req.body;\r\n         const categoryId = req.params.id;\r\n \r\n         if (!nome) {\r\n-            return res.status(400).json({\r\n-                message: 'O nome da categoria é obrigatório.'\r\n-            });\r\n+            return res.status(400).json({ message: 'O nome da categoria é obrigatório.' });\r\n         }\r\n \r\n         const updatedCategory = await Category.findByIdAndUpdate(\r\n-            categoryId, {\r\n-                nome,\r\n-                parent: parent || null\r\n-            }, {\r\n-                new: true, // Retorna o documento atualizado\r\n-                runValidators: true // Roda as validações do schema\r\n-            }\r\n+            categoryId,\r\n+            { nome, parent: parent || null },\r\n+            { new: true, runValidators: true }\r\n         );\r\n \r\n         if (!updatedCategory) {\r\n-            return res.status(404).json({\r\n-                message: 'Categoria não encontrada.'\r\n-            });\r\n+            return res.status(404).json({ message: 'Categoria não encontrada.' });\r\n         }\r\n \r\n         res.json(updatedCategory);\r\n-\r\n     } catch (error) {\r\n-        // Trata erro de duplicado (mesmo nome + mesmo pai)\r\n         if (error.code === 11000) {\r\n-            return res.status(400).json({\r\n-                message: 'Já existe uma categoria com este nome dentro da mesma categoria pai.'\r\n-            });\r\n-        }\r\n-        console.error('Erro ao atualizar categoria:', error);\r\n-        res.status(500).json({\r\n-            message: 'Erro no servidor ao atualizar a categoria.'\r\n-        });\r\n-    }\r\n-});\r\n-\r\n-// ROTA: DELETE /api/categories/:id\r\n-// DESCRIÇÃO: Apaga uma categoria\r\n-router.delete('/:id', authorizeRoles('admin', 'admin_master'), async (req, res) => {\r\n-    try {\r\n-        const categoryId = req.params.id;\r\n-\r\n-        // 1. VERIFICAÇÃO DE SEGURANÇA: procurar se alguma categoria tem esta como pai\r\n-        const childCategory = await Category.findOne({ parent: categoryId });\r\n-\r\n-        if (childCategory) {\r\n-            // Se encontrou uma filha, retorna um erro e não apaga\r\n-            return res.status(400).json({\r\n-                message: 'Não é possível apagar esta categoria, pois ela contém sub-categorias.'\r\n-            });\r\n-        }\r\n-\r\n-        // 2. Se não encontrou filhas, apaga a categoria\r\n-        const deletedCategory = await Category.findByIdAndDelete(categoryId);\r\n-\r\n-        if (!deletedCategory) {\r\n-            return res.status(404).json({\r\n-                message: 'Categoria não encontrada.'\r\n-            });\r\n-        }\r\n-\r\n-        res.json({\r\n-            message: 'Categoria apagada com sucesso.'\r\n-        });\r\n-\r\n-    } catch (error) {\r\n-        console.error('Erro ao apagar categoria:', error);\r\n-        res.status(500).json({\r\n-            message: 'Erro no servidor ao apagar a categoria.'\r\n-        });\r\n-    }\r\n-});\r\n-\r\n-\r\n-module.exports = router;\n-const express = require('express');\r\n-const router = express.Router();\r\n-const Category = require('../models/Category');\r\n-const authorizeRoles = require('../middlewares/authorizeRoles');\r\n-\r\n-// ROTA: GET /api/categories\r\n-// DESCRIÇÃO: Busca todas as categorias\r\n-router.get('/', async (req, res) => {\r\n-    try {\r\n-        const categories = await Category.find({}).sort({ nome: 1 }); // .sort({ nome: 1 }) para ordem alfabética\r\n-        res.json(categories);\r\n-    } catch (error) {\r\n-        res.status(500).json({ message: 'Erro no servidor.' });\r\n-    }\r\n-});\r\n-\r\n-// ROTA: POST /api/categories\r\n-// DESCRIÇÃO: Cria uma nova categoria\r\n-router.post('/', authorizeRoles('admin', 'admin_master'), async (req, res) => {\r\n-    const { nome, parent } = req.body;\r\n-\r\n-    if (!nome) {\r\n-        return res.status(400).json({ message: 'O nome da categoria é obrigatório.' });\r\n-    }\r\n-\r\n-    try {\r\n-        const newCategory = new Category({\r\n-            nome,\r\n-            // Se 'parent' for uma string vazia ou nula, o Mongoose não a define, usando o 'default: null' do Schema\r\n-            parent: parent || null\r\n-        });\r\n-\r\n-        const savedCategory = await newCategory.save();\r\n-        res.status(201).json(savedCategory); // Responde com a categoria criada\r\n-\r\n-    } catch (error) {\r\n-        // O erro 11000 é o código do MongoDB para chaves duplicadas\r\n-        if (error.code === 11000) {\r\n             return res.status(400).json({ message: 'Já existe uma categoria com este nome dentro da mesma categoria pai.' });\r\n         }\r\n-        console.error(\"Erro ao criar categoria:\", error);\r\n-        res.status(500).json({ message: 'Erro no servidor ao criar a categoria.' });\r\n-    }\r\n-});\r\n-\r\n-router.get('/hierarchical', async (req, res) => {\r\n-    try {\r\n-        const allCategories = await Category.find({});\r\n-        \r\n-        // Função para construir a árvore\r\n-        const buildHierarchy = (categories, parentId = null) => {\r\n-            const result = [];\r\n-            const children = categories.filter(cat => String(cat.parent) === String(parentId));\r\n-            \r\n-            for (const child of children) {\r\n-                const grandchildren = buildHierarchy(categories, child._id);\r\n-                const categoryNode = {\r\n-                    _id: child._id,\r\n-                    nome: child.nome,\r\n-                    children: grandchildren\r\n-                };\r\n-                result.push(categoryNode);\r\n-            }\r\n-            return result;\r\n-        };\r\n-\r\n-        const hierarchicalCategories = buildHierarchy(allCategories);\r\n-        res.json(hierarchicalCategories);\r\n-\r\n-    } catch (error) {\r\n-        console.error(\"Erro ao buscar categorias hierárquicas:\", error);\r\n-        res.status(500).json({ message: 'Erro no servidor.' });\r\n-    }\r\n-});\r\n-\r\n-// DESCRIÇÃO: Busca as sub-categorias diretas de uma categoria pai, usando o nome do pai.\r\n-router.get('/subcategories', async (req, res) => {\r\n-    try {\r\n-        const { name: parentName, parent: grandParentName, grandparent: greatGrandParentName } = req.query;\r\n-        let parentQuery = { nome: new RegExp('^' + parentName + '$', 'i') };\r\n-\r\n-        if (grandParentName) {\r\n-            const grandParent = await Category.findOne({ nome: new RegExp('^' + grandParentName + '$', 'i') });\r\n-            if (grandParent) {\r\n-                parentQuery.parent = grandParent._id;\r\n-\r\n-                if (greatGrandParentName) {\r\n-                    const greatGrandParent = await Category.findOne({ nome: new RegExp('^' + greatGrandParentName + '$', 'i') });\r\n-                    if (greatGrandParent) {\r\n-                        const confirmedGrandParent = await Category.findOne({ nome: new RegExp('^' + grandParentName + '$', 'i'), parent: greatGrandParent._id });\r\n-                        if (confirmedGrandParent) {\r\n-                            parentQuery.parent = confirmedGrandParent._id;\r\n-                        }\r\n-                    }\r\n-                }\r\n-            }\r\n-        }\r\n-\r\n-        const parentCategory = await Category.findOne(parentQuery);\r\n-        if (!parentCategory) return res.json([]);\r\n-        \r\n-        const subCategories = await Category.find({ parent: parentCategory._id }).sort({ nome: 1 });\r\n-        res.json(subCategories);\r\n-    } catch (error) {\r\n-        console.error('Erro ao buscar sub-categorias:', error);\r\n-        res.status(500).json({ message: 'Erro no servidor' });\r\n-    }\r\n-});\r\n-\r\n-// DESCRIÇÃO: Encontra o caminho completo de uma categoria usando o nome e, opcionalmente, o nome do pai.\r\n-router.get('/path', async (req, res) => {\r\n-    try {\r\n-        const { name, parent: parentName, grandparent: grandParentName } = req.query;\r\n-        if (!name) return res.status(400).json({ message: 'O nome da categoria é obrigatório.' });\r\n-\r\n-        let query = { nome: new RegExp('^' + name + '$', 'i') };\r\n-\r\n-        if (parentName) {\r\n-            let parentCandidates = await Category.find({ nome: new RegExp('^' + parentName + '$', 'i') });\r\n-            if (grandParentName) {\r\n-                const grandParent = await Category.findOne({ nome: new RegExp('^' + grandParentName + '$', 'i') });\r\n-                if (grandParent) {\r\n-                    parentCandidates = await Category.find({ nome: new RegExp('^' + parentName + '$', 'i'), parent: grandParent._id });\r\n-                }\r\n-            }\r\n-            if (parentCandidates.length > 0) {\r\n-                query.parent = { $in: parentCandidates.map(p => p._id) };\r\n-            }\r\n-        } else {\r\n-            query.parent = null;\r\n-        }\r\n-\r\n-        let currentCategory = await Category.findOne(query);\r\n-        if (!currentCategory && !parentName) {\r\n-             currentCategory = await Category.findOne({ nome: new RegExp('^' + name + '$', 'i'), parent: null });\r\n-        }\r\n-        if (!currentCategory) return res.json([]);\r\n-\r\n-        const path = [];\r\n-        while (currentCategory) {\r\n-            path.unshift(currentCategory);\r\n-            currentCategory = currentCategory.parent ? await Category.findById(currentCategory.parent) : null;\r\n-        }\r\n-        \r\n-        res.json(path);\r\n-    } catch (error) {\r\n-        console.error('Erro ao buscar caminho da categoria:', error);\r\n-        res.status(500).json({ message: 'Erro no servidor' });\r\n-    }\r\n-});\r\n-\r\n-// ROTA: PUT /api/categories/:id\r\n-// DESCRIÇÃO: Atualiza uma categoria existente\r\n-router.put('/:id', async (req, res) => {\r\n-    try {\r\n-        const {\r\n-            nome,\r\n-            parent\r\n-        } = req.body;\r\n-        const categoryId = req.params.id;\r\n-\r\n-        if (!nome) {\r\n-            return res.status(400).json({\r\n-                message: 'O nome da categoria é obrigatório.'\r\n-            });\r\n-        }\r\n-\r\n-        const updatedCategory = await Category.findByIdAndUpdate(\r\n-            categoryId, {\r\n-                nome,\r\n-                parent: parent || null\r\n-            }, {\r\n-                new: true, // Retorna o documento atualizado\r\n-                runValidators: true // Roda as validações do schema\r\n-            }\r\n-        );\r\n-\r\n-        if (!updatedCategory) {\r\n-            return res.status(404).json({\r\n-                message: 'Categoria não encontrada.'\r\n-            });\r\n-        }\r\n-\r\n-        res.json(updatedCategory);\r\n-\r\n-    } catch (error) {\r\n-        // Trata erro de duplicado (mesmo nome + mesmo pai)\r\n-        if (error.code === 11000) {\r\n-            return res.status(400).json({\r\n-                message: 'Já existe uma categoria com este nome dentro da mesma categoria pai.'\r\n-            });\r\n-        }\r\n         console.error('Erro ao atualizar categoria:', error);\r\n-        res.status(500).json({\r\n-            message: 'Erro no servidor ao atualizar a categoria.'\r\n-        });\r\n+        res.status(500).json({ message: 'Erro no servidor ao atualizar a categoria.' });\r\n     }\r\n });\r\n \r\n-// ROTA: DELETE /api/categories/:id\r\n-// DESCRIÇÃO: Apaga uma categoria\r\n-router.delete('/:id', async (req, res) => {\r\n+// ROTA: DELETE /api/categories/:id (restrita a admin/admin_master)\r\n+router.delete('/:id', requireAuth, authorizeRoles('admin', 'admin_master'), async (req, res) => {\r\n     try {\r\n         const categoryId = req.params.id;\r\n \r\n-        // 1. VERIFICAÇÃO DE SEGURANÇA: procurar se alguma categoria tem esta como pai\r\n         const childCategory = await Category.findOne({ parent: categoryId });\r\n-\r\n         if (childCategory) {\r\n-            // Se encontrou uma filha, retorna um erro e não apaga\r\n-            return res.status(400).json({\r\n-                message: 'Não é possível apagar esta categoria, pois ela contém sub-categorias.'\r\n-            });\r\n+            return res.status(400).json({ message: 'Não é possível apagar esta categoria, pois ela contém sub-categorias.' });\r\n         }\r\n \r\n-        // 2. Se não encontrou filhas, apaga a categoria\r\n         const deletedCategory = await Category.findByIdAndDelete(categoryId);\r\n-\r\n         if (!deletedCategory) {\r\n-            return res.status(404).json({\r\n-                message: 'Categoria não encontrada.'\r\n-            });\r\n+            return res.status(404).json({ message: 'Categoria não encontrada.' });\r\n         }\r\n \r\n\\ No newline at end of file\n-        res.json({\r\n-            message: 'Categoria apagada com sucesso.'\r\n-        });\r\n-\r\n+        res.json({ message: 'Categoria apagada com sucesso.' });\r\n     } catch (error) {\r\n         console.error('Erro ao apagar categoria:', error);\r\n-        res.status(500).json({\r\n-            message: 'Erro no servidor ao apagar a categoria.'\r\n-        });\r\n+        res.status(500).json({ message: 'Erro no servidor ao apagar a categoria.' });\r\n     }\r\n });\r\n \r\n-\r\n-module.exports = router;\n+module.exports = router;\r\n"
                }
            ],
            "date": 1756571367520,
            "name": "Commit-0",
            "content": "const express = require('express');\r\nconst router = express.Router();\r\nconst Category = require('../models/Category');\r\nconst authorizeRoles = require('../middlewares/authorizeRoles');\r\n\r\n// ROTA: GET /api/categories\r\n// DESCRIÇÃO: Busca todas as categorias\r\nrouter.get('/', async (req, res) => {\r\n    try {\r\n        const categories = await Category.find({}).sort({ nome: 1 }); // .sort({ nome: 1 }) para ordem alfabética\r\n        res.json(categories);\r\n    } catch (error) {\r\n        res.status(500).json({ message: 'Erro no servidor.' });\r\n    }\r\n});\r\n\r\n// ROTA: POST /api/categories\r\n// DESCRIÇÃO: Cria uma nova categoria\r\nrouter.post('/', authorizeRoles('admin', 'admin_master'), async (req, res) => {\r\n    const { nome, parent } = req.body;\r\n\r\n    if (!nome) {\r\n        return res.status(400).json({ message: 'O nome da categoria é obrigatório.' });\r\n    }\r\n\r\n    try {\r\n        const newCategory = new Category({\r\n            nome,\r\n            // Se 'parent' for uma string vazia ou nula, o Mongoose não a define, usando o 'default: null' do Schema\r\n            parent: parent || null\r\n        });\r\n\r\n        const savedCategory = await newCategory.save();\r\n        res.status(201).json(savedCategory); // Responde com a categoria criada\r\n\r\n    } catch (error) {\r\n        // O erro 11000 é o código do MongoDB para chaves duplicadas\r\n        if (error.code === 11000) {\r\n            return res.status(400).json({ message: 'Já existe uma categoria com este nome dentro da mesma categoria pai.' });\r\n        }\r\n        console.error(\"Erro ao criar categoria:\", error);\r\n        res.status(500).json({ message: 'Erro no servidor ao criar a categoria.' });\r\n    }\r\n});\r\n\r\nrouter.get('/hierarchical', async (req, res) => {\r\n    try {\r\n        const allCategories = await Category.find({});\r\n        \r\n        // Função para construir a árvore\r\n        const buildHierarchy = (categories, parentId = null) => {\r\n            const result = [];\r\n            const children = categories.filter(cat => String(cat.parent) === String(parentId));\r\n            \r\n            for (const child of children) {\r\n                const grandchildren = buildHierarchy(categories, child._id);\r\n                const categoryNode = {\r\n                    _id: child._id,\r\n                    nome: child.nome,\r\n                    children: grandchildren\r\n                };\r\n                result.push(categoryNode);\r\n            }\r\n            return result;\r\n        };\r\n\r\n        const hierarchicalCategories = buildHierarchy(allCategories);\r\n        res.json(hierarchicalCategories);\r\n\r\n    } catch (error) {\r\n        console.error(\"Erro ao buscar categorias hierárquicas:\", error);\r\n        res.status(500).json({ message: 'Erro no servidor.' });\r\n    }\r\n});\r\n\r\n// DESCRIÇÃO: Busca as sub-categorias diretas de uma categoria pai, usando o nome do pai.\r\nrouter.get('/subcategories', async (req, res) => {\r\n    try {\r\n        const { name: parentName, parent: grandParentName, grandparent: greatGrandParentName } = req.query;\r\n        let parentQuery = { nome: new RegExp('^' + parentName + '$', 'i') };\r\n\r\n        if (grandParentName) {\r\n            const grandParent = await Category.findOne({ nome: new RegExp('^' + grandParentName + '$', 'i') });\r\n            if (grandParent) {\r\n                parentQuery.parent = grandParent._id;\r\n\r\n                if (greatGrandParentName) {\r\n                    const greatGrandParent = await Category.findOne({ nome: new RegExp('^' + greatGrandParentName + '$', 'i') });\r\n                    if (greatGrandParent) {\r\n                        const confirmedGrandParent = await Category.findOne({ nome: new RegExp('^' + grandParentName + '$', 'i'), parent: greatGrandParent._id });\r\n                        if (confirmedGrandParent) {\r\n                            parentQuery.parent = confirmedGrandParent._id;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        const parentCategory = await Category.findOne(parentQuery);\r\n        if (!parentCategory) return res.json([]);\r\n        \r\n        const subCategories = await Category.find({ parent: parentCategory._id }).sort({ nome: 1 });\r\n        res.json(subCategories);\r\n    } catch (error) {\r\n        console.error('Erro ao buscar sub-categorias:', error);\r\n        res.status(500).json({ message: 'Erro no servidor' });\r\n    }\r\n});\r\n\r\n// DESCRIÇÃO: Encontra o caminho completo de uma categoria usando o nome e, opcionalmente, o nome do pai.\r\nrouter.get('/path', async (req, res) => {\r\n    try {\r\n        const { name, parent: parentName, grandparent: grandParentName } = req.query;\r\n        if (!name) return res.status(400).json({ message: 'O nome da categoria é obrigatório.' });\r\n\r\n        let query = { nome: new RegExp('^' + name + '$', 'i') };\r\n\r\n        if (parentName) {\r\n            let parentCandidates = await Category.find({ nome: new RegExp('^' + parentName + '$', 'i') });\r\n            if (grandParentName) {\r\n                const grandParent = await Category.findOne({ nome: new RegExp('^' + grandParentName + '$', 'i') });\r\n                if (grandParent) {\r\n                    parentCandidates = await Category.find({ nome: new RegExp('^' + parentName + '$', 'i'), parent: grandParent._id });\r\n                }\r\n            }\r\n            if (parentCandidates.length > 0) {\r\n                query.parent = { $in: parentCandidates.map(p => p._id) };\r\n            }\r\n        } else {\r\n            query.parent = null;\r\n        }\r\n\r\n        let currentCategory = await Category.findOne(query);\r\n        if (!currentCategory && !parentName) {\r\n             currentCategory = await Category.findOne({ nome: new RegExp('^' + name + '$', 'i'), parent: null });\r\n        }\r\n        if (!currentCategory) return res.json([]);\r\n\r\n        const path = [];\r\n        while (currentCategory) {\r\n            path.unshift(currentCategory);\r\n            currentCategory = currentCategory.parent ? await Category.findById(currentCategory.parent) : null;\r\n        }\r\n        \r\n        res.json(path);\r\n    } catch (error) {\r\n        console.error('Erro ao buscar caminho da categoria:', error);\r\n        res.status(500).json({ message: 'Erro no servidor' });\r\n    }\r\n});\r\n\r\n// ROTA: PUT /api/categories/:id\r\n// DESCRIÇÃO: Atualiza uma categoria existente\r\nrouter.put('/:id', async (req, res) => {\r\n    try {\r\n        const {\r\n            nome,\r\n            parent\r\n        } = req.body;\r\n        const categoryId = req.params.id;\r\n\r\n        if (!nome) {\r\n            return res.status(400).json({\r\n                message: 'O nome da categoria é obrigatório.'\r\n            });\r\n        }\r\n\r\n        const updatedCategory = await Category.findByIdAndUpdate(\r\n            categoryId, {\r\n                nome,\r\n                parent: parent || null\r\n            }, {\r\n                new: true, // Retorna o documento atualizado\r\n                runValidators: true // Roda as validações do schema\r\n            }\r\n        );\r\n\r\n        if (!updatedCategory) {\r\n            return res.status(404).json({\r\n                message: 'Categoria não encontrada.'\r\n            });\r\n        }\r\n\r\n        res.json(updatedCategory);\r\n\r\n    } catch (error) {\r\n        // Trata erro de duplicado (mesmo nome + mesmo pai)\r\n        if (error.code === 11000) {\r\n            return res.status(400).json({\r\n                message: 'Já existe uma categoria com este nome dentro da mesma categoria pai.'\r\n            });\r\n        }\r\n        console.error('Erro ao atualizar categoria:', error);\r\n        res.status(500).json({\r\n            message: 'Erro no servidor ao atualizar a categoria.'\r\n        });\r\n    }\r\n});\r\n\r\n// ROTA: DELETE /api/categories/:id\r\n// DESCRIÇÃO: Apaga uma categoria\r\nrouter.delete('/:id', async (req, res) => {\r\n    try {\r\n        const categoryId = req.params.id;\r\n\r\n        // 1. VERIFICAÇÃO DE SEGURANÇA: procurar se alguma categoria tem esta como pai\r\n        const childCategory = await Category.findOne({ parent: categoryId });\r\n\r\n        if (childCategory) {\r\n            // Se encontrou uma filha, retorna um erro e não apaga\r\n            return res.status(400).json({\r\n                message: 'Não é possível apagar esta categoria, pois ela contém sub-categorias.'\r\n            });\r\n        }\r\n\r\n        // 2. Se não encontrou filhas, apaga a categoria\r\n        const deletedCategory = await Category.findByIdAndDelete(categoryId);\r\n\r\n        if (!deletedCategory) {\r\n            return res.status(404).json({\r\n                message: 'Categoria não encontrada.'\r\n            });\r\n        }\r\n\r\n        res.json({\r\n            message: 'Categoria apagada com sucesso.'\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error('Erro ao apagar categoria:', error);\r\n        res.status(500).json({\r\n            message: 'Erro no servidor ao apagar a categoria.'\r\n        });\r\n    }\r\n});\r\n\r\n\r\nmodule.exports = router;"
        }
    ]
}