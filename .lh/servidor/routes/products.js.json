{
    "sourceFile": "servidor/routes/products.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 3,
            "patches": [
                {
                    "date": 1756571571585,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1756580177628,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,8 +5,9 @@\n const Product = require('../models/Product');\r\n const Category = require('../models/Category');\r\n const multer = require('multer');\r\n const fs = require('fs');\r\n+const requireAuth = require('../middlewares/requireAuth');\r\n const authorizeRoles = require('../middlewares/authorizeRoles');\r\n \r\n // Configuração do Multer para upload de imagens\r\n const storage = multer.diskStorage({\r\n@@ -19,14 +20,12 @@\n     }\r\n });\r\n const upload = multer({ storage: storage });\r\n \r\n-\r\n // ========================================================================\r\n // ========= ROTAS ESPECÍFICAS (Devem vir primeiro) =======================\r\n // ========================================================================\r\n \r\n-// DESCRIÇÃO: Busca produtos que pertencem EXATAMENTE a uma categoria pelo nome.\r\n // Função auxiliar recursiva para encontrar todos os IDs de sub-categorias\r\n async function findAllSubCategoryIds(categoryId) {\r\n     let ids = [categoryId];\r\n     const children = await Category.find({ parent: categoryId });\r\n@@ -35,8 +34,9 @@\n     }\r\n     return ids;\r\n }\r\n \r\n+// GET /api/products/by-category (pública)\r\n router.get('/by-category', async (req, res) => {\r\n     try {\r\n         const { name: categoryName, parent: parentName, grandparent: grandParentName } = req.query;\r\n         let query = { nome: new RegExp('^' + categoryName + '$', 'i') };\r\n@@ -60,18 +60,22 @@\n         const topCategory = await Category.findOne(query);\r\n         if (!topCategory) return res.json({ products: [], page: 1, pages: 1, total: 0 });\r\n \r\n         const allCategoryIds = await findAllSubCategoryIds(topCategory._id);\r\n-        const products = await Product.find({ categorias: { $in: allCategoryIds } }).populate('categorias').sort({ nome: 1 }).lean();\r\n+        const products = await Product.find({ categorias: { $in: allCategoryIds } })\r\n+            .populate('categorias')\r\n+            .sort({ nome: 1 })\r\n+            .lean();\r\n+\r\n         products.forEach(p => { if (!p.imagemPrincipal) p.imagemPrincipal = '/image/placeholder.png'; });\r\n         res.json({ products, page: 1, pages: 1, total: products.length });\r\n     } catch (error) {\r\n         console.error(\"Erro ao buscar produtos por categoria:\", error);\r\n         res.status(500).json({ message: 'Erro no servidor.' });\r\n     }\r\n });\r\n \r\n-// ROTA: GET / - Listar todos os produtos (rota principal com busca e paginação)\r\n+// GET /api/products (pública, listagem com paginação e busca)\r\n router.get('/', async (req, res) => {\r\n     try {\r\n         const { page = 1, limit = 20, search = '' } = req.query;\r\n         const query = {};\r\n@@ -85,13 +89,12 @@\n             .limit(parseInt(limit))\r\n             .skip(parseInt(limit) * (page - 1))\r\n             .populate('categorias')\r\n             .sort({ nome: 1 })\r\n-            .lean(); // Usar .lean() para melhor performance e facilitar manipulação\r\n-        \r\n+            .lean();\r\n+\r\n         const total = await Product.countDocuments(query);\r\n-        \r\n-        // Garante que todos os produtos tenham uma imagem principal\r\n+\r\n         products.forEach(p => {\r\n             if (!p.imagemPrincipal) {\r\n                 p.imagemPrincipal = '/image/placeholder.png';\r\n             }\r\n@@ -108,9 +111,9 @@\n         res.status(500).json({ message: 'Erro no servidor.' });\r\n     }\r\n });\r\n \r\n-// ROTA: GET /destaques\r\n+// GET /api/products/destaques (pública)\r\n router.get('/destaques', async (req, res) => {\r\n     try {\r\n         const destaques = await Product.find({ isDestaque: true }).sort({ destaqueOrder: 1 });\r\n         res.json(destaques);\r\n@@ -118,51 +121,36 @@\n         res.status(500).json({ message: 'Erro ao buscar produtos em destaque.' });\r\n     }\r\n });\r\n \r\n-// ROTA: PUT /bulk-update-category\r\n-router.put('/bulk-update-category', authorizeRoles('admin', 'admin_master'), async (req, res) => {\r\n+// PUT /api/products/bulk-update-category (restrito)\r\n+router.put('/bulk-update-category', requireAuth, authorizeRoles('admin', 'admin_master'), async (req, res) => {\r\n     try {\r\n-        // Pega o novo campo brandName do corpo do pedido\r\n-        const { productIds, newCategoryId, brandName } = req.body; \r\n-\r\n+        const { productIds, newCategoryId, brandName } = req.body;\r\n         if (!productIds || !newCategoryId || !Array.isArray(productIds) || productIds.length === 0) {\r\n             return res.status(400).json({ message: 'Dados inválidos ou nenhum produto selecionado.' });\r\n         }\r\n \r\n-        // 1. Cria o objeto de atualização base para adicionar a categoria\r\n-        const updateOperation = {\r\n-            $addToSet: { categorias: newCategoryId }\r\n-        };\r\n+        const updateOperation = { $addToSet: { categorias: newCategoryId } };\r\n+        if (brandName) updateOperation.$set = { marca: brandName };\r\n \r\n-        // 2. Se um nome de marca foi enviado, adiciona a atualização do campo 'marca'\r\n-        if (brandName) {\r\n-            updateOperation.$set = { marca: brandName };\r\n-        }\r\n-\r\n-        // 3. Executa a atualização na base de dados com as operações combinadas\r\n-        const result = await Product.updateMany(\r\n-            { _id: { $in: productIds } }, \r\n-            updateOperation\r\n-        );\r\n-        \r\n+        const result = await Product.updateMany({ _id: { $in: productIds } }, updateOperation);\r\n         res.json({ message: `${result.modifiedCount} produtos foram atualizados com sucesso.` });\r\n-\r\n     } catch (error) {\r\n         console.error(\"Erro ao atualizar produtos em massa:\", error);\r\n         res.status(500).json({ message: 'Erro no servidor.' });\r\n     }\r\n });\r\n \r\n-// ROTA: PUT /destaques/order\r\n-router.put('/destaques/order', authorizeRoles('admin', 'admin_master'), async (req, res) => {\r\n+// PUT /api/products/destaques/order (restrito)\r\n+router.put('/destaques/order', requireAuth, authorizeRoles('admin', 'admin_master'), async (req, res) => {\r\n     try {\r\n         const { orderedIds } = req.body;\r\n         if (!Array.isArray(orderedIds)) {\r\n             return res.status(400).json({ message: 'Formato de dados inválido.' });\r\n         }\r\n         await Promise.all(\r\n-            orderedIds.map((id, index) => \r\n+            orderedIds.map((id, index) =>\r\n                 Product.findByIdAndUpdate(id, { destaqueOrder: index + 1 })\r\n             )\r\n         );\r\n         res.json({ message: 'Ordem dos destaques atualizada com sucesso.' });\r\n@@ -170,22 +158,19 @@\n         res.status(500).json({ message: 'Erro ao reordenar os destaques.' });\r\n     }\r\n });\r\n \r\n-// ROTA: GET /by-barcode/:barcode\r\n+// GET /api/products/by-barcode/:barcode (pública)\r\n router.get('/by-barcode/:barcode', async (req, res) => {\r\n     try {\r\n         const fullBarcode = req.params.barcode;\r\n         const parts = fullBarcode.split('-');\r\n         const baseBarcode = parts[0];\r\n         const imageIndex = parts.length > 1 ? parseInt(parts[1], 10) - 1 : -1;\r\n \r\n         const product = await Product.findOne({ codbarras: baseBarcode }).populate('categorias').lean();\r\n+        if (!product) return res.status(404).json({ message: 'Produto não encontrado.' });\r\n \r\n-        if (!product) {\r\n-            return res.status(404).json({ message: 'Produto não encontrado.' });\r\n-        }\r\n-        \r\n         if (imageIndex >= 0 && product.imagens && product.imagens[imageIndex]) {\r\n             product.imagemPrincipal = product.imagens[imageIndex];\r\n         } else if (!product.imagemPrincipal) {\r\n             product.imagemPrincipal = '/image/placeholder.png';\r\n@@ -197,168 +182,151 @@\n         res.status(500).json({ message: 'Erro no servidor.' });\r\n     }\r\n });\r\n \r\n-\r\n // ========================================================================\r\n-// ========= ROTAS GENÉRICAS (com :id ou múltiplos parâmetros) ============\r\n+// ========= FUNÇÃO AUXILIAR PARA BREADCRUMB ===============================\r\n // ========================================================================\r\n-\r\n-// Função auxiliar para construir o breadcrumb\r\n async function getCategoryPath(categoryId) {\r\n     let path = [];\r\n     let currentIdToSearch = categoryId;\r\n \r\n-    // Limite de segurança para evitar loops infinitos\r\n     for (let i = 0; i < 10; i++) { \r\n-        if (!currentIdToSearch) {\r\n-            console.log('Busca terminada: Categoria pai é nula.');\r\n-            break;\r\n-        }\r\n+        if (!currentIdToSearch) break;\r\n \r\n         const currentCategory = await mongoose.model('Category').findById(currentIdToSearch).lean();\r\n+        if (!currentCategory) break;\r\n \r\n-        if (!currentCategory) {\r\n-            console.log(`[Passo ${i+1}] !! ERRO: Categoria com ID ${currentIdToSearch} NÃO ENCONTRADA. A corrente quebrou. !!`);\r\n-            break;\r\n-        }\r\n-        \r\n         let href = `/pages/menu-departments-item/search.html?category=${encodeURIComponent(currentCategory.nome)}`;\r\n-        path.unshift({\r\n-            nome: currentCategory.nome,\r\n-            href: href \r\n-        });\r\n-        \r\n+        path.unshift({ nome: currentCategory.nome, href });\r\n+\r\n         currentIdToSearch = currentCategory.parent;\r\n     }\r\n     return path;\r\n }\r\n \r\n-\r\n-// ROTA: GET /:id (Versão atualizada)\r\n+// GET /api/products/:id (pública)\r\n router.get('/:id', async (req, res) => {\r\n     try {\r\n         const product = await Product.findById(req.params.id).populate('categorias').lean();\r\n-        if (!product) {\r\n-            return res.status(404).json({ message: 'Produto não encontrado.' });\r\n-        }\r\n+        if (!product) return res.status(404).json({ message: 'Produto não encontrado.' });\r\n \r\n-        // Lógica simplificada: Pega na PRIMEIRA categoria e gera o caminho para ela.\r\n         if (product.categorias && product.categorias.length > 0) {\r\n-            const primaryCategory = product.categorias[0]; // Pega no primeiro item do array\r\n+            const primaryCategory = product.categorias[0];\r\n             product.breadcrumbPath = await getCategoryPath(primaryCategory._id);\r\n         } else {\r\n-            product.breadcrumbPath = []; // Se não houver categorias, envia um array vazio\r\n+            product.breadcrumbPath = [];\r\n         }\r\n \r\n         res.json(product);\r\n-\r\n     } catch (error) {\r\n         console.error(\"Erro ao buscar produto por ID:\", error);\r\n         res.status(500).json({ message: 'Erro no servidor.' });\r\n     }\r\n });\r\n \r\n-// ROTA: PUT /:id\r\n-router.put('/:id', authorizeRoles('admin', 'admin_master'), async (req, res) => {\r\n+// PUT /api/products/:id (restrito)\r\n+router.put('/:id', requireAuth, authorizeRoles('admin', 'admin_master'), async (req, res) => {\r\n     try {\r\n         const { descricao, marca, stock, categorias } = req.body;\r\n-        const updatedProduct = await Product.findByIdAndUpdate(req.params.id, { descricao, marca, stock, categorias }, { new: true });\r\n+        const updatedProduct = await Product.findByIdAndUpdate(\r\n+            req.params.id,\r\n+            { descricao, marca, stock, categorias },\r\n+            { new: true }\r\n+        );\r\n         res.json(updatedProduct);\r\n     } catch (error) {\r\n         console.error(\"Erro ao atualizar produto:\", error);\r\n         res.status(500).json({ message: 'Erro no servidor.' });\r\n     }\r\n });\r\n \r\n-// ROTA: POST /:id/destaque\r\n-router.post('/:id/destaque', authorizeRoles('admin', 'admin_master'), async (req, res) => {\r\n+// POST /api/products/:id/destaque (restrito)\r\n+router.post('/:id/destaque', requireAuth, authorizeRoles('admin', 'admin_master'), async (req, res) => {\r\n     try {\r\n         const highestOrder = await Product.findOne({ isDestaque: true }).sort({ destaqueOrder: -1 });\r\n         const newOrder = highestOrder ? highestOrder.destaqueOrder + 1 : 1;\r\n-        const product = await Product.findByIdAndUpdate(req.params.id, { isDestaque: true, destaqueOrder: newOrder }, { new: true });\r\n+        const product = await Product.findByIdAndUpdate(\r\n+            req.params.id,\r\n+            { isDestaque: true, destaqueOrder: newOrder },\r\n+            { new: true }\r\n+        );\r\n         if (!product) return res.status(404).json({ message: 'Produto não encontrado.' });\r\n         res.json(product);\r\n     } catch (error) {\r\n         res.status(500).json({ message: 'Erro ao marcar produto como destaque.' });\r\n     }\r\n });\r\n \r\n-// ROTA: DELETE /:id/destaque\r\n-router.delete('/:id/destaque', authorizeRoles('admin', 'admin_master'), async (req, res) => {\r\n+// DELETE /api/products/:id/destaque (restrito)\r\n+router.delete('/:id/destaque', requireAuth, authorizeRoles('admin', 'admin_master'), async (req, res) => {\r\n     try {\r\n-        const product = await Product.findByIdAndUpdate(req.params.id, { isDestaque: false, destaqueOrder: 0 }, { new: true });\r\n+        const product = await Product.findByIdAndUpdate(\r\n+            req.params.id,\r\n+            { isDestaque: false, destaqueOrder: 0 },\r\n+            { new: true }\r\n+        );\r\n         if (!product) return res.status(404).json({ message: 'Produto não encontrado.' });\r\n         res.json({ message: 'Produto removido dos destaques.' });\r\n     } catch (error) {\r\n         res.status(500).json({ message: 'Erro ao remover produto dos destaques.' });\r\n     }\r\n });\r\n \r\n-// ROTA: POST /api/products/by-ids\r\n-// DESCRIÇÃO: Busca uma lista de produtos a partir de um array de IDs.\r\n-router.post('/by-ids', authorizeRoles('admin', 'admin_master'), async (req, res) => {\r\n+// POST /api/products/by-ids (restrito)\r\n+router.post('/by-ids', requireAuth, authorizeRoles('admin', 'admin_master'), async (req, res) => {\r\n     try {\r\n         const { ids } = req.body;\r\n         if (!ids || !Array.isArray(ids)) {\r\n             return res.status(400).json({ message: 'Um array de IDs é obrigatório.' });\r\n         }\r\n-\r\n         const products = await Product.find({ '_id': { $in: ids } });\r\n         res.json(products);\r\n-\r\n     } catch (error) {\r\n         console.error('Erro ao buscar produtos por IDs:', error);\r\n         res.status(500).json({ message: 'Erro no servidor.' });\r\n     }\r\n });\r\n \r\n-// ROTA: POST /:id/upload\r\n-router.post('/:id/upload', authorizeRoles('admin', 'admin_master'), upload.array('imagens', 10), async (req, res) => {\r\n+// POST /api/products/:id/upload (restrito)\r\n+router.post('/:id/upload', requireAuth, authorizeRoles('admin', 'admin_master'), upload.array('imagens', 10), async (req, res) => {\r\n     try {\r\n         const product = await Product.findById(req.params.id);\r\n         if (!product) {\r\n-             // Se o produto não for encontrado, apaga os ficheiros temporários\r\n-             req.files.forEach(file => fs.unlinkSync(file.path));\r\n-             return res.status(404).send('Produto não encontrado');\r\n+            req.files.forEach(file => fs.unlinkSync(file.path));\r\n+            return res.status(404).send('Produto não encontrado');\r\n         }\r\n \r\n         const newImagePaths = [];\r\n-        let imageCounter = product.imagens.length; // Começa a contar a partir do número de imagens existentes\r\n+        let imageCounter = product.imagens.length;\r\n \r\n         for (const file of req.files) {\r\n             imageCounter++;\r\n             const fileExtension = path.extname(file.originalname);\r\n             const newFilename = `${product.codbarras}-${imageCounter}${fileExtension}`;\r\n-            \r\n             const oldPath = file.path;\r\n             const newPath = path.join('public', 'uploads', 'products', newFilename);\r\n \r\n             fs.renameSync(oldPath, newPath);\r\n-\r\n             newImagePaths.push(`/uploads/products/${newFilename}`);\r\n         }\r\n \r\n         product.imagens.push(...newImagePaths);\r\n-\r\n-        // Se o produto não tiver imagem principal, define a primeira imagem do upload como principal\r\n         if (!product.imagemPrincipal || product.imagemPrincipal.includes('placeholder')) {\r\n             product.imagemPrincipal = newImagePaths[0];\r\n         }\r\n \r\n         await product.save();\r\n         res.send(product);\r\n-\r\n     } catch (error) {\r\n         console.error(\"Erro no upload de imagens:\", error);\r\n-        // Se der erro, apaga os ficheiros temporários que possam ter sido criados\r\n         req.files.forEach(file => fs.unlinkSync(file.path));\r\n         res.status(500).send('Erro no servidor');\r\n     }\r\n });\r\n \r\n-// ROTA: DELETE /:productId/images\r\n-router.delete('/:productId/images', authorizeRoles('admin', 'admin_master'), async (req, res) => {\r\n+// DELETE /api/products/:productId/images (restrito)\r\n+router.delete('/:productId/images', requireAuth, authorizeRoles('admin', 'admin_master'), async (req, res) => {\r\n     try {\r\n         const { productId } = req.params;\r\n         const { imageUrl } = req.body;\r\n         if (!imageUrl) return res.status(400).json({ message: 'O URL da imagem é obrigatório.' });\r\n@@ -377,10 +345,10 @@\n         res.status(500).json({ message: 'Erro no servidor ao apagar a imagem.' });\r\n     }\r\n });\r\n \r\n-// ROTA: DELETE /:productId/categories/:categoryId\r\n-router.delete('/:productId/categories/:categoryId', authorizeRoles('admin', 'admin_master'), async (req, res) => {\r\n+// DELETE /api/products/:productId/categories/:categoryId (restrito)\r\n+router.delete('/:productId/categories/:categoryId', requireAuth, authorizeRoles('admin', 'admin_master'), async (req, res) => {\r\n     const { productId, categoryId } = req.params;\r\n     try {\r\n         const product = await Product.findByIdAndUpdate(productId, { $pull: { categorias: categoryId } }, { new: true });\r\n         if (!product) return res.status(404).json({ message: 'Produto não encontrado.' });\r\n@@ -390,5 +358,5 @@\n         res.status(500).json({ message: 'Erro ao remover categoria do produto.' });\r\n     }\r\n });\r\n \r\n-module.exports = router;\n\\ No newline at end of file\n+module.exports = router;\r\n"
                },
                {
                    "date": 1756584905231,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -272,19 +272,15 @@\n     }\r\n });\r\n \r\n // POST /api/products/by-ids (restrito)\r\n-router.post('/by-ids', requireAuth, authorizeRoles('admin', 'admin_master'), async (req, res) => {\r\n+router.post('/by-ids', requireAuth, async (req, res) => {\r\n     try {\r\n         const { ids } = req.body;\r\n-        if (!ids || !Array.isArray(ids)) {\r\n-            return res.status(400).json({ message: 'Um array de IDs é obrigatório.' });\r\n-        }\r\n-        const products = await Product.find({ '_id': { $in: ids } });\r\n+        const products = await Product.find({ _id: { $in: ids } });\r\n         res.json(products);\r\n     } catch (error) {\r\n-        console.error('Erro ao buscar produtos por IDs:', error);\r\n-        res.status(500).json({ message: 'Erro no servidor.' });\r\n+        res.status(500).json({ message: 'Erro ao buscar produtos.' });\r\n     }\r\n });\r\n \r\n // POST /api/products/:id/upload (restrito)\r\n"
                },
                {
                    "date": 1756584919435,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,358 @@\n+const mongoose = require('mongoose');\r\n+const express = require('express');\r\n+const router = express.Router();\r\n+const path = require('path');\r\n+const Product = require('../models/Product');\r\n+const Category = require('../models/Category');\r\n+const multer = require('multer');\r\n+const fs = require('fs');\r\n+const requireAuth = require('../middlewares/requireAuth');\r\n+const authorizeRoles = require('../middlewares/authorizeRoles');\r\n+\r\n+// Configuração do Multer para upload de imagens\r\n+const storage = multer.diskStorage({\r\n+    destination: function (req, file, cb) {\r\n+        cb(null, 'public/uploads/products/');\r\n+    },\r\n+    filename: function (req, file, cb) {\r\n+        const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);\r\n+        cb(null, `temp-${uniqueSuffix}${path.extname(file.originalname)}`);\r\n+    }\r\n+});\r\n+const upload = multer({ storage: storage });\r\n+\r\n+// ========================================================================\r\n+// ========= ROTAS ESPECÍFICAS (Devem vir primeiro) =======================\r\n+// ========================================================================\r\n+\r\n+// Função auxiliar recursiva para encontrar todos os IDs de sub-categorias\r\n+async function findAllSubCategoryIds(categoryId) {\r\n+    let ids = [categoryId];\r\n+    const children = await Category.find({ parent: categoryId });\r\n+    for (const child of children) {\r\n+        ids = ids.concat(await findAllSubCategoryIds(child._id));\r\n+    }\r\n+    return ids;\r\n+}\r\n+\r\n+// GET /api/products/by-category (pública)\r\n+router.get('/by-category', async (req, res) => {\r\n+    try {\r\n+        const { name: categoryName, parent: parentName, grandparent: grandParentName } = req.query;\r\n+        let query = { nome: new RegExp('^' + categoryName + '$', 'i') };\r\n+\r\n+        if (parentName) {\r\n+            let parentCandidates = await Category.find({ nome: new RegExp('^' + parentName + '$', 'i') });\r\n+\r\n+            if (grandParentName) {\r\n+                const grandParent = await Category.findOne({ nome: new RegExp('^' + grandParentName + '$', 'i') });\r\n+                if (grandParent) {\r\n+                    parentCandidates = await Category.find({ nome: new RegExp('^' + parentName + '$', 'i'), parent: grandParent._id });\r\n+                }\r\n+            }\r\n+            if (parentCandidates.length > 0) {\r\n+                query.parent = { $in: parentCandidates.map(p => p._id) };\r\n+            }\r\n+        } else {\r\n+            query.parent = null;\r\n+        }\r\n+\r\n+        const topCategory = await Category.findOne(query);\r\n+        if (!topCategory) return res.json({ products: [], page: 1, pages: 1, total: 0 });\r\n+\r\n+        const allCategoryIds = await findAllSubCategoryIds(topCategory._id);\r\n+        const products = await Product.find({ categorias: { $in: allCategoryIds } })\r\n+            .populate('categorias')\r\n+            .sort({ nome: 1 })\r\n+            .lean();\r\n+\r\n+        products.forEach(p => { if (!p.imagemPrincipal) p.imagemPrincipal = '/image/placeholder.png'; });\r\n+        res.json({ products, page: 1, pages: 1, total: products.length });\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao buscar produtos por categoria:\", error);\r\n+        res.status(500).json({ message: 'Erro no servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// GET /api/products (pública, listagem com paginação e busca)\r\n+router.get('/', async (req, res) => {\r\n+    try {\r\n+        const { page = 1, limit = 20, search = '' } = req.query;\r\n+        const query = {};\r\n+\r\n+        if (search) {\r\n+            const normalizedSearch = search.toString().toLowerCase().normalize(\"NFD\").replace(/[\\u0300-\\u036f]/g, \"\");\r\n+            query.searchableString = { $regex: normalizedSearch, $options: 'i' };\r\n+        }\r\n+\r\n+        const products = await Product.find(query)\r\n+            .limit(parseInt(limit))\r\n+            .skip(parseInt(limit) * (page - 1))\r\n+            .populate('categorias')\r\n+            .sort({ nome: 1 })\r\n+            .lean();\r\n+\r\n+        const total = await Product.countDocuments(query);\r\n+\r\n+        products.forEach(p => {\r\n+            if (!p.imagemPrincipal) {\r\n+                p.imagemPrincipal = '/image/placeholder.png';\r\n+            }\r\n+        });\r\n+\r\n+        res.json({\r\n+            products,\r\n+            page: parseInt(page),\r\n+            pages: Math.ceil(total / limit),\r\n+            total: total\r\n+        });\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao buscar produtos:\", error);\r\n+        res.status(500).json({ message: 'Erro no servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// GET /api/products/destaques (pública)\r\n+router.get('/destaques', async (req, res) => {\r\n+    try {\r\n+        const destaques = await Product.find({ isDestaque: true }).sort({ destaqueOrder: 1 });\r\n+        res.json(destaques);\r\n+    } catch (error) {\r\n+        res.status(500).json({ message: 'Erro ao buscar produtos em destaque.' });\r\n+    }\r\n+});\r\n+\r\n+// PUT /api/products/bulk-update-category (restrito)\r\n+router.put('/bulk-update-category', requireAuth, authorizeRoles('admin', 'admin_master'), async (req, res) => {\r\n+    try {\r\n+        const { productIds, newCategoryId, brandName } = req.body;\r\n+        if (!productIds || !newCategoryId || !Array.isArray(productIds) || productIds.length === 0) {\r\n+            return res.status(400).json({ message: 'Dados inválidos ou nenhum produto selecionado.' });\r\n+        }\r\n+\r\n+        const updateOperation = { $addToSet: { categorias: newCategoryId } };\r\n+        if (brandName) updateOperation.$set = { marca: brandName };\r\n+\r\n+        const result = await Product.updateMany({ _id: { $in: productIds } }, updateOperation);\r\n+        res.json({ message: `${result.modifiedCount} produtos foram atualizados com sucesso.` });\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao atualizar produtos em massa:\", error);\r\n+        res.status(500).json({ message: 'Erro no servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// PUT /api/products/destaques/order (restrito)\r\n+router.put('/destaques/order', requireAuth, authorizeRoles('admin', 'admin_master'), async (req, res) => {\r\n+    try {\r\n+        const { orderedIds } = req.body;\r\n+        if (!Array.isArray(orderedIds)) {\r\n+            return res.status(400).json({ message: 'Formato de dados inválido.' });\r\n+        }\r\n+        await Promise.all(\r\n+            orderedIds.map((id, index) =>\r\n+                Product.findByIdAndUpdate(id, { destaqueOrder: index + 1 })\r\n+            )\r\n+        );\r\n+        res.json({ message: 'Ordem dos destaques atualizada com sucesso.' });\r\n+    } catch (error) {\r\n+        res.status(500).json({ message: 'Erro ao reordenar os destaques.' });\r\n+    }\r\n+});\r\n+\r\n+// GET /api/products/by-barcode/:barcode (pública)\r\n+router.get('/by-barcode/:barcode', async (req, res) => {\r\n+    try {\r\n+        const fullBarcode = req.params.barcode;\r\n+        const parts = fullBarcode.split('-');\r\n+        const baseBarcode = parts[0];\r\n+        const imageIndex = parts.length > 1 ? parseInt(parts[1], 10) - 1 : -1;\r\n+\r\n+        const product = await Product.findOne({ codbarras: baseBarcode }).populate('categorias').lean();\r\n+        if (!product) return res.status(404).json({ message: 'Produto não encontrado.' });\r\n+\r\n+        if (imageIndex >= 0 && product.imagens && product.imagens[imageIndex]) {\r\n+            product.imagemPrincipal = product.imagens[imageIndex];\r\n+        } else if (!product.imagemPrincipal) {\r\n+            product.imagemPrincipal = '/image/placeholder.png';\r\n+        }\r\n+\r\n+        res.json({ products: [product], page: 1, pages: 1, total: 1 });\r\n+    } catch (error) {\r\n+        console.error(\"Erro na busca por código de barras:\", error);\r\n+        res.status(500).json({ message: 'Erro no servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// ========================================================================\r\n+// ========= FUNÇÃO AUXILIAR PARA BREADCRUMB ===============================\r\n+// ========================================================================\r\n+async function getCategoryPath(categoryId) {\r\n+    let path = [];\r\n+    let currentIdToSearch = categoryId;\r\n+\r\n+    for (let i = 0; i < 10; i++) { \r\n+        if (!currentIdToSearch) break;\r\n+\r\n+        const currentCategory = await mongoose.model('Category').findById(currentIdToSearch).lean();\r\n+        if (!currentCategory) break;\r\n+\r\n+        let href = `/pages/menu-departments-item/search.html?category=${encodeURIComponent(currentCategory.nome)}`;\r\n+        path.unshift({ nome: currentCategory.nome, href });\r\n+\r\n+        currentIdToSearch = currentCategory.parent;\r\n+    }\r\n+    return path;\r\n+}\r\n+\r\n+// GET /api/products/:id (pública)\r\n+router.get('/:id', async (req, res) => {\r\n+    try {\r\n+        const product = await Product.findById(req.params.id).populate('categorias').lean();\r\n+        if (!product) return res.status(404).json({ message: 'Produto não encontrado.' });\r\n+\r\n+        if (product.categorias && product.categorias.length > 0) {\r\n+            const primaryCategory = product.categorias[0];\r\n+            product.breadcrumbPath = await getCategoryPath(primaryCategory._id);\r\n+        } else {\r\n+            product.breadcrumbPath = [];\r\n+        }\r\n+\r\n+        res.json(product);\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao buscar produto por ID:\", error);\r\n+        res.status(500).json({ message: 'Erro no servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// PUT /api/products/:id (restrito)\r\n+router.put('/:id', requireAuth, authorizeRoles('admin', 'admin_master'), async (req, res) => {\r\n+    try {\r\n+        const { descricao, marca, stock, categorias } = req.body;\r\n+        const updatedProduct = await Product.findByIdAndUpdate(\r\n+            req.params.id,\r\n+            { descricao, marca, stock, categorias },\r\n+            { new: true }\r\n+        );\r\n+        res.json(updatedProduct);\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao atualizar produto:\", error);\r\n+        res.status(500).json({ message: 'Erro no servidor.' });\r\n+    }\r\n+});\r\n+\r\n+// POST /api/products/:id/destaque (restrito)\r\n+router.post('/:id/destaque', requireAuth, authorizeRoles('admin', 'admin_master'), async (req, res) => {\r\n+    try {\r\n+        const highestOrder = await Product.findOne({ isDestaque: true }).sort({ destaqueOrder: -1 });\r\n+        const newOrder = highestOrder ? highestOrder.destaqueOrder + 1 : 1;\r\n+        const product = await Product.findByIdAndUpdate(\r\n+            req.params.id,\r\n+            { isDestaque: true, destaqueOrder: newOrder },\r\n+            { new: true }\r\n+        );\r\n+        if (!product) return res.status(404).json({ message: 'Produto não encontrado.' });\r\n+        res.json(product);\r\n+    } catch (error) {\r\n+        res.status(500).json({ message: 'Erro ao marcar produto como destaque.' });\r\n+    }\r\n+});\r\n+\r\n+// DELETE /api/products/:id/destaque (restrito)\r\n+router.delete('/:id/destaque', requireAuth, authorizeRoles('admin', 'admin_master'), async (req, res) => {\r\n+    try {\r\n+        const product = await Product.findByIdAndUpdate(\r\n+            req.params.id,\r\n+            { isDestaque: false, destaqueOrder: 0 },\r\n+            { new: true }\r\n+        );\r\n+        if (!product) return res.status(404).json({ message: 'Produto não encontrado.' });\r\n+        res.json({ message: 'Produto removido dos destaques.' });\r\n+    } catch (error) {\r\n+        res.status(500).json({ message: 'Erro ao remover produto dos destaques.' });\r\n+    }\r\n+});\r\n+\r\n+// POST /api/products/by-ids (restrito)\r\n+router.post('/by-ids', requireAuth, async (req, res) => {\r\n+    try {\r\n+        const { ids } = req.body;\r\n+        const products = await Product.find({ _id: { $in: ids } });\r\n+        res.json(products);\r\n+    } catch (error) {\r\n+        res.status(500).json({ message: 'Erro ao buscar produtos.' });\r\n+    }\r\n+});\r\n+\r\n+// POST /api/products/:id/upload (restrito)\r\n+router.post('/:id/upload', requireAuth, authorizeRoles('admin', 'admin_master'), upload.array('imagens', 10), async (req, res) => {\r\n+    try {\r\n+        const product = await Product.findById(req.params.id);\r\n+        if (!product) {\r\n+            req.files.forEach(file => fs.unlinkSync(file.path));\r\n+            return res.status(404).send('Produto não encontrado');\r\n+        }\r\n+\r\n+        const newImagePaths = [];\r\n+        let imageCounter = product.imagens.length;\r\n+\r\n+        for (const file of req.files) {\r\n+            imageCounter++;\r\n+            const fileExtension = path.extname(file.originalname);\r\n+            const newFilename = `${product.codbarras}-${imageCounter}${fileExtension}`;\r\n+            const oldPath = file.path;\r\n+            const newPath = path.join('public', 'uploads', 'products', newFilename);\r\n+\r\n+            fs.renameSync(oldPath, newPath);\r\n+            newImagePaths.push(`/uploads/products/${newFilename}`);\r\n+        }\r\n+\r\n+        product.imagens.push(...newImagePaths);\r\n+        if (!product.imagemPrincipal || product.imagemPrincipal.includes('placeholder')) {\r\n+            product.imagemPrincipal = newImagePaths[0];\r\n+        }\r\n+\r\n+        await product.save();\r\n+        res.send(product);\r\n+    } catch (error) {\r\n+        console.error(\"Erro no upload de imagens:\", error);\r\n+        req.files.forEach(file => fs.unlinkSync(file.path));\r\n+        res.status(500).send('Erro no servidor');\r\n+    }\r\n+});\r\n+\r\n+// DELETE /api/products/:productId/images (restrito)\r\n+router.delete('/:productId/images', requireAuth, authorizeRoles('admin', 'admin_master'), async (req, res) => {\r\n+    try {\r\n+        const { productId } = req.params;\r\n+        const { imageUrl } = req.body;\r\n+        if (!imageUrl) return res.status(400).json({ message: 'O URL da imagem é obrigatório.' });\r\n+        \r\n+        const product = await Product.findById(productId);\r\n+        if (!product) return res.status(404).json({ message: 'Produto não encontrado.' });\r\n+        \r\n+        product.imagens.pull(imageUrl);\r\n+        if (product.imagemPrincipal === imageUrl) {\r\n+            product.imagemPrincipal = product.imagens.length > 0 ? product.imagens[0] : '/image/placeholder.png';\r\n+        }\r\n+        await product.save();\r\n+        res.json({ message: 'Imagem apagada com sucesso.', product });\r\n+    } catch (error) {\r\n+        console.error(\"Erro ao apagar a imagem:\", error);\r\n+        res.status(500).json({ message: 'Erro no servidor ao apagar a imagem.' });\r\n+    }\r\n+});\r\n+\r\n+// DELETE /api/products/:productId/categories/:categoryId (restrito)\r\n+router.delete('/:productId/categories/:categoryId', requireAuth, authorizeRoles('admin', 'admin_master'), async (req, res) => {\r\n+    const { productId, categoryId } = req.params;\r\n+    try {\r\n+        const product = await Product.findByIdAndUpdate(productId, { $pull: { categorias: categoryId } }, { new: true });\r\n+        if (!product) return res.status(404).json({ message: 'Produto não encontrado.' });\r\n+        res.json({ message: 'Categoria removida com sucesso.' });\r\n+    } catch (error) {\r\n+        console.error('Erro ao remover categoria do produto:', error);\r\n+        res.status(500).json({ message: 'Erro ao remover categoria do produto.' });\r\n+    }\r\n+});\r\n+\r\n+module.exports = router;\r\n"
                }
            ],
            "date": 1756571571585,
            "name": "Commit-0",
            "content": "const mongoose = require('mongoose');\r\nconst express = require('express');\r\nconst router = express.Router();\r\nconst path = require('path');\r\nconst Product = require('../models/Product');\r\nconst Category = require('../models/Category');\r\nconst multer = require('multer');\r\nconst fs = require('fs');\r\nconst authorizeRoles = require('../middlewares/authorizeRoles');\r\n\r\n// Configuração do Multer para upload de imagens\r\nconst storage = multer.diskStorage({\r\n    destination: function (req, file, cb) {\r\n        cb(null, 'public/uploads/products/');\r\n    },\r\n    filename: function (req, file, cb) {\r\n        const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);\r\n        cb(null, `temp-${uniqueSuffix}${path.extname(file.originalname)}`);\r\n    }\r\n});\r\nconst upload = multer({ storage: storage });\r\n\r\n\r\n// ========================================================================\r\n// ========= ROTAS ESPECÍFICAS (Devem vir primeiro) =======================\r\n// ========================================================================\r\n\r\n// DESCRIÇÃO: Busca produtos que pertencem EXATAMENTE a uma categoria pelo nome.\r\n// Função auxiliar recursiva para encontrar todos os IDs de sub-categorias\r\nasync function findAllSubCategoryIds(categoryId) {\r\n    let ids = [categoryId];\r\n    const children = await Category.find({ parent: categoryId });\r\n    for (const child of children) {\r\n        ids = ids.concat(await findAllSubCategoryIds(child._id));\r\n    }\r\n    return ids;\r\n}\r\n\r\nrouter.get('/by-category', async (req, res) => {\r\n    try {\r\n        const { name: categoryName, parent: parentName, grandparent: grandParentName } = req.query;\r\n        let query = { nome: new RegExp('^' + categoryName + '$', 'i') };\r\n\r\n        if (parentName) {\r\n            let parentCandidates = await Category.find({ nome: new RegExp('^' + parentName + '$', 'i') });\r\n\r\n            if (grandParentName) {\r\n                const grandParent = await Category.findOne({ nome: new RegExp('^' + grandParentName + '$', 'i') });\r\n                if (grandParent) {\r\n                    parentCandidates = await Category.find({ nome: new RegExp('^' + parentName + '$', 'i'), parent: grandParent._id });\r\n                }\r\n            }\r\n            if (parentCandidates.length > 0) {\r\n                query.parent = { $in: parentCandidates.map(p => p._id) };\r\n            }\r\n        } else {\r\n            query.parent = null;\r\n        }\r\n\r\n        const topCategory = await Category.findOne(query);\r\n        if (!topCategory) return res.json({ products: [], page: 1, pages: 1, total: 0 });\r\n\r\n        const allCategoryIds = await findAllSubCategoryIds(topCategory._id);\r\n        const products = await Product.find({ categorias: { $in: allCategoryIds } }).populate('categorias').sort({ nome: 1 }).lean();\r\n        products.forEach(p => { if (!p.imagemPrincipal) p.imagemPrincipal = '/image/placeholder.png'; });\r\n        res.json({ products, page: 1, pages: 1, total: products.length });\r\n    } catch (error) {\r\n        console.error(\"Erro ao buscar produtos por categoria:\", error);\r\n        res.status(500).json({ message: 'Erro no servidor.' });\r\n    }\r\n});\r\n\r\n// ROTA: GET / - Listar todos os produtos (rota principal com busca e paginação)\r\nrouter.get('/', async (req, res) => {\r\n    try {\r\n        const { page = 1, limit = 20, search = '' } = req.query;\r\n        const query = {};\r\n\r\n        if (search) {\r\n            const normalizedSearch = search.toString().toLowerCase().normalize(\"NFD\").replace(/[\\u0300-\\u036f]/g, \"\");\r\n            query.searchableString = { $regex: normalizedSearch, $options: 'i' };\r\n        }\r\n\r\n        const products = await Product.find(query)\r\n            .limit(parseInt(limit))\r\n            .skip(parseInt(limit) * (page - 1))\r\n            .populate('categorias')\r\n            .sort({ nome: 1 })\r\n            .lean(); // Usar .lean() para melhor performance e facilitar manipulação\r\n        \r\n        const total = await Product.countDocuments(query);\r\n        \r\n        // Garante que todos os produtos tenham uma imagem principal\r\n        products.forEach(p => {\r\n            if (!p.imagemPrincipal) {\r\n                p.imagemPrincipal = '/image/placeholder.png';\r\n            }\r\n        });\r\n\r\n        res.json({\r\n            products,\r\n            page: parseInt(page),\r\n            pages: Math.ceil(total / limit),\r\n            total: total\r\n        });\r\n    } catch (error) {\r\n        console.error(\"Erro ao buscar produtos:\", error);\r\n        res.status(500).json({ message: 'Erro no servidor.' });\r\n    }\r\n});\r\n\r\n// ROTA: GET /destaques\r\nrouter.get('/destaques', async (req, res) => {\r\n    try {\r\n        const destaques = await Product.find({ isDestaque: true }).sort({ destaqueOrder: 1 });\r\n        res.json(destaques);\r\n    } catch (error) {\r\n        res.status(500).json({ message: 'Erro ao buscar produtos em destaque.' });\r\n    }\r\n});\r\n\r\n// ROTA: PUT /bulk-update-category\r\nrouter.put('/bulk-update-category', authorizeRoles('admin', 'admin_master'), async (req, res) => {\r\n    try {\r\n        // Pega o novo campo brandName do corpo do pedido\r\n        const { productIds, newCategoryId, brandName } = req.body; \r\n\r\n        if (!productIds || !newCategoryId || !Array.isArray(productIds) || productIds.length === 0) {\r\n            return res.status(400).json({ message: 'Dados inválidos ou nenhum produto selecionado.' });\r\n        }\r\n\r\n        // 1. Cria o objeto de atualização base para adicionar a categoria\r\n        const updateOperation = {\r\n            $addToSet: { categorias: newCategoryId }\r\n        };\r\n\r\n        // 2. Se um nome de marca foi enviado, adiciona a atualização do campo 'marca'\r\n        if (brandName) {\r\n            updateOperation.$set = { marca: brandName };\r\n        }\r\n\r\n        // 3. Executa a atualização na base de dados com as operações combinadas\r\n        const result = await Product.updateMany(\r\n            { _id: { $in: productIds } }, \r\n            updateOperation\r\n        );\r\n        \r\n        res.json({ message: `${result.modifiedCount} produtos foram atualizados com sucesso.` });\r\n\r\n    } catch (error) {\r\n        console.error(\"Erro ao atualizar produtos em massa:\", error);\r\n        res.status(500).json({ message: 'Erro no servidor.' });\r\n    }\r\n});\r\n\r\n// ROTA: PUT /destaques/order\r\nrouter.put('/destaques/order', authorizeRoles('admin', 'admin_master'), async (req, res) => {\r\n    try {\r\n        const { orderedIds } = req.body;\r\n        if (!Array.isArray(orderedIds)) {\r\n            return res.status(400).json({ message: 'Formato de dados inválido.' });\r\n        }\r\n        await Promise.all(\r\n            orderedIds.map((id, index) => \r\n                Product.findByIdAndUpdate(id, { destaqueOrder: index + 1 })\r\n            )\r\n        );\r\n        res.json({ message: 'Ordem dos destaques atualizada com sucesso.' });\r\n    } catch (error) {\r\n        res.status(500).json({ message: 'Erro ao reordenar os destaques.' });\r\n    }\r\n});\r\n\r\n// ROTA: GET /by-barcode/:barcode\r\nrouter.get('/by-barcode/:barcode', async (req, res) => {\r\n    try {\r\n        const fullBarcode = req.params.barcode;\r\n        const parts = fullBarcode.split('-');\r\n        const baseBarcode = parts[0];\r\n        const imageIndex = parts.length > 1 ? parseInt(parts[1], 10) - 1 : -1;\r\n\r\n        const product = await Product.findOne({ codbarras: baseBarcode }).populate('categorias').lean();\r\n\r\n        if (!product) {\r\n            return res.status(404).json({ message: 'Produto não encontrado.' });\r\n        }\r\n        \r\n        if (imageIndex >= 0 && product.imagens && product.imagens[imageIndex]) {\r\n            product.imagemPrincipal = product.imagens[imageIndex];\r\n        } else if (!product.imagemPrincipal) {\r\n            product.imagemPrincipal = '/image/placeholder.png';\r\n        }\r\n\r\n        res.json({ products: [product], page: 1, pages: 1, total: 1 });\r\n    } catch (error) {\r\n        console.error(\"Erro na busca por código de barras:\", error);\r\n        res.status(500).json({ message: 'Erro no servidor.' });\r\n    }\r\n});\r\n\r\n\r\n// ========================================================================\r\n// ========= ROTAS GENÉRICAS (com :id ou múltiplos parâmetros) ============\r\n// ========================================================================\r\n\r\n// Função auxiliar para construir o breadcrumb\r\nasync function getCategoryPath(categoryId) {\r\n    let path = [];\r\n    let currentIdToSearch = categoryId;\r\n\r\n    // Limite de segurança para evitar loops infinitos\r\n    for (let i = 0; i < 10; i++) { \r\n        if (!currentIdToSearch) {\r\n            console.log('Busca terminada: Categoria pai é nula.');\r\n            break;\r\n        }\r\n\r\n        const currentCategory = await mongoose.model('Category').findById(currentIdToSearch).lean();\r\n\r\n        if (!currentCategory) {\r\n            console.log(`[Passo ${i+1}] !! ERRO: Categoria com ID ${currentIdToSearch} NÃO ENCONTRADA. A corrente quebrou. !!`);\r\n            break;\r\n        }\r\n        \r\n        let href = `/pages/menu-departments-item/search.html?category=${encodeURIComponent(currentCategory.nome)}`;\r\n        path.unshift({\r\n            nome: currentCategory.nome,\r\n            href: href \r\n        });\r\n        \r\n        currentIdToSearch = currentCategory.parent;\r\n    }\r\n    return path;\r\n}\r\n\r\n\r\n// ROTA: GET /:id (Versão atualizada)\r\nrouter.get('/:id', async (req, res) => {\r\n    try {\r\n        const product = await Product.findById(req.params.id).populate('categorias').lean();\r\n        if (!product) {\r\n            return res.status(404).json({ message: 'Produto não encontrado.' });\r\n        }\r\n\r\n        // Lógica simplificada: Pega na PRIMEIRA categoria e gera o caminho para ela.\r\n        if (product.categorias && product.categorias.length > 0) {\r\n            const primaryCategory = product.categorias[0]; // Pega no primeiro item do array\r\n            product.breadcrumbPath = await getCategoryPath(primaryCategory._id);\r\n        } else {\r\n            product.breadcrumbPath = []; // Se não houver categorias, envia um array vazio\r\n        }\r\n\r\n        res.json(product);\r\n\r\n    } catch (error) {\r\n        console.error(\"Erro ao buscar produto por ID:\", error);\r\n        res.status(500).json({ message: 'Erro no servidor.' });\r\n    }\r\n});\r\n\r\n// ROTA: PUT /:id\r\nrouter.put('/:id', authorizeRoles('admin', 'admin_master'), async (req, res) => {\r\n    try {\r\n        const { descricao, marca, stock, categorias } = req.body;\r\n        const updatedProduct = await Product.findByIdAndUpdate(req.params.id, { descricao, marca, stock, categorias }, { new: true });\r\n        res.json(updatedProduct);\r\n    } catch (error) {\r\n        console.error(\"Erro ao atualizar produto:\", error);\r\n        res.status(500).json({ message: 'Erro no servidor.' });\r\n    }\r\n});\r\n\r\n// ROTA: POST /:id/destaque\r\nrouter.post('/:id/destaque', authorizeRoles('admin', 'admin_master'), async (req, res) => {\r\n    try {\r\n        const highestOrder = await Product.findOne({ isDestaque: true }).sort({ destaqueOrder: -1 });\r\n        const newOrder = highestOrder ? highestOrder.destaqueOrder + 1 : 1;\r\n        const product = await Product.findByIdAndUpdate(req.params.id, { isDestaque: true, destaqueOrder: newOrder }, { new: true });\r\n        if (!product) return res.status(404).json({ message: 'Produto não encontrado.' });\r\n        res.json(product);\r\n    } catch (error) {\r\n        res.status(500).json({ message: 'Erro ao marcar produto como destaque.' });\r\n    }\r\n});\r\n\r\n// ROTA: DELETE /:id/destaque\r\nrouter.delete('/:id/destaque', authorizeRoles('admin', 'admin_master'), async (req, res) => {\r\n    try {\r\n        const product = await Product.findByIdAndUpdate(req.params.id, { isDestaque: false, destaqueOrder: 0 }, { new: true });\r\n        if (!product) return res.status(404).json({ message: 'Produto não encontrado.' });\r\n        res.json({ message: 'Produto removido dos destaques.' });\r\n    } catch (error) {\r\n        res.status(500).json({ message: 'Erro ao remover produto dos destaques.' });\r\n    }\r\n});\r\n\r\n// ROTA: POST /api/products/by-ids\r\n// DESCRIÇÃO: Busca uma lista de produtos a partir de um array de IDs.\r\nrouter.post('/by-ids', authorizeRoles('admin', 'admin_master'), async (req, res) => {\r\n    try {\r\n        const { ids } = req.body;\r\n        if (!ids || !Array.isArray(ids)) {\r\n            return res.status(400).json({ message: 'Um array de IDs é obrigatório.' });\r\n        }\r\n\r\n        const products = await Product.find({ '_id': { $in: ids } });\r\n        res.json(products);\r\n\r\n    } catch (error) {\r\n        console.error('Erro ao buscar produtos por IDs:', error);\r\n        res.status(500).json({ message: 'Erro no servidor.' });\r\n    }\r\n});\r\n\r\n// ROTA: POST /:id/upload\r\nrouter.post('/:id/upload', authorizeRoles('admin', 'admin_master'), upload.array('imagens', 10), async (req, res) => {\r\n    try {\r\n        const product = await Product.findById(req.params.id);\r\n        if (!product) {\r\n             // Se o produto não for encontrado, apaga os ficheiros temporários\r\n             req.files.forEach(file => fs.unlinkSync(file.path));\r\n             return res.status(404).send('Produto não encontrado');\r\n        }\r\n\r\n        const newImagePaths = [];\r\n        let imageCounter = product.imagens.length; // Começa a contar a partir do número de imagens existentes\r\n\r\n        for (const file of req.files) {\r\n            imageCounter++;\r\n            const fileExtension = path.extname(file.originalname);\r\n            const newFilename = `${product.codbarras}-${imageCounter}${fileExtension}`;\r\n            \r\n            const oldPath = file.path;\r\n            const newPath = path.join('public', 'uploads', 'products', newFilename);\r\n\r\n            fs.renameSync(oldPath, newPath);\r\n\r\n            newImagePaths.push(`/uploads/products/${newFilename}`);\r\n        }\r\n\r\n        product.imagens.push(...newImagePaths);\r\n\r\n        // Se o produto não tiver imagem principal, define a primeira imagem do upload como principal\r\n        if (!product.imagemPrincipal || product.imagemPrincipal.includes('placeholder')) {\r\n            product.imagemPrincipal = newImagePaths[0];\r\n        }\r\n\r\n        await product.save();\r\n        res.send(product);\r\n\r\n    } catch (error) {\r\n        console.error(\"Erro no upload de imagens:\", error);\r\n        // Se der erro, apaga os ficheiros temporários que possam ter sido criados\r\n        req.files.forEach(file => fs.unlinkSync(file.path));\r\n        res.status(500).send('Erro no servidor');\r\n    }\r\n});\r\n\r\n// ROTA: DELETE /:productId/images\r\nrouter.delete('/:productId/images', authorizeRoles('admin', 'admin_master'), async (req, res) => {\r\n    try {\r\n        const { productId } = req.params;\r\n        const { imageUrl } = req.body;\r\n        if (!imageUrl) return res.status(400).json({ message: 'O URL da imagem é obrigatório.' });\r\n        \r\n        const product = await Product.findById(productId);\r\n        if (!product) return res.status(404).json({ message: 'Produto não encontrado.' });\r\n        \r\n        product.imagens.pull(imageUrl);\r\n        if (product.imagemPrincipal === imageUrl) {\r\n            product.imagemPrincipal = product.imagens.length > 0 ? product.imagens[0] : '/image/placeholder.png';\r\n        }\r\n        await product.save();\r\n        res.json({ message: 'Imagem apagada com sucesso.', product });\r\n    } catch (error) {\r\n        console.error(\"Erro ao apagar a imagem:\", error);\r\n        res.status(500).json({ message: 'Erro no servidor ao apagar a imagem.' });\r\n    }\r\n});\r\n\r\n// ROTA: DELETE /:productId/categories/:categoryId\r\nrouter.delete('/:productId/categories/:categoryId', authorizeRoles('admin', 'admin_master'), async (req, res) => {\r\n    const { productId, categoryId } = req.params;\r\n    try {\r\n        const product = await Product.findByIdAndUpdate(productId, { $pull: { categorias: categoryId } }, { new: true });\r\n        if (!product) return res.status(404).json({ message: 'Produto não encontrado.' });\r\n        res.json({ message: 'Categoria removida com sucesso.' });\r\n    } catch (error) {\r\n        console.error('Erro ao remover categoria do produto:', error);\r\n        res.status(500).json({ message: 'Erro ao remover categoria do produto.' });\r\n    }\r\n});\r\n\r\nmodule.exports = router;"
        }
    ]
}