{
    "sourceFile": "servidor/services/ifoodClient.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1766172142593,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1766172142593,
            "name": "Commit-0",
            "content": "const axios = require('axios');\n\n// Cliente para operações de catálogo (item) no iFood.\n// Variáveis de ambiente aceitas:\n// - IFOOD_API_BASE (ex.: https://merchant-api.ifood.com.br)\n// - IFOOD_OAUTH_PATH (ex.: /authentication/v1.0/oauth/token)\n// - IFOOD_ITEMS_PATH (ex.: /item/v1.0/ingestion/{merchantId})\n\nconst API_BASE = process.env.IFOOD_API_BASE || 'https://merchant-api.ifood.com.br';\nconst OAUTH_PATH = process.env.IFOOD_OAUTH_PATH || '/authentication/v1.0/oauth/token';\nconst ITEMS_PATH_TEMPLATE = process.env.IFOOD_ITEMS_PATH || '/item/v1.0/ingestion/{merchantId}';\nconst POST_RESET_PARAM = 'true'; // reset=false para não apagar catálogo\n\nasync function getAccessToken({ clientId, clientSecret }) {\n  if (!clientId || !clientSecret) {\n    throw new Error('Credenciais do iFood ausentes.');\n  }\n\n  const url = `${API_BASE}${OAUTH_PATH}`;\n  const params = new URLSearchParams();\n  params.append('grant_type', 'client_credentials');\n  params.append('grantType', 'client_credentials');\n  params.append('client_id', clientId);\n  params.append('client_secret', clientSecret);\n  params.append('clientId', clientId);\n  params.append('clientSecret', clientSecret);\n\n  const basic = Buffer.from(`${clientId}:${clientSecret}`).toString('base64');\n\n  try {\n    const resp = await axios.post(url, params, {\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n        Authorization: `Basic ${basic}`,\n      },\n      timeout: 10000,\n    });\n\n    const token = resp.data?.access_token || resp.data?.accessToken;\n    if (!token) {\n      throw new Error(`Token do iFood não retornado: ${JSON.stringify(resp.data)}`);\n    }\n    return token;\n  } catch (error) {\n    const detail = error?.response?.data || error?.message || 'Erro desconhecido no OAuth do iFood';\n    throw new Error(`Falha no OAuth iFood (${url}): ${JSON.stringify(detail)}`);\n  }\n}\n\nfunction normalizeUnit(unit) {\n  const raw = (unit || '').toString().trim().toUpperCase();\n  if (!raw) return 'UN';\n  if (raw === 'SC') return 'UN';\n  return raw;\n}\n\nfunction buildFullItemPayload(item = {}) {\n  const stock = Number(item.stock);\n  const price = Number(item.price);\n  return {\n    barcode: item.barcode,\n    name: item.name,\n    plu: item.sku ?? null,\n    active: item.active !== false,\n    inventory: { stock: Number.isFinite(stock) ? stock : 0 },\n    details: {\n      categorization: { department: null, category: null, subCategory: null },\n      brand: item.brand ?? null,\n      unit: normalizeUnit(item.unit),\n      volume: item.volume ?? null,\n      imageUrl: item.imageUrl ?? null,\n      description: item.description ?? null,\n      nearExpiration: item.nearExpiration ?? false,\n      family: item.family ?? null,\n    },\n    prices: {\n      price: Number.isFinite(price) ? price : null,\n      promotionPrice: Number.isFinite(price) ? item.promotionPrice ?? null : null,\n    },\n    scalePrices: null,\n    multiple: null,\n    channels: null,\n  };\n}\n\nfunction buildPatchItemPayload(item = {}) {\n  const payload = {\n    barcode: item.barcode,\n    name: item.name,\n  };\n\n  const stock = Number(item.stock);\n  payload.inventory = { stock: Number.isFinite(stock) ? stock : 0 };\n\n  const price = Number(item.price);\n  if (Number.isFinite(price)) {\n    payload.prices = { price, promotionPrice: item.promotionPrice ?? null };\n  }\n\n  return payload;\n}\n\nconst normalizeInventoryStock = (item = {}) => {\n  const normalized = { ...item };\n  if (normalized.stock !== undefined) {\n    const inv = normalized.inventory || {};\n    if (inv.stock === undefined) {\n      normalized.inventory = { ...inv, stock: normalized.stock };\n    }\n    delete normalized.stock;\n  }\n  return normalized;\n};\n\nasync function sendBatches({ url, method, token, items, mapFn }) {\n  const batchSize = 30;\n  let sent = 0;\n\n  const collectIngestionErrors = (data) => {\n    const errors = [];\n    if (!data) return errors;\n\n    if (Array.isArray(data)) {\n      data.forEach((entry) => {\n        if (Array.isArray(entry?.errors) && entry.errors.length) {\n          errors.push(\n            ...entry.errors.map((err) => ({\n              ...err,\n              itemId: entry?.id,\n              barcode: entry?.barcode,\n            })),\n          );\n        } else if (entry?.error) {\n          errors.push({\n            ...entry.error,\n            itemId: entry?.id,\n            barcode: entry?.barcode,\n          });\n        }\n      });\n    } else if (Array.isArray(data?.errors)) {\n      errors.push(...data.errors);\n    }\n\n    return errors;\n  };\n\n  for (let i = 0; i < items.length; i += batchSize) {\n    const batch = items\n      .slice(i, i + batchSize)\n      .map(mapFn)\n      .map(normalizeInventoryStock);\n    const sample = batch.slice(0, 5).map((item) => ({\n      barcode: item.barcode,\n      name: item.name,\n      inventory: { stock: item.inventory?.stock },\n      prices: item.prices\n        ? { price: item.prices.price, promotionPrice: item.prices.promotionPrice ?? null }\n        : undefined,\n    }));\n    const samplePreview = JSON.stringify(sample);\n    console.info(`[ifood:catalog][${method.toUpperCase()}]`, {\n      url,\n      batch: batch.length,\n      sample: samplePreview,\n    });\n    try {\n      const resp = await axios({\n        method,\n        url,\n        data: batch,\n        headers: {\n          Authorization: `Bearer ${token}`,\n          'Content-Type': 'application/json',\n        },\n        timeout: 15000,\n      });\n      const errors = collectIngestionErrors(resp?.data);\n      if (errors.length) {\n        console.error(`[ifood:catalog][${method.toUpperCase()}][errors]`, {\n          url,\n          errors,\n        });\n        throw new Error(`Falha no envio iFood (${method}) - itens com erro`);\n      }\n      sent += batch.length;\n    } catch (err) {\n      console.log('STATUS:', err.response?.status);\n      console.log('DATA:', JSON.stringify(err.response?.data, null, 2));\n      console.log('ERRORS:', JSON.stringify(err.response?.data?.errors, null, 2));\n      throw err;\n    }\n  }\n\n  return sent;\n}\n\nasync function pushCatalog(credentials, payload) {\n  const { clientId, clientSecret, merchantId } = credentials || {};\n  if (!clientId || !clientSecret || !merchantId) {\n    throw new Error('Credenciais/merchantId do iFood ausentes.');\n  }\n\n  const token = await getAccessToken({ clientId, clientSecret });\n  const postItems = Array.isArray(payload?.newItems) ? payload.newItems : [];\n  const patchItems = Array.isArray(payload?.updateItems) ? payload.updateItems : [];\n\n  console.info('[ifood:catalog][payload]', {\n    merchantId,\n    newItems: postItems.length,\n    updateItems: patchItems.length,\n  });\n\n  if (!postItems.length && !patchItems.length) {\n    return { created: 0, updated: 0, message: 'Nenhum item marcado para envio.' };\n  }\n\n  const path = ITEMS_PATH_TEMPLATE.replace('{merchantId}', merchantId);\n  const postUrl = `${API_BASE}${path}?reset=${POST_RESET_PARAM}`;\n  const patchUrl = `${API_BASE}${path}`;\n\n  let created = 0;\n  let updated = 0;\n\n  if (postItems.length) {\n    created = await sendBatches({\n      url: postUrl,\n      method: 'post',\n      token,\n      items: postItems,\n      mapFn: buildFullItemPayload,\n    });\n  }\n\n  if (patchItems.length) {\n    updated = await sendBatches({\n      url: patchUrl,\n      method: 'patch',\n      token,\n      items: patchItems,\n      mapFn: buildPatchItemPayload,\n    });\n  }\n\n  const message = `Itens enviados ao iFood: criados/reativados=${created}, atualizados=${updated}`;\n  return { created, updated, message };\n}\n\nmodule.exports = {\n  pushCatalog,\n  getAccessToken,\n};\n"
        }
    ]
}