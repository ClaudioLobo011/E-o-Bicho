{
    "sourceFile": "servidor/services/nfceEmitter.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1759279071323,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1759279071323,
            "name": "Commit-0",
            "content": "const crypto = require('crypto');\r\nconst mongoose = require('mongoose');\r\nconst forge = require('node-forge');\r\nconst { DOMParser, XMLSerializer } = require('@xmldom/xmldom');\r\nconst xpath = require('xpath');\r\nconst { SignedXml } = require('xml-crypto');\r\nconst Product = require('../models/Product');\r\nconst {\r\n  computeMissingFields,\r\n  describeMissingFields,\r\n  getFiscalDataForStore,\r\n} = require('./fiscalRuleEngine');\r\nconst { transmitNfceToSefaz, SefazTransmissionError } = require('./sefazTransmitter');\r\nconst { decryptBuffer, decryptText } = require('../utils/certificates');\r\nconst {\r\n  normalizeWhitespace,\r\n  sanitizeXmlAttribute,\r\n  sanitizeXmlContent,\r\n  sanitizeXmlText,\r\n} = require('../utils/xmlSanitizer');\r\n\r\nconst UF_BY_CODE = {\r\n  '11': 'RO',\r\n  '12': 'AC',\r\n  '13': 'AM',\r\n  '14': 'RR',\r\n  '15': 'PA',\r\n  '16': 'AP',\r\n  '17': 'TO',\r\n  '21': 'MA',\r\n  '22': 'PI',\r\n  '23': 'CE',\r\n  '24': 'RN',\r\n  '25': 'PB',\r\n  '26': 'PE',\r\n  '27': 'AL',\r\n  '28': 'SE',\r\n  '29': 'BA',\r\n  '31': 'MG',\r\n  '32': 'ES',\r\n  '33': 'RJ',\r\n  '35': 'SP',\r\n  '41': 'PR',\r\n  '42': 'SC',\r\n  '43': 'RS',\r\n  '50': 'MS',\r\n  '51': 'MT',\r\n  '52': 'GO',\r\n  '53': 'DF',\r\n};\r\n\r\nconst sanitizeDigits = (value, { fallback = '' } = {}) => {\r\n  if (!value) return fallback;\r\n  const digits = String(value).replace(/\\D+/g, '');\r\n  return digits || fallback;\r\n};\r\n\r\nconst BRAZILIAN_CNPJ_OID = '2.16.76.1.3.3';\r\nconst HOMOLOGATION_FIRST_ITEM_DESCRIPTION =\r\n  'NOTA FISCAL EMITIDA EM AMBIENTE DE HOMOLOGACAO - SEM VALOR FISCAL';\r\n\r\nconst describeCertificate = (pem) => {\r\n  if (!pem) {\r\n    return null;\r\n  }\r\n\r\n  try {\r\n    const certificate = forge.pki.certificateFromPem(pem);\r\n    const subject = certificate?.subject?.attributes || [];\r\n    const issuer = certificate?.issuer?.attributes || [];\r\n\r\n    const subjectString = subject\r\n      .map((attr) => `${attr?.shortName || attr?.name || attr?.type}=${attr?.value}`)\r\n      .filter(Boolean)\r\n      .join(', ');\r\n\r\n    const issuerString = issuer\r\n      .map((attr) => `${attr?.shortName || attr?.name || attr?.type}=${attr?.value}`)\r\n      .filter(Boolean)\r\n      .join(', ');\r\n\r\n    const findAttributeValue = (attributes, identifier) => {\r\n      if (!attributes) return null;\r\n      for (const attr of attributes) {\r\n        if (!attr) continue;\r\n        if (attr.type === identifier || attr.name === identifier || attr.shortName === identifier) {\r\n          if (attr.value && typeof attr.value === 'string') {\r\n            return attr.value;\r\n          }\r\n        }\r\n      }\r\n      try {\r\n        const field = certificate.subject.getField(identifier);\r\n        if (field?.value) {\r\n          return field.value;\r\n        }\r\n      } catch (error) {\r\n        // Ignore forge lookup errors.\r\n      }\r\n      return null;\r\n    };\r\n\r\n    const subjectCnpj = findAttributeValue(subject, BRAZILIAN_CNPJ_OID) || findAttributeValue(subject, 'CNPJ');\r\n\r\n    return {\r\n      subject: subjectString,\r\n      issuer: issuerString,\r\n      serialNumber: certificate?.serialNumber || null,\r\n      validFrom: certificate?.validity?.notBefore || null,\r\n      validTo: certificate?.validity?.notAfter || null,\r\n      cnpj: subjectCnpj ? onlyDigits(subjectCnpj) : null,\r\n    };\r\n  } catch (error) {\r\n    return null;\r\n  }\r\n};\r\n\r\nconst normalizeStringSafe = (value) => {\r\n  if (!value && value !== 0) {\r\n    return '';\r\n  }\r\n  const source = String(value)\r\n    .trim()\r\n    .replace(/\\s+/g, ' ');\r\n  if (!source) {\r\n    return '';\r\n  }\r\n  let normalized = source;\r\n  if (typeof normalized.normalize === 'function') {\r\n    normalized = normalized.normalize('NFD').replace(/[\\u0300-\\u036f]/g, '');\r\n  }\r\n  return normalized\r\n    .replace(/[^0-9a-zA-Z]+/g, '-')\r\n    .replace(/-+/g, '-')\r\n    .replace(/^-|-$/g, '')\r\n    .toLowerCase();\r\n};\r\n\r\nconst onlyDigits = (s) => String(s ?? '').replace(/\\D/g, '');\r\nconst dec = (n) => Number(n ?? 0).toFixed(2);\r\nconst sanitize = (value) => sanitizeXmlText(value);\r\n\r\nconst sanitizeQrCodeContent = (value) => {\r\n  const normalized = normalizeWhitespace(value ?? '').trim();\r\n  return sanitize(normalized);\r\n};\r\nconst pushTagIf = (arr, tag, value, indent = '        ') => {\r\n  const v = sanitize(value);\r\n  if (v) arr.push(`${indent}<${tag}>${v}</${tag}>`);\r\n};\r\n\r\nconst PAYMENT_TYPE_MAP = {\r\n  '01': '01',\r\n  dinheiro: '01',\r\n  cash: '01',\r\n  '02': '02',\r\n  cheque: '02',\r\n  '03': '03',\r\n  credito: '03',\r\n  cartaocredito: '03',\r\n  '04': '04',\r\n  debito: '04',\r\n  cartaodebito: '04',\r\n  '05': '05',\r\n  crediario: '05',\r\n  loja: '05',\r\n  '15': '15',\r\n  boleto: '15',\r\n  '16': '16',\r\n  deposito: '16',\r\n  '17': '17',\r\n  pix: '17',\r\n  '18': '18',\r\n  transferencia: '18',\r\n  transferenciabancaria: '18',\r\n  '90': '90',\r\n  semdinheiro: '90',\r\n  sempagamento: '90',\r\n  '99': '99',\r\n  outros: '99',\r\n};\r\n\r\nconst resolvePaymentCode = (raw) => {\r\n  const source = String(raw ?? '').trim();\r\n  if (!source) {\r\n    return '01';\r\n  }\r\n\r\n  const digits = onlyDigits(source).padStart(2, '0');\r\n  if (PAYMENT_TYPE_MAP[digits]) {\r\n    return PAYMENT_TYPE_MAP[digits];\r\n  }\r\n\r\n  const normalizedSource =\r\n    typeof source.normalize === 'function' ? source.normalize('NFD') : source;\r\n  const normalized = normalizedSource.replace(/[^\\p{Letter}\\p{Number}]+/gu, '').toLowerCase();\r\n  if (PAYMENT_TYPE_MAP[normalized]) {\r\n    return PAYMENT_TYPE_MAP[normalized];\r\n  }\r\n\r\n  return '99';\r\n};\r\n\r\nconst resolveIndPag = (raw) => {\r\n  const digits = onlyDigits(raw);\r\n  return digits === '0' || digits === '1' || digits === '2' ? digits : '';\r\n};\r\n\r\nconst CARD_PAYMENT_CODES = new Set(['03', '04']);\r\n\r\nconst resolveStoreUf = (store = {}) => {\r\n  const ufSource = store.uf || store.estado || store.state || '';\r\n  if (ufSource) {\r\n    const normalized = String(ufSource).trim().toUpperCase();\r\n    if (normalized.length === 2) {\r\n      return normalized;\r\n    }\r\n  }\r\n\r\n  const codeCandidates = [\r\n    store.codigoUf,\r\n    store.codigoUF,\r\n    store.codigoEstado,\r\n    store.codigoUfIbge,\r\n    store.codigoIbgeUf,\r\n    store.codigoEstadoIbge,\r\n  ];\r\n\r\n  for (const candidate of codeCandidates) {\r\n    if (!candidate && candidate !== 0) continue;\r\n    const digits = sanitizeDigits(candidate, { fallback: '' });\r\n    if (!digits) continue;\r\n    const normalizedCode = digits.padStart(2, '0').slice(-2);\r\n    const resolved = UF_BY_CODE[normalizedCode];\r\n    if (resolved) {\r\n      return resolved;\r\n    }\r\n  }\r\n\r\n  return '';\r\n};\r\n\r\nconst safeNumber = (value, fallback = 0) => {\r\n  if (value === null || value === undefined || value === '') {\r\n    return fallback;\r\n  }\r\n  const normalized = Number(value);\r\n  return Number.isFinite(normalized) ? normalized : fallback;\r\n};\r\n\r\nconst toDecimal = (value, fractionDigits = 2) => {\r\n  const number = safeNumber(value, 0);\r\n  return number.toFixed(fractionDigits);\r\n};\r\n\r\nconst TAX_NT_CODES = new Set(['04', '05', '06', '07', '08', '09']);\r\nconst TAX_ALIQ_CODES = new Set(['01', '02']);\r\nconst TAX_QTDE_CODES = new Set(['03']);\r\n\r\nconst buildTaxGroup = ({ lines, tag, data = {}, baseValue = 0, quantity = 0 }) => {\r\n  const upperTag = tag.toUpperCase();\r\n  const subgroupIndent = '          ';\r\n  const valueIndent = '            ';\r\n  const baseNumber = safeNumber(baseValue, 0);\r\n  const quantityNumber = safeNumber(quantity, 0);\r\n  const aliquotNumber = safeNumber(data?.aliquota, 0);\r\n  const amountByAliquot = (baseNumber * aliquotNumber) / 100;\r\n  const quantityAmount = quantityNumber * aliquotNumber;\r\n  const cstDigitsRaw = onlyDigits(data?.cst);\r\n  const normalizedCst = cstDigitsRaw ? cstDigitsRaw.padStart(2, '0').slice(-2) : '';\r\n  const effectiveCst = normalizedCst || '99';\r\n  let summaryAmount = 0;\r\n\r\n  lines.push(`        <${upperTag}>`);\r\n\r\n  if (TAX_NT_CODES.has(effectiveCst)) {\r\n    lines.push(`${subgroupIndent}<${upperTag}NT>`);\r\n    lines.push(`${valueIndent}<CST>${effectiveCst}</CST>`);\r\n    lines.push(`${subgroupIndent}</${upperTag}NT>`);\r\n  } else if (TAX_QTDE_CODES.has(effectiveCst)) {\r\n    lines.push(`${subgroupIndent}<${upperTag}Qtde>`);\r\n    lines.push(`${valueIndent}<CST>${effectiveCst}</CST>`);\r\n    lines.push(`${valueIndent}<qBCProd>${toDecimal(quantityNumber, 4)}</qBCProd>`);\r\n    lines.push(`${valueIndent}<vAliqProd>${toDecimal(aliquotNumber, 4)}</vAliqProd>`);\r\n    lines.push(`${valueIndent}<v${upperTag}>${toDecimal(quantityAmount)}</v${upperTag}>`);\r\n    lines.push(`${subgroupIndent}</${upperTag}Qtde>`);\r\n    summaryAmount = quantityAmount;\r\n  } else if (effectiveCst === '60') {\r\n    lines.push(`${subgroupIndent}<${upperTag}ST>`);\r\n    lines.push(`${valueIndent}<CST>${effectiveCst}</CST>`);\r\n    lines.push(`${valueIndent}<vBC>${toDecimal(baseNumber)}</vBC>`);\r\n    lines.push(`${valueIndent}<p${upperTag}>${toDecimal(aliquotNumber)}</p${upperTag}>`);\r\n    lines.push(`${valueIndent}<v${upperTag}>${toDecimal(amountByAliquot)}</v${upperTag}>`);\r\n    lines.push(`${subgroupIndent}</${upperTag}ST>`);\r\n    summaryAmount = amountByAliquot;\r\n  } else {\r\n    const groupTag = TAX_ALIQ_CODES.has(effectiveCst) ? `${upperTag}Aliq` : `${upperTag}Outr`;\r\n    lines.push(`${subgroupIndent}<${groupTag}>`);\r\n    lines.push(`${valueIndent}<CST>${effectiveCst}</CST>`);\r\n    lines.push(`${valueIndent}<vBC>${toDecimal(baseNumber)}</vBC>`);\r\n    lines.push(`${valueIndent}<p${upperTag}>${toDecimal(aliquotNumber)}</p${upperTag}>`);\r\n    lines.push(`${valueIndent}<v${upperTag}>${toDecimal(amountByAliquot)}</v${upperTag}>`);\r\n    lines.push(`${subgroupIndent}</${groupTag}>`);\r\n    summaryAmount = amountByAliquot;\r\n  }\r\n\r\n  lines.push(`        </${upperTag}>`);\r\n  return { amount: summaryAmount };\r\n};\r\n\r\nconst formatDateTimeWithOffset = (date) => {\r\n  if (!(date instanceof Date) || Number.isNaN(date.getTime())) {\r\n    return new Date().toISOString();\r\n  }\r\n  const year = date.getFullYear();\r\n  const month = String(date.getMonth() + 1).padStart(2, '0');\r\n  const day = String(date.getDate()).padStart(2, '0');\r\n  const hours = String(date.getHours()).padStart(2, '0');\r\n  const minutes = String(date.getMinutes()).padStart(2, '0');\r\n  const seconds = String(date.getSeconds()).padStart(2, '0');\r\n  const offsetMinutes = date.getTimezoneOffset();\r\n  const sign = offsetMinutes > 0 ? '-' : '+';\r\n  const abs = Math.abs(offsetMinutes);\r\n  const offsetHours = String(Math.floor(abs / 60)).padStart(2, '0');\r\n  const offsetMins = String(abs % 60).padStart(2, '0');\r\n  return `${year}-${month}-${day}T${hours}:${minutes}:${seconds}${sign}${offsetHours}:${offsetMins}`;\r\n};\r\n\r\n// Gera o QR Code v2 on-line exigido pela SEFAZ/RJ para NFC-e autorizada em emissão normal.\r\nconst buildQrCodeRJ = ({ chNFe, tpAmb, idToken, csc }) => {\r\n  const versaoQR = '2';\r\n  const qrCodeBase = 'https://consultadfe.fazenda.rj.gov.br/consultaNFCe/QRCode';\r\n  const urlChaveBase = 'www.fazenda.rj.gov.br/nfce/consulta';\r\n\r\n  // NORMALIZAÇÃO CRÍTICA: remover zeros à esquerda\r\n  const rawId = onlyDigits(idToken);\r\n  const idT = String(Number(rawId)); // \"000003\" -> \"3\"\r\n  if (!idT || idT === '0') {\r\n    throw new Error('Identificador do CSC (cIdToken) inválido para NFC-e do RJ.');\r\n  }\r\n\r\n  const pSemHash = `${chNFe}|${versaoQR}|${tpAmb}|${idT}`;\r\n  const token = String(csc ?? '');\r\n  const hashInput = `${pSemHash}${token}`;\r\n  const cHash = crypto.createHash('sha1').update(hashInput, 'utf8').digest('hex').toUpperCase();\r\n  const qrCodeUrl = `${qrCodeBase}?p=${pSemHash}|${cHash}`;\r\n  return { qrCodeUrl, urlChaveBase };\r\n};\r\n\r\nconst buildCnf = (sale) => {\r\n  const base =\r\n    sale?.saleCode ||\r\n    sale?.receiptSnapshot?.meta?.saleCode ||\r\n    sale?.id ||\r\n    `${Date.now()}-${Math.random()}`;\r\n  const hash = crypto.createHash('sha256').update(String(base)).digest('hex');\r\n  const numeric = BigInt(`0x${hash.slice(-12)}`);\r\n  const cnfNumber = Number(numeric % BigInt(100000000));\r\n  return String(cnfNumber).padStart(8, '0');\r\n};\r\n\r\nconst modulo11 = (value) => {\r\n  const reversed = String(value).split('').reverse();\r\n  let weight = 2;\r\n  let total = 0;\r\n  for (const char of reversed) {\r\n    total += Number(char) * weight;\r\n    weight += 1;\r\n    if (weight > 9) weight = 2;\r\n  }\r\n  const remainder = total % 11;\r\n  const dv = remainder === 0 || remainder === 1 ? 0 : 11 - remainder;\r\n  return dv;\r\n};\r\n\r\nconst buildAccessKey = ({\r\n  ufCode,\r\n  emissionDate,\r\n  cnpj,\r\n  model,\r\n  serie,\r\n  numero,\r\n  emissionType,\r\n  cnf,\r\n}) => {\r\n  const yy = String(emissionDate.getFullYear()).slice(-2);\r\n  const mm = String(emissionDate.getMonth() + 1).padStart(2, '0');\r\n  const datePart = `${yy}${mm}`;\r\n  const normalizedSerie = String(serie).padStart(3, '0');\r\n  const normalizedNumero = String(numero).padStart(9, '0');\r\n  const body = `${String(ufCode).padStart(2, '0')}${datePart}${String(cnpj).padStart(14, '0')}${String(model).padStart(\r\n    2,\r\n    '0'\r\n  )}${normalizedSerie}${normalizedNumero}${String(emissionType).padStart(1, '0')}${String(cnf).padStart(8, '0')}`;\r\n  const dv = modulo11(body);\r\n  return `${body}${dv}`;\r\n};\r\n\r\nconst extractCertificatePair = (pfxBuffer, password) => {\r\n  const collectBagAttributes = (bag = {}) => {\r\n    const { attributes } = bag;\r\n    if (!attributes) {\r\n      return [];\r\n    }\r\n    if (Array.isArray(attributes)) {\r\n      return attributes.filter(Boolean);\r\n    }\r\n    if (attributes instanceof Map) {\r\n      return Array.from(attributes.values()).reduce((acc, value) => {\r\n        if (!value) {\r\n          return acc;\r\n        }\r\n        if (Array.isArray(value)) {\r\n          acc.push(...value.filter(Boolean));\r\n        } else {\r\n          acc.push(value);\r\n        }\r\n        return acc;\r\n      }, []);\r\n    }\r\n    if (typeof attributes === 'object') {\r\n      if (typeof attributes[Symbol.iterator] === 'function') {\r\n        return Array.from(attributes).filter(Boolean);\r\n      }\r\n      return Object.values(attributes).reduce((acc, value) => {\r\n        if (!value) {\r\n          return acc;\r\n        }\r\n        if (Array.isArray(value)) {\r\n          acc.push(...value.filter(Boolean));\r\n        } else {\r\n          acc.push(value);\r\n        }\r\n        return acc;\r\n      }, []);\r\n    }\r\n    if (typeof attributes === 'function') {\r\n      try {\r\n        const result = attributes();\r\n        return Array.isArray(result) ? result.filter(Boolean) : [];\r\n      } catch (error) {\r\n        return [];\r\n      }\r\n    }\r\n    if (attributes && typeof attributes[Symbol.iterator] === 'function') {\r\n      return Array.from(attributes).filter(Boolean);\r\n    }\r\n    return [];\r\n  };\r\n\r\n  const decodeLocalKeyId = (bag = {}) => {\r\n    const attributes = collectBagAttributes(bag);\r\n    if (!attributes || typeof attributes[Symbol.iterator] !== 'function') {\r\n      return null;\r\n    }\r\n\r\n    let attribute = null;\r\n    for (const candidate of attributes) {\r\n      if (candidate && candidate.type === forge.pki.oids.localKeyId) {\r\n        attribute = candidate;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (!attribute || !attribute.value || !attribute.value.length) {\r\n      return null;\r\n    }\r\n    const raw = attribute.value[0];\r\n    if (!raw) {\r\n      return null;\r\n    }\r\n    if (typeof raw === 'string') {\r\n      return Buffer.from(raw, 'binary').toString('hex');\r\n    }\r\n    if (raw.value && typeof raw.value === 'string') {\r\n      return Buffer.from(raw.value, 'binary').toString('hex');\r\n    }\r\n    if (typeof raw.getBytes === 'function') {\r\n      return Buffer.from(raw.getBytes(), 'binary').toString('hex');\r\n    }\r\n    if (Array.isArray(raw)) {\r\n      return Buffer.from(raw).toString('hex');\r\n    }\r\n    return null;\r\n  };\r\n\r\n  const decodeFriendlyName = (bag = {}) => {\r\n    const attributes = collectBagAttributes(bag);\r\n    if (!attributes || typeof attributes[Symbol.iterator] !== 'function') {\r\n      return null;\r\n    }\r\n\r\n    let attribute = null;\r\n    for (const candidate of attributes) {\r\n      if (candidate && candidate.type === forge.pki.oids.friendlyName) {\r\n        attribute = candidate;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (!attribute || !attribute.value || !attribute.value.length) {\r\n      return null;\r\n    }\r\n    const raw = attribute.value[0];\r\n    if (!raw) {\r\n      return null;\r\n    }\r\n    if (typeof raw === 'string') {\r\n      return raw;\r\n    }\r\n    if (raw.value && typeof raw.value === 'string') {\r\n      return raw.value;\r\n    }\r\n    if (typeof raw.getBytes === 'function') {\r\n      return raw.getBytes();\r\n    }\r\n    return null;\r\n  };\r\n\r\n  const normalizePfxBuffer = (value) => {\r\n    if (!value) {\r\n      throw new Error('O arquivo do certificado digital está vazio.');\r\n    }\r\n    if (Buffer.isBuffer(value)) {\r\n      return Buffer.from(value);\r\n    }\r\n    if (ArrayBuffer.isView(value)) {\r\n      return Buffer.from(value.buffer, value.byteOffset, value.byteLength);\r\n    }\r\n    if (typeof value === 'string') {\r\n      const trimmed = value.trim();\r\n      if (!trimmed) {\r\n        throw new Error('O arquivo do certificado digital está vazio.');\r\n      }\r\n      const sanitized = trimmed.replace(/\\s+/g, '');\r\n      if (sanitized.length >= 4 && sanitized.length % 4 === 0 && /^[A-Za-z0-9+/=]+$/.test(sanitized)) {\r\n        try {\r\n          const asBase64 = Buffer.from(sanitized, 'base64');\r\n          if (\r\n            asBase64.length &&\r\n            asBase64.toString('base64').replace(/=+$/, '') === sanitized.replace(/=+$/, '')\r\n          ) {\r\n            return asBase64;\r\n          }\r\n        } catch (error) {\r\n          // Ignore and fall back to binary decoding when base64 parsing fails.\r\n        }\r\n      }\r\n      return Buffer.from(trimmed, 'binary');\r\n    }\r\n    throw new Error('Formato de certificado digital não suportado.');\r\n  };\r\n\r\n  const collectBagEntries = (p12) => {\r\n    const keys = [];\r\n    const certificates = [];\r\n\r\n    const pushKeyBag = (bag) => {\r\n      if (!bag) return;\r\n      let privateKey;\r\n      if (bag.key) {\r\n        privateKey = bag.key;\r\n      } else if (bag.asn1) {\r\n        privateKey = forge.pki.privateKeyFromAsn1(bag.asn1);\r\n      } else if (bag.rsaPrivateKey) {\r\n        privateKey = forge.pki.privateKeyFromAsn1(bag.rsaPrivateKey);\r\n      }\r\n      if (!privateKey) {\r\n        return;\r\n      }\r\n      const pem = forge.pki.privateKeyToPem(privateKey);\r\n      keys.push({\r\n        pem,\r\n        localKeyId: decodeLocalKeyId(bag),\r\n        friendlyName: decodeFriendlyName(bag),\r\n      });\r\n    };\r\n\r\n    const pushCertificateBag = (bag) => {\r\n      if (!bag) return;\r\n      const certificate = bag.cert || bag.bagValue?.cert || bag.bagValue;\r\n      if (!certificate) {\r\n        return;\r\n      }\r\n      const pem = forge.pki.certificateToPem(certificate);\r\n      certificates.push({\r\n        pem,\r\n        localKeyId: decodeLocalKeyId(bag),\r\n        friendlyName: decodeFriendlyName(bag),\r\n      });\r\n    };\r\n\r\n    const traverseSafeContents = (safeContents = []) => {\r\n      for (const content of safeContents) {\r\n        if (content.safeBags) {\r\n          for (const bag of content.safeBags) {\r\n            if (bag.type === forge.pki.oids.pkcs8ShroudedKeyBag || bag.type === forge.pki.oids.keyBag) {\r\n              pushKeyBag(bag);\r\n            } else if (bag.type === forge.pki.oids.certBag) {\r\n              pushCertificateBag(bag);\r\n            }\r\n          }\r\n        }\r\n        if (content.safeContents) {\r\n          traverseSafeContents(content.safeContents);\r\n        }\r\n      }\r\n    };\r\n\r\n    traverseSafeContents(p12.safeContents || []);\r\n\r\n    if (!keys.length) {\r\n      const bagTypes = [forge.pki.oids.pkcs8ShroudedKeyBag, forge.pki.oids.keyBag];\r\n      for (const bagType of bagTypes) {\r\n        const bags = p12.getBags({ bagType })?.[bagType] || [];\r\n        bags.forEach(pushKeyBag);\r\n      }\r\n    }\r\n\r\n    if (!certificates.length) {\r\n      const bags = p12.getBags({ bagType: forge.pki.oids.certBag })?.[forge.pki.oids.certBag] || [];\r\n      bags.forEach(pushCertificateBag);\r\n    }\r\n\r\n    return { keys, certificates };\r\n  };\r\n\r\n  const computePrivateKeyFingerprint = (pem) => {\r\n    if (!pem) return null;\r\n    try {\r\n      const privateKey = forge.pki.privateKeyFromPem(pem);\r\n      if (privateKey && privateKey.n && privateKey.e) {\r\n        return privateKey.n.toString(16);\r\n      }\r\n    } catch (error) {\r\n      // Ignore forge parsing issues and fall back to node's crypto implementation below.\r\n    }\r\n    try {\r\n      const keyObject = crypto.createPrivateKey({ key: pem, format: 'pem' });\r\n      const publicKeyDer = crypto\r\n        .createPublicKey(keyObject)\r\n        .export({ type: 'spki', format: 'der' });\r\n      return crypto.createHash('sha1').update(publicKeyDer).digest('hex');\r\n    } catch (error) {\r\n      return null;\r\n    }\r\n  };\r\n\r\n  const computeCertificateFingerprint = (pem) => {\r\n    if (!pem) return null;\r\n    try {\r\n      const certificate = forge.pki.certificateFromPem(pem);\r\n      if (certificate?.publicKey?.n && certificate.publicKey.e) {\r\n        return certificate.publicKey.n.toString(16);\r\n      }\r\n    } catch (error) {\r\n      // Ignore forge parsing issues and fall back to node's crypto implementation below.\r\n    }\r\n    try {\r\n      const x509 = new crypto.X509Certificate(pem);\r\n      const publicKeyDer = x509.publicKey.export({ type: 'spki', format: 'der' });\r\n      return crypto.createHash('sha1').update(publicKeyDer).digest('hex');\r\n    } catch (error) {\r\n      return null;\r\n    }\r\n  };\r\n\r\n  const keysMatch = (keyPem, certificatePem) => {\r\n    if (!keyPem || !certificatePem) {\r\n      return false;\r\n    }\r\n    try {\r\n      const privateKey = crypto.createPrivateKey({ key: keyPem, format: 'pem' });\r\n      const publicFromPrivate = crypto\r\n        .createPublicKey(privateKey)\r\n        .export({ type: 'spki', format: 'der' });\r\n      const certificatePublicKey = new crypto.X509Certificate(certificatePem)\r\n        .publicKey.export({ type: 'spki', format: 'der' });\r\n      return Buffer.compare(publicFromPrivate, certificatePublicKey) === 0;\r\n    } catch (error) {\r\n      return false;\r\n    }\r\n  };\r\n\r\n  const matchKeyWithCertificate = ({ keys, certificates }) => {\r\n    if (!keys.length) {\r\n      throw new Error('Não foi possível extrair a chave privada do certificado.');\r\n    }\r\n    if (!certificates.length) {\r\n      throw new Error('Não foi possível extrair o certificado digital.');\r\n    }\r\n\r\n    const enrichedKeys = keys.map((entry) => ({\r\n      ...entry,\r\n      fingerprint: computePrivateKeyFingerprint(entry.pem),\r\n    }));\r\n    const enrichedCertificates = certificates.map((entry) => ({\r\n      ...entry,\r\n      fingerprint: computeCertificateFingerprint(entry.pem),\r\n    }));\r\n\r\n    for (const keyEntry of enrichedKeys) {\r\n      const certificateEntry = enrichedCertificates.find((candidate) => {\r\n        if (keyEntry.localKeyId && candidate.localKeyId && candidate.localKeyId === keyEntry.localKeyId) {\r\n          return keysMatch(keyEntry.pem, candidate.pem);\r\n        }\r\n        if (keyEntry.friendlyName && candidate.friendlyName && candidate.friendlyName === keyEntry.friendlyName) {\r\n          return keysMatch(keyEntry.pem, candidate.pem);\r\n        }\r\n        if (keyEntry.fingerprint && candidate.fingerprint && keyEntry.fingerprint === candidate.fingerprint) {\r\n          return keysMatch(keyEntry.pem, candidate.pem);\r\n        }\r\n        return false;\r\n      });\r\n      if (certificateEntry) {\r\n        return { keyEntry, certificateEntry };\r\n      }\r\n    }\r\n\r\n    for (const keyEntry of enrichedKeys) {\r\n      if (!keyEntry.fingerprint) {\r\n        continue;\r\n      }\r\n      const certificateEntry = enrichedCertificates.find(\r\n        (candidate) =>\r\n          candidate.fingerprint &&\r\n          candidate.fingerprint === keyEntry.fingerprint &&\r\n          keysMatch(keyEntry.pem, candidate.pem)\r\n      );\r\n      if (certificateEntry) {\r\n        return { keyEntry, certificateEntry };\r\n      }\r\n    }\r\n\r\n    for (const keyEntry of enrichedKeys) {\r\n      const certificateEntry = enrichedCertificates.find((candidate) => keysMatch(keyEntry.pem, candidate.pem));\r\n      if (certificateEntry) {\r\n        return { keyEntry, certificateEntry };\r\n      }\r\n    }\r\n\r\n    throw new Error(\r\n      'O certificado digital não contém um par de chave privada e certificado compatível. Verifique o arquivo PFX.'\r\n    );\r\n  };\r\n\r\n  try {\r\n    const normalizedPassword = typeof password === 'string' ? password : String(password || '');\r\n    const buffer = normalizePfxBuffer(pfxBuffer);\r\n    const der = forge.util.createBuffer(buffer.toString('binary'), 'binary');\r\n    const asn1 = forge.asn1.fromDer(der);\r\n    const p12 = forge.pkcs12.pkcs12FromAsn1(asn1, false, normalizedPassword);\r\n\r\n    const entries = collectBagEntries(p12);\r\n    const { keyEntry, certificateEntry } = matchKeyWithCertificate(entries);\r\n\r\n    let normalizedPrivateKeyPem = keyEntry?.pem ? String(keyEntry.pem) : '';\r\n    if (!normalizedPrivateKeyPem.trim()) {\r\n      throw new Error('Não foi possível extrair a chave privada do certificado.');\r\n    }\r\n\r\n    try {\r\n      const keyObject = crypto.createPrivateKey({ key: normalizedPrivateKeyPem, format: 'pem' });\r\n      try {\r\n        normalizedPrivateKeyPem = keyObject.export({ type: 'pkcs1', format: 'pem' }).toString();\r\n      } catch (innerError) {\r\n        normalizedPrivateKeyPem = keyObject.export({ type: 'pkcs8', format: 'pem' }).toString();\r\n      }\r\n    } catch (error) {\r\n      throw new Error('A chave privada do certificado é inválida ou está protegida por senha desconhecida.');\r\n    }\r\n\r\n    const certificatePem = certificateEntry?.pem ? String(certificateEntry.pem) : '';\r\n    if (!certificatePem.trim()) {\r\n      throw new Error('Não foi possível extrair o certificado digital.');\r\n    }\r\n\r\n    try {\r\n      const signer = crypto.createSign('RSA-SHA1');\r\n      signer.update('nfce-signature-validation');\r\n      signer.end();\r\n      const signature = signer.sign(normalizedPrivateKeyPem);\r\n      const verifier = crypto.createVerify('RSA-SHA1');\r\n      verifier.update('nfce-signature-validation');\r\n      verifier.end();\r\n      if (!verifier.verify(certificatePem, signature)) {\r\n        throw new Error('A chave privada não corresponde ao certificado digital informado.');\r\n      }\r\n    } catch (error) {\r\n      if (error instanceof Error && error.message === 'A chave privada não corresponde ao certificado digital informado.') {\r\n        throw error;\r\n      }\r\n      throw new Error('Falha ao validar o par chave/certificado do arquivo PFX.');\r\n    }\r\n\r\n    if (!keysMatch(normalizedPrivateKeyPem, certificatePem)) {\r\n      throw new Error('A chave privada não corresponde ao certificado digital informado.');\r\n    }\r\n\r\n    const rawCertificates = Array.isArray(entries?.certificates)\r\n      ? entries.certificates.map((entry) => (entry?.pem ? String(entry.pem) : '')).filter(Boolean)\r\n      : [];\r\n\r\n    const certificateChain = [];\r\n    const normalizedLeaf = certificatePem;\r\n    certificateChain.push(normalizedLeaf);\r\n\r\n    for (const candidate of rawCertificates) {\r\n      if (!candidate.trim()) {\r\n        continue;\r\n      }\r\n      if (normalizedLeaf && candidate === normalizedLeaf) {\r\n        continue;\r\n      }\r\n      if (certificateChain.includes(candidate)) {\r\n        continue;\r\n      }\r\n      certificateChain.push(candidate);\r\n    }\r\n\r\n    return { privateKeyPem: normalizedPrivateKeyPem, certificatePem: normalizedLeaf, certificateChain };\r\n  } catch (error) {\r\n    if (error instanceof Error && error.message) {\r\n      if (error.message.startsWith('Falha ao processar o certificado digital da empresa')) {\r\n        throw error;\r\n      }\r\n      throw new Error(`Falha ao processar o certificado digital da empresa: ${error.message}`);\r\n    }\r\n    throw new Error('Falha ao processar o certificado digital da empresa.');\r\n  }\r\n};\r\n\r\nconst normalizeFiscalItem = (item = {}) => {\r\n  const quantity = safeNumber(item.quantity ?? item.quantidade ?? item.qtd ?? 0, 0);\r\n  const unitPrice = safeNumber(item.unitPrice ?? item.valor ?? item.preco ?? item.valorUnitario ?? 0, 0);\r\n  const total = safeNumber(item.totalPrice ?? item.subtotal ?? unitPrice * quantity, 0);\r\n  const productId = item.productId || item.id || item._id || item.productSnapshot?._id || null;\r\n  return {\r\n    productId: productId ? String(productId) : null,\r\n    quantity,\r\n    unitPrice,\r\n    total,\r\n    productSnapshot: item.productSnapshot ? { ...item.productSnapshot } : null,\r\n    name: item.name || item.nome || item.product || item.descricao || '',\r\n    barcode: item.barcode || item.codigoBarras || item.codigo || '',\r\n    internalCode: item.codigoInterno || item.internalCode || '',\r\n    unit: item.unit || item.unidade || item.productSnapshot?.unidade || 'UN',\r\n  };\r\n};\r\n\r\nconst loadProductsByIds = async (ids = []) => {\r\n  const uniqueIds = Array.from(\r\n    new Set(\r\n      ids\r\n        .map((id) => {\r\n          if (!id) return null;\r\n          if (mongoose.Types.ObjectId.isValid(id)) {\r\n            return id;\r\n          }\r\n          return null;\r\n        })\r\n        .filter(Boolean)\r\n    )\r\n  );\r\n  if (!uniqueIds.length) {\r\n    return new Map();\r\n  }\r\n  const products = await Product.find({ _id: { $in: uniqueIds } }).lean();\r\n  const map = new Map();\r\n  for (const product of products) {\r\n    map.set(String(product._id), product);\r\n  }\r\n  return map;\r\n};\r\n\r\nconst buildInfAdicObservations = ({ pdv, sale, environmentLabel }) => {\r\n  const observations = [];\r\n  if (pdv?.codigo) {\r\n    observations.push({ tag: 'PDVCodigo', value: pdv.codigo });\r\n  }\r\n  if (pdv?.nome) {\r\n    observations.push({ tag: 'PDVNome', value: pdv.nome });\r\n  }\r\n  if (sale?.saleCode) {\r\n    observations.push({ tag: 'VendaCodigo', value: sale.saleCode });\r\n  }\r\n  const operador = sale?.receiptSnapshot?.meta?.operador || sale?.receiptSnapshot?.meta?.operadorNome;\r\n  if (operador) {\r\n    observations.push({ tag: 'Operador', value: operador });\r\n  }\r\n  if (environmentLabel) {\r\n    observations.push({ tag: 'Ambiente', value: environmentLabel });\r\n  }\r\n  return observations;\r\n};\r\n\r\nconst emitPdvSaleFiscal = async ({ sale, pdv, store, emissionDate, environment, serie, numero }) => {\r\n  if (!sale || typeof sale !== 'object') {\r\n    throw new Error('Venda inválida para emissão fiscal.');\r\n  }\r\n  const snapshot = sale.receiptSnapshot || {};\r\n  const saleCodeForFile = normalizeStringSafe(sale?.saleCode) || normalizeStringSafe(sale?.id);\r\n  let xmlFileBaseName = saleCodeForFile ? `NFCe-${saleCodeForFile}` : '';\r\n  const fiscalItemsRaw = Array.isArray(sale.fiscalItemsSnapshot)\r\n    ? sale.fiscalItemsSnapshot\r\n    : Array.isArray(sale.itemsSnapshot)\r\n    ? sale.itemsSnapshot\r\n    : [];\r\n  const fiscalItems = fiscalItemsRaw.map((item) => normalizeFiscalItem(item));\r\n  if (!fiscalItems.length) {\r\n    throw new Error('Itens da venda não estão disponíveis para emissão fiscal.');\r\n  }\r\n\r\n  const productsMap = await loadProductsByIds(fiscalItems.map((item) => item.productId));\r\n  const storeObject = store && typeof store.toObject === 'function' ? store.toObject() : store || {};\r\n  const storeUf = resolveStoreUf(storeObject);\r\n  if (!storeUf) {\r\n    throw new Error('UF da empresa não está configurada para transmissão fiscal.');\r\n  }\r\n  const regime = storeObject?.regimeTributario || storeObject?.regime || '';\r\n  const missingByProduct = [];\r\n\r\n  for (const item of fiscalItems) {\r\n    const product = item.productId ? productsMap.get(String(item.productId)) : null;\r\n    if (!product) {\r\n      missingByProduct.push({\r\n        name: item.name || item.productSnapshot?.nome || 'Produto sem identificação',\r\n        issues: ['Produto não localizado na base de dados para validação fiscal.'],\r\n      });\r\n      continue;\r\n    }\r\n    const fiscalData = getFiscalDataForStore(product, storeObject);\r\n    const missing = computeMissingFields(fiscalData, { regime });\r\n    const issues = [\r\n      ...describeMissingFields(missing.comum || []),\r\n      ...describeMissingFields(missing.nfce || []),\r\n    ];\r\n    if (issues.length) {\r\n      missingByProduct.push({ name: product.nome || item.name || 'Produto', issues });\r\n    }\r\n  }\r\n\r\n  if (missingByProduct.length) {\r\n    const message = missingByProduct\r\n      .map((entry) => `• ${entry.name}: ${entry.issues.join(', ')}`)\r\n      .join('\\n');\r\n    throw new Error(`Ajuste a configuração fiscal dos itens antes da emissão:\\n${message}`);\r\n  }\r\n\r\n  const emissionRef = emissionDate instanceof Date && !Number.isNaN(emissionDate.getTime())\r\n    ? emissionDate\r\n    : new Date();\r\n\r\n  const ufCode = sanitizeDigits(storeObject?.codigoUf, { fallback: '00' }).padStart(2, '0');\r\n  const cnpj = sanitizeDigits(storeObject?.cnpj, { fallback: '00000000000000' }).padStart(14, '0');\r\n  const resolvedSerie = serie ?? storeObject?.serieFiscal ?? 1;\r\n  const serieNumber = Number.parseInt(resolvedSerie, 10);\r\n  if (!Number.isInteger(serieNumber) || serieNumber <= 0 || serieNumber > 999) {\r\n    throw new Error('Série fiscal inválida. Informe um valor inteiro entre 1 e 999.');\r\n  }\r\n  const serieFiscal = String(serieNumber).padStart(3, '0');\r\n  const numeroFiscal = Number(numero);\r\n  const cnf = buildCnf(sale);\r\n  const tpAmb = environment === 'producao' ? '1' : '2';\r\n  const accessKey = buildAccessKey({\r\n    ufCode,\r\n    emissionDate: emissionRef,\r\n    cnpj,\r\n    model: '65',\r\n    serie: serieFiscal,\r\n    numero: numeroFiscal,\r\n    emissionType: '1',\r\n    cnf,\r\n  });\r\n  if (!xmlFileBaseName) {\r\n    xmlFileBaseName = `NFCe-${accessKey}`;\r\n  }\r\n\r\n  const totalProducts = fiscalItems.reduce((sum, item) => sum + item.total, 0);\r\n  const desconto = safeNumber(snapshot?.totais?.descontoValor ?? snapshot?.totais?.desconto ?? sale.discountValue ?? 0, 0);\r\n  const acrescimo = safeNumber(snapshot?.totais?.acrescimoValor ?? snapshot?.totais?.acrescimo ?? sale.additionValue ?? 0, 0);\r\n  const totalLiquido = Math.max(0, totalProducts - desconto + acrescimo);\r\n  const pagamentosRaw = Array.isArray(snapshot?.pagamentos?.items) ? snapshot.pagamentos.items : [];\r\n  const pagamentos = pagamentosRaw.length\r\n    ? pagamentosRaw.map((payment) => ({\r\n        descricao: payment?.descricao || payment?.label || payment?.nome || 'Pagamento',\r\n        valor: safeNumber(payment?.valor ?? payment?.formatted ?? 0, 0),\r\n        forma: payment?.forma || payment?.codigo || payment?.tipo || '01',\r\n        indPag: payment?.indPag ?? payment?.indicador ?? payment?.indicadorPagamento,\r\n        integracao: payment?.tpIntegra ?? payment?.integracao ?? payment?.tipoIntegracao,\r\n        card: payment?.card || payment?.cartao || null,\r\n        cnpj: payment?.cnpjCredenciadora || payment?.cnpj || null,\r\n        tBand: payment?.tBand || payment?.bandeira || null,\r\n        cAut: payment?.cAut || payment?.autorizacao || null,\r\n      }))\r\n    : [\r\n        {\r\n          descricao: 'Dinheiro',\r\n          valor: totalLiquido,\r\n          forma: '01',\r\n        },\r\n      ];\r\n  const troco = safeNumber(snapshot?.totais?.trocoValor ?? snapshot?.totais?.troco ?? 0, 0);\r\n\r\n  const delivery = snapshot?.delivery || null;\r\n  const cliente = snapshot?.cliente || null;\r\n\r\n  const encryptedCertificate = storeObject?.certificadoArquivoCriptografado;\r\n  if (!encryptedCertificate) {\r\n    throw new Error('O certificado digital da empresa não está configurado.');\r\n  }\r\n\r\n  const encryptedCertificatePassword = storeObject?.certificadoSenhaCriptografada;\r\n  if (!encryptedCertificatePassword) {\r\n    throw new Error('A senha do certificado digital não está configurada.');\r\n  }\r\n\r\n  let certificateBuffer;\r\n  try {\r\n    certificateBuffer = decryptBuffer(encryptedCertificate);\r\n  } catch (error) {\r\n    throw new Error(`Não foi possível descriptografar o certificado digital: ${error.message}`);\r\n  }\r\n\r\n  let certificatePassword;\r\n  try {\r\n    certificatePassword = decryptText(encryptedCertificatePassword);\r\n  } catch (error) {\r\n    throw new Error(`Não foi possível recuperar a senha do certificado digital: ${error.message}`);\r\n  }\r\n  if (!certificatePassword) {\r\n    throw new Error('A senha do certificado digital descriptografada está vazia.');\r\n  }\r\n  const { privateKeyPem, certificatePem, certificateChain } = extractCertificatePair(\r\n    certificateBuffer,\r\n    certificatePassword\r\n  );\r\n\r\n  const certificateInfo = describeCertificate(certificatePem);\r\n  const storeCnpjDigits = sanitizeDigits(storeObject?.cnpj, { fallback: '' });\r\n  if (certificateInfo?.cnpj && storeCnpjDigits && certificateInfo.cnpj !== storeCnpjDigits) {\r\n    throw new Error(\r\n      `O certificado digital pertence ao CNPJ ${certificateInfo.cnpj}, diferente do CNPJ configurado (${storeCnpjDigits}).`\r\n    );\r\n  }\r\n\r\n  if (certificateInfo?.validTo instanceof Date && Number.isFinite(certificateInfo.validTo.getTime())) {\r\n    if (certificateInfo.validTo < new Date()) {\r\n      throw new Error('O certificado digital configurado está vencido e não pode ser utilizado.');\r\n    }\r\n  }\r\n\r\n  const cscIdRaw = environment === 'producao' ? storeObject.cscIdProducao : storeObject.cscIdHomologacao;\r\n  const cscId = String(cscIdRaw ?? '').trim();\r\n  const cscTokenEncrypted =\r\n    environment === 'producao'\r\n      ? storeObject.cscTokenProducaoCriptografado\r\n      : storeObject.cscTokenHomologacaoCriptografado;\r\n  if (!cscId || !cscTokenEncrypted) {\r\n    throw new Error('O CSC do ambiente selecionado não está configurado para a empresa.');\r\n  }\r\n  let cscToken;\r\n  try {\r\n    cscToken = decryptText(cscTokenEncrypted).trim();\r\n  } catch (error) {\r\n    throw new Error(`Não foi possível recuperar o CSC do ambiente selecionado: ${error.message}`);\r\n  }\r\n  if (!cscToken) {\r\n    throw new Error('O CSC configurado para a empresa está vazio após a descriptografia.');\r\n  }\r\n\r\n  const environmentLabel = environment === 'producao' ? 'Produção' : 'Homologação';\r\n\r\n  const emLgr = sanitize(storeObject?.logradouro || storeObject?.endereco);\r\n  const emNro = onlyDigits(storeObject?.numero);\r\n  const emCompl = sanitize(storeObject?.complemento);\r\n  const emBairro = sanitize(storeObject?.bairro);\r\n  const emCMun = onlyDigits(\r\n    storeObject?.cMun || storeObject?.codigoMunicipio || storeObject?.codigoIbgeMunicipio || ''\r\n  );\r\n  const emXMun = sanitize(storeObject?.xMun || storeObject?.municipio);\r\n  const emUF = sanitize(storeObject?.uf || storeObject?.UF || '').toUpperCase();\r\n  const emCEP = onlyDigits(storeObject?.cep);\r\n\r\n  if (!emLgr) throw new Error('Endereço do emitente inválido: xLgr é obrigatório.');\r\n  if (!emNro) throw new Error('Endereço do emitente inválido: nro é obrigatório (apenas dígitos).');\r\n  if (!emBairro) throw new Error('Endereço do emitente inválido: xBairro é obrigatório.');\r\n  if (!/^\\d{7}$/.test(emCMun)) {\r\n    throw new Error('Endereço do emitente inválido: cMun deve ter 7 dígitos IBGE.');\r\n  }\r\n  if (!emXMun) throw new Error('Endereço do emitente inválido: xMun é obrigatório.');\r\n  if (!/^[A-Z]{2}$/.test(emUF)) throw new Error('Endereço do emitente inválido: UF inválida.');\r\n  if (!/^\\d{8}$/.test(emCEP)) {\r\n    throw new Error('Endereço do emitente inválido: CEP deve ter 8 dígitos.');\r\n  }\r\n\r\n  const emissionIso = formatDateTimeWithOffset(emissionRef);\r\n\r\n  const infNfeLines = [];\r\n  infNfeLines.push(`  <infNFe Id=\"NFe${accessKey}\" versao=\"4.00\">`);\r\n  infNfeLines.push('    <ide>');\r\n  infNfeLines.push(`      <cUF>${ufCode}</cUF>`);\r\n  infNfeLines.push(`      <cNF>${cnf}</cNF>`);\r\n  const naturezaOperacao = sanitize(snapshot?.meta?.naturezaOperacao) || 'VENDA AO CONSUMIDOR';\r\n  infNfeLines.push(`      <natOp>${naturezaOperacao}</natOp>`);\r\n  infNfeLines.push('      <mod>65</mod>');\r\n  infNfeLines.push(`      <serie>${serieNumber}</serie>`);\r\n  infNfeLines.push(`      <nNF>${String(numeroFiscal)}</nNF>`);\r\n  infNfeLines.push(`      <dhEmi>${emissionIso}</dhEmi>`);\r\n  infNfeLines.push(`      <tpNF>1</tpNF>`);\r\n  infNfeLines.push('      <idDest>1</idDest>');\r\n  infNfeLines.push(`      <cMunFG>${emCMun}</cMunFG>`);\r\n  infNfeLines.push(`      <tpImp>4</tpImp>`);\r\n  infNfeLines.push(`      <tpEmis>1</tpEmis>`);\r\n  infNfeLines.push(`      <cDV>${accessKey.slice(-1)}</cDV>`);\r\n  infNfeLines.push(`      <tpAmb>${tpAmb}</tpAmb>`);\r\n  infNfeLines.push('      <finNFe>1</finNFe>');\r\n  infNfeLines.push('      <indFinal>1</indFinal>');\r\n  infNfeLines.push('      <indPres>1</indPres>');\r\n  infNfeLines.push('      <procEmi>0</procEmi>');\r\n  const verProcSource = snapshot?.meta?.versaoProcesso || snapshot?.meta?.verProc || '1.0';\r\n  let verProcValue = sanitize(verProcSource);\r\n  if (!verProcValue) {\r\n    verProcValue = '1.0';\r\n  }\r\n  infNfeLines.push(`      <verProc>${verProcValue}</verProc>`);\r\n  infNfeLines.push('    </ide>');\r\n  infNfeLines.push('    <emit>');\r\n  infNfeLines.push(`      <CNPJ>${cnpj}</CNPJ>`);\r\n  infNfeLines.push(`      <xNome>${sanitize(storeObject?.razaoSocial || storeObject?.nome || '')}</xNome>`);\r\n  infNfeLines.push(`      <xFant>${sanitize(storeObject?.nomeFantasia || storeObject?.razaoSocial || '')}</xFant>`);\r\n  infNfeLines.push('      <enderEmit>');\r\n  infNfeLines.push(`        <xLgr>${emLgr}</xLgr>`);\r\n  infNfeLines.push(`        <nro>${emNro}</nro>`);\r\n  // Complemento opcional não deve aparecer vazio para o Schema 4.00\r\n  pushTagIf(infNfeLines, 'xCpl', emCompl);\r\n  infNfeLines.push(`        <xBairro>${emBairro}</xBairro>`);\r\n  infNfeLines.push(`        <cMun>${emCMun}</cMun>`);\r\n  infNfeLines.push(`        <xMun>${emXMun}</xMun>`);\r\n  infNfeLines.push(`        <UF>${emUF}</UF>`);\r\n  infNfeLines.push(`        <CEP>${emCEP}</CEP>`);\r\n  infNfeLines.push('        <cPais>1058</cPais>');\r\n  infNfeLines.push('        <xPais>Brasil</xPais>');\r\n  infNfeLines.push('      </enderEmit>');\r\n  infNfeLines.push(`      <IE>${sanitizeDigits(storeObject?.inscricaoEstadual, { fallback: '' })}</IE>`);\r\n  infNfeLines.push('      <CRT>1</CRT>');\r\n  infNfeLines.push('    </emit>');\r\n\r\n  const destCPF = onlyDigits(cliente?.cpf || delivery?.cpf);\r\n  const destCNPJ = onlyDigits(cliente?.cnpj);\r\n  const destIdE = sanitize(cliente?.idEstrangeiro);\r\n\r\n  const hasCPF = /^\\d{11}$/.test(destCPF);\r\n  const hasCNPJ = /^\\d{14}$/.test(destCNPJ);\r\n  const hasIdE = !!destIdE;\r\n\r\n  const xNome = sanitize(cliente?.nome || cliente?.razaoSocial || delivery?.nome || '');\r\n  const xNome60 = (xNome || 'CONSUMIDOR').slice(0, 60);\r\n\r\n  if (hasCPF || hasCNPJ || hasIdE) {\r\n    const dLgr = sanitize(delivery?.logradouro || cliente?.logradouro);\r\n    const dNro = onlyDigits(delivery?.numero ?? cliente?.numero);\r\n    const dCompl = sanitize(delivery?.complemento || cliente?.complemento);\r\n    const dBairro = sanitize(delivery?.bairro || cliente?.bairro);\r\n    const dCMun = onlyDigits(\r\n      delivery?.cMun ??\r\n        delivery?.codigoIbgeMunicipio ??\r\n        cliente?.cMun ??\r\n        cliente?.codigoIbgeMunicipio\r\n    );\r\n    const dXMun = sanitize(\r\n      delivery?.xMun ?? delivery?.cidade ?? cliente?.xMun ?? cliente?.cidade\r\n    );\r\n    const dUF = sanitize(\r\n      (delivery?.UF ?? delivery?.uf ?? cliente?.UF ?? cliente?.uf) || ''\r\n    ).toUpperCase();\r\n    const dCEP = onlyDigits(delivery?.CEP ?? delivery?.cep ?? cliente?.CEP ?? cliente?.cep);\r\n\r\n    const hasAddr = dLgr || dNro || dCompl || dBairro || dCMun || dXMun || dUF || dCEP;\r\n\r\n    infNfeLines.push('    <dest>');\r\n    if (hasCNPJ) infNfeLines.push(`      <CNPJ>${destCNPJ}</CNPJ>`);\r\n    else if (hasCPF) infNfeLines.push(`      <CPF>${destCPF}</CPF>`);\r\n    else infNfeLines.push(`      <idEstrangeiro>${destIdE}</idEstrangeiro>`);\r\n\r\n    if (xNome60) infNfeLines.push(`      <xNome>${xNome60}</xNome>`);\r\n\r\n    if (hasAddr) {\r\n      infNfeLines.push('      <enderDest>');\r\n      pushTagIf(infNfeLines, 'xLgr', dLgr, '        ');\r\n      infNfeLines.push(`        <nro>${dNro || '0'}</nro>`);\r\n      pushTagIf(infNfeLines, 'xCpl', dCompl, '        ');\r\n      pushTagIf(infNfeLines, 'xBairro', dBairro, '        ');\r\n      if (dCMun) infNfeLines.push(`        <cMun>${dCMun}</cMun>`);\r\n      pushTagIf(infNfeLines, 'xMun', dXMun, '        ');\r\n      if (/^[A-Z]{2}$/.test(dUF)) infNfeLines.push(`        <UF>${dUF}</UF>`);\r\n      if (/^\\d{8}$/.test(dCEP)) infNfeLines.push(`        <CEP>${dCEP}</CEP>`);\r\n      infNfeLines.push('      </enderDest>');\r\n    }\r\n\r\n    infNfeLines.push('      <indIEDest>9</indIEDest>');\r\n    if (cliente?.email) {\r\n      infNfeLines.push(`      <email>${sanitize(cliente.email)}</email>`);\r\n    }\r\n    infNfeLines.push('    </dest>');\r\n  }\r\n\r\n  let totalPis = 0;\r\n  let totalCofins = 0;\r\n\r\n  const isHomologation = tpAmb === '2';\r\n\r\n  fiscalItems.forEach((item, index) => {\r\n    const product = item.productId ? productsMap.get(String(item.productId)) : null;\r\n    const fiscalData = product ? getFiscalDataForStore(product, storeObject) : {};\r\n    const cfop =\r\n      fiscalData?.cfop?.nfce?.dentroEstado ||\r\n      fiscalData?.cfop?.nfce?.foraEstado ||\r\n      fiscalData?.cfop?.nfe?.dentroEstado ||\r\n      '5102';\r\n    const ncm = sanitizeDigits(product?.ncm || item.productSnapshot?.ncm, { fallback: '00000000' });\r\n    const cEAN = sanitizeDigits(item.barcode, { fallback: 'SEM GTIN' });\r\n    const cEANTrib = cEAN === 'SEM GTIN' ? 'SEM GTIN' : cEAN;\r\n    const orig = fiscalData?.origem || '0';\r\n    const csosn = fiscalData?.csosn || '';\r\n    const cst = fiscalData?.cst || '';\r\n    infNfeLines.push(`    <det nItem=\"${index + 1}\">`);\r\n    infNfeLines.push('      <prod>');\r\n    const productCode = item.internalCode || item.productId || String(index + 1).padStart(4, '0');\r\n    infNfeLines.push(`        <cProd>${sanitize(productCode)}</cProd>`);\r\n    infNfeLines.push(`        <cEAN>${cEAN}</cEAN>`);\r\n    const productDescription =\r\n      index === 0 && isHomologation\r\n        ? HOMOLOGATION_FIRST_ITEM_DESCRIPTION\r\n        : item.name;\r\n    infNfeLines.push(`        <xProd>${sanitize(productDescription)}</xProd>`);\r\n    infNfeLines.push(`        <NCM>${ncm.padStart(8, '0')}</NCM>`);\r\n    if (fiscalData?.cest) {\r\n      infNfeLines.push(`        <CEST>${fiscalData.cest}</CEST>`);\r\n    }\r\n    infNfeLines.push(`        <CFOP>${cfop}</CFOP>`);\r\n    infNfeLines.push(`        <uCom>${sanitize(item.unit)}</uCom>`);\r\n    infNfeLines.push(`        <qCom>${toDecimal(item.quantity, 4)}</qCom>`);\r\n    infNfeLines.push(`        <vUnCom>${toDecimal(item.unitPrice)}</vUnCom>`);\r\n    infNfeLines.push(`        <vProd>${toDecimal(item.total)}</vProd>`);\r\n    infNfeLines.push(`        <cEANTrib>${cEANTrib}</cEANTrib>`);\r\n    infNfeLines.push(`        <uTrib>${sanitize(item.unit)}</uTrib>`);\r\n    infNfeLines.push(`        <qTrib>${toDecimal(item.quantity, 4)}</qTrib>`);\r\n    infNfeLines.push(`        <vUnTrib>${toDecimal(item.unitPrice)}</vUnTrib>`);\r\n    infNfeLines.push('        <indTot>1</indTot>');\r\n    infNfeLines.push('      </prod>');\r\n    infNfeLines.push('      <imposto>');\r\n    infNfeLines.push('        <ICMS>');\r\n    if (csosn) {\r\n      infNfeLines.push('          <ICMSSN102>');\r\n      infNfeLines.push(`            <orig>${orig}</orig>`);\r\n      infNfeLines.push(`            <CSOSN>${csosn}</CSOSN>`);\r\n      infNfeLines.push('          </ICMSSN102>');\r\n    } else {\r\n      infNfeLines.push('          <ICMS00>');\r\n      infNfeLines.push(`            <orig>${orig}</orig>`);\r\n      infNfeLines.push(`            <CST>${cst || '00'}</CST>`);\r\n      infNfeLines.push('            <modBC>3</modBC>');\r\n      infNfeLines.push(`            <vBC>${toDecimal(item.total)}</vBC>`);\r\n      infNfeLines.push('            <pICMS>0.00</pICMS>');\r\n      infNfeLines.push('            <vICMS>0.00</vICMS>');\r\n      infNfeLines.push('          </ICMS00>');\r\n    }\r\n    infNfeLines.push('        </ICMS>');\r\n    const pisSummary = buildTaxGroup({\r\n      lines: infNfeLines,\r\n      tag: 'PIS',\r\n      data: fiscalData?.pis,\r\n      baseValue: item.total,\r\n      quantity: item.quantity,\r\n    });\r\n    totalPis += pisSummary.amount || 0;\r\n    const cofinsSummary = buildTaxGroup({\r\n      lines: infNfeLines,\r\n      tag: 'COFINS',\r\n      data: fiscalData?.cofins,\r\n      baseValue: item.total,\r\n      quantity: item.quantity,\r\n    });\r\n    totalCofins += cofinsSummary.amount || 0;\r\n    infNfeLines.push('      </imposto>');\r\n    infNfeLines.push('    </det>');\r\n  });\r\n\r\n  infNfeLines.push('    <total>');\r\n  infNfeLines.push('      <ICMSTot>');\r\n  infNfeLines.push('        <vBC>0.00</vBC>');\r\n  infNfeLines.push('        <vICMS>0.00</vICMS>');\r\n  infNfeLines.push('        <vICMSDeson>0.00</vICMSDeson>');\r\n  infNfeLines.push('        <vFCPUFDest>0.00</vFCPUFDest>');\r\n  infNfeLines.push('        <vICMSUFDest>0.00</vICMSUFDest>');\r\n  infNfeLines.push('        <vICMSUFRemet>0.00</vICMSUFRemet>');\r\n  infNfeLines.push('        <vFCP>0.00</vFCP>');\r\n  infNfeLines.push(`        <vBCST>0.00</vBCST>`);\r\n  infNfeLines.push('        <vST>0.00</vST>');\r\n  infNfeLines.push('        <vFCPST>0.00</vFCPST>');\r\n  infNfeLines.push('        <vFCPSTRet>0.00</vFCPSTRet>');\r\n  infNfeLines.push(`        <vProd>${toDecimal(totalProducts)}</vProd>`);\r\n  infNfeLines.push(`        <vFrete>0.00</vFrete>`);\r\n  infNfeLines.push(`        <vSeg>0.00</vSeg>`);\r\n  infNfeLines.push(`        <vDesc>${toDecimal(desconto)}</vDesc>`);\r\n  infNfeLines.push(`        <vII>0.00</vII>`);\r\n  infNfeLines.push(`        <vIPI>0.00</vIPI>`);\r\n  infNfeLines.push(`        <vIPIDevol>0.00</vIPIDevol>`);\r\n  infNfeLines.push(`        <vPIS>${toDecimal(totalPis)}</vPIS>`);\r\n  infNfeLines.push(`        <vCOFINS>${toDecimal(totalCofins)}</vCOFINS>`);\r\n  infNfeLines.push(`        <vOutro>${toDecimal(acrescimo)}</vOutro>`);\r\n  infNfeLines.push(`        <vNF>${toDecimal(totalLiquido)}</vNF>`);\r\n  infNfeLines.push('      </ICMSTot>');\r\n  infNfeLines.push('    </total>');\r\n  infNfeLines.push('    <transp>');\r\n  infNfeLines.push('      <modFrete>9</modFrete>');\r\n  infNfeLines.push('    </transp>');\r\n\r\n  const paymentDetails = pagamentos.map((payment) => {\r\n    const valor = safeNumber(payment.valor, 0);\r\n    const tPag = resolvePaymentCode(payment.forma);\r\n    const indPag = resolveIndPag(payment.indPag);\r\n    let card = null;\r\n\r\n    if (CARD_PAYMENT_CODES.has(tPag)) {\r\n      const cardSource = payment.card || {};\r\n      const integraRaw = payment.integracao ?? cardSource.tpIntegra ?? cardSource.integracao;\r\n      const integraDigits = onlyDigits(integraRaw);\r\n      const tpIntegra = integraDigits === '1' ? '1' : '2';\r\n      const cnpjCred = onlyDigits(\r\n        cardSource.cnpj || cardSource.cnpjCredenciadora || payment.cnpj || payment.cnpjCredenciadora\r\n      );\r\n      const bandDigits = onlyDigits(cardSource.tBand || cardSource.bandeira || payment.tBand);\r\n      const cAutValue = sanitize(cardSource.cAut || cardSource.autorizacao || payment.cAut);\r\n      card = {\r\n        tpIntegra,\r\n        cnpj: cnpjCred.length === 14 ? cnpjCred : '',\r\n        tBand: bandDigits ? bandDigits.padStart(2, '0').slice(-2) : '',\r\n        cAut: cAutValue ? cAutValue.slice(0, 20) : '',\r\n      };\r\n    }\r\n\r\n    return { valor, tPag, indPag, card };\r\n  });\r\n\r\n  if (!paymentDetails.length) {\r\n    throw new Error('NFC-e inválida: grupo <pag> requer ao menos um <detPag>.');\r\n  }\r\n\r\n  const totalPagamentos = paymentDetails.reduce((sum, item) => sum + item.valor, 0);\r\n  const difference = Math.abs(totalPagamentos - troco - totalLiquido);\r\n  if (difference > 0.01) {\r\n    throw new Error('NFC-e inválida: soma dos pagamentos não confere com o vNF.');\r\n  }\r\n\r\n  infNfeLines.push('    <pag>');\r\n  paymentDetails.forEach((payment) => {\r\n    infNfeLines.push('      <detPag>');\r\n    if (payment.indPag) {\r\n      infNfeLines.push(`        <indPag>${payment.indPag}</indPag>`);\r\n    }\r\n    infNfeLines.push(`        <tPag>${payment.tPag}</tPag>`);\r\n    infNfeLines.push(`        <vPag>${dec(payment.valor)}</vPag>`);\r\n    if (payment.card) {\r\n      infNfeLines.push('        <card>');\r\n      infNfeLines.push(`          <tpIntegra>${payment.card.tpIntegra}</tpIntegra>`);\r\n      if (payment.card.cnpj) {\r\n        infNfeLines.push(`          <CNPJ>${payment.card.cnpj}</CNPJ>`);\r\n      }\r\n      if (payment.card.tBand) {\r\n        infNfeLines.push(`          <tBand>${payment.card.tBand}</tBand>`);\r\n      }\r\n      if (payment.card.cAut) {\r\n        infNfeLines.push(`          <cAut>${payment.card.cAut}</cAut>`);\r\n      }\r\n      infNfeLines.push('        </card>');\r\n    }\r\n    infNfeLines.push('      </detPag>');\r\n  });\r\n  if (Math.abs(troco) > 0.009) {\r\n    infNfeLines.push(`      <vTroco>${dec(troco)}</vTroco>`);\r\n  }\r\n  infNfeLines.push('    </pag>');\r\n\r\n  const obs = buildInfAdicObservations({ pdv, sale, environmentLabel });\r\n  const infAdicLines = [];\r\n  if (obs.length) {\r\n    obs.forEach((entry) => {\r\n      const campo = sanitizeXmlAttribute(entry.tag);\r\n      const texto = sanitize(entry.value);\r\n      infAdicLines.push(`      <obsCont xCampo=\"${campo}\"><xTexto>${texto}</xTexto></obsCont>`);\r\n    });\r\n  }\r\n  if (snapshot?.meta?.observacoes || snapshot?.meta?.observacaoGeral) {\r\n    infAdicLines.push(\r\n      `      <infCpl>${sanitize(snapshot.meta.observacoes || snapshot.meta.observacaoGeral)}</infCpl>`\r\n    );\r\n  }\r\n  if (infAdicLines.length) {\r\n    infNfeLines.push('    <infAdic>');\r\n    infAdicLines.forEach((line) => infNfeLines.push(line));\r\n    infNfeLines.push('    </infAdic>');\r\n  }\r\n  infNfeLines.push('  </infNFe>');\r\n\r\n  const certB64 = certificatePem\r\n    .replace('-----BEGIN CERTIFICATE-----', '')\r\n    .replace('-----END CERTIFICATE-----', '')\r\n    .replace(/\\s+/g, '');\r\n\r\n  const baseXmlLines = [\r\n    '<?xml version=\"1.0\" encoding=\"UTF-8\"?>',\r\n    '<NFe xmlns=\"http://www.portalfiscal.inf.br/nfe\">',\r\n    ...infNfeLines,\r\n    '</NFe>',\r\n  ];\r\n  const xmlForSignature = sanitizeXmlContent(baseXmlLines.join('\\n'));\r\n\r\n  const xmlDocument = new DOMParser().parseFromString(xmlForSignature, 'text/xml');\r\n  const [infNfeNode] = xpath.select(\"/*[local-name()='NFe']/*[local-name()='infNFe']\", xmlDocument);\r\n  if (!infNfeNode) {\r\n    throw new Error('Estrutura NFC-e inválida: nó <infNFe> ausente.');\r\n  }\r\n  const infId = infNfeNode.getAttribute('Id');\r\n  if (!infId) {\r\n    throw new Error('Estrutura NFC-e inválida: atributo Id ausente em <infNFe>.');\r\n  }\r\n\r\n  const keyPemString = Buffer.isBuffer(privateKeyPem)\r\n    ? privateKeyPem.toString('utf8')\r\n    : String(privateKeyPem || '');\r\n\r\n  if (!/-----BEGIN (?:RSA )?PRIVATE KEY-----/.test(keyPemString)) {\r\n    throw new Error('Chave privada inválida/ausente.');\r\n  }\r\n\r\n  const signer = new SignedXml({\r\n    privateKey: Buffer.from(keyPemString),\r\n    idAttribute: 'Id',\r\n    canonicalizationAlgorithm: 'http://www.w3.org/TR/2001/REC-xml-c14n-20010315',\r\n    signatureAlgorithm: 'http://www.w3.org/2000/09/xmldsig#rsa-sha1',\r\n    digestAlgorithm: 'http://www.w3.org/2000/09/xmldsig#sha1',\r\n  });\r\n  signer.keyInfoProvider = {\r\n    getKeyInfo: () =>\r\n      `<X509Data><X509Certificate>${certB64}</X509Certificate></X509Data>`,\r\n  };\r\n  const refXPath = \"/*[local-name()='NFe']/*[local-name()='infNFe']\";\r\n  signer.addReference({\r\n    xpath: refXPath,\r\n    transforms: [\r\n      'http://www.w3.org/2000/09/xmldsig#enveloped-signature',\r\n      'http://www.w3.org/TR/2001/REC-xml-c14n-20010315',\r\n    ],\r\n    digestAlgorithm: 'http://www.w3.org/2000/09/xmldsig#sha1',\r\n  });\r\n  console.debug('XPath ref:', refXPath);\r\n  signer.computeSignature(xmlForSignature, {\r\n    prefix: '',\r\n    location: {\r\n      reference: refXPath,\r\n      action: 'after',\r\n    },\r\n  });\r\n\r\n  let signedXmlContent = signer.getSignedXml();\r\n  let signedDocument = null;\r\n\r\n  if (process.env.NODE_ENV === 'development') {\r\n    console.debug('[NFCE] XML assinado para transmissão:', signedXmlContent);\r\n  }\r\n  const digestValue = signer.references?.[0]?.digestValue || '';\r\n  const signatureValue = signer.signatureValue || '';\r\n\r\n  let qrCodePayload = '';\r\n  let qrCodeBaseUrl = 'https://www.sefaz.br.gov.br/nfce/consulta';\r\n  if (storeUf === 'RJ') {\r\n    const { qrCodeUrl, urlChaveBase } = buildQrCodeRJ({\r\n      chNFe: accessKey,\r\n      tpAmb,\r\n      idToken: cscId,\r\n      csc: cscToken,\r\n    });\r\n    qrCodePayload = qrCodeUrl;\r\n    qrCodeBaseUrl = urlChaveBase;\r\n  } else {\r\n    const qrParams = new URLSearchParams();\r\n    qrParams.set('chNFe', accessKey);\r\n    qrParams.set('nVersao', '100');\r\n    qrParams.set('tpAmb', tpAmb);\r\n    qrParams.set('dhEmi', emissionIso);\r\n    qrParams.set('vNF', toDecimal(totalLiquido));\r\n    qrParams.set('vICMS', '0.00');\r\n    qrParams.set('digVal', digestValue);\r\n    qrParams.set('cIdToken', cscId);\r\n    const qrBase = qrParams.toString();\r\n    const cHashQRCode = crypto\r\n      .createHash('sha1')\r\n      .update(`${qrBase}${cscToken}`)\r\n      .digest('hex')\r\n      .toUpperCase();\r\n    qrCodePayload = `${qrBase}&cHashQRCode=${cHashQRCode}`;\r\n  }\r\n\r\n  if (!qrCodePayload) {\r\n    throw new Error('Falha ao gerar QR Code da NFC-e.');\r\n  }\r\n\r\n  const hasKeyInfo = /<KeyInfo\\b/.test(signedXmlContent);\r\n  if (!hasKeyInfo) {\r\n    const signatureValueClose = '</SignatureValue>';\r\n    const signatureValueIndex = signedXmlContent.indexOf(signatureValueClose);\r\n    if (signatureValueIndex === -1) {\r\n      throw new Error('Assinatura NFC-e invalida: bloco <SignatureValue> ausente.');\r\n    }\r\n    const insertPosition = signatureValueIndex + signatureValueClose.length;\r\n    const keyInfoXml =\r\n      '<KeyInfo><X509Data><X509Certificate>' +\r\n      certB64 +\r\n      '</X509Certificate></X509Data></KeyInfo>';\r\n    signedXmlContent =\r\n      signedXmlContent.slice(0, insertPosition) +\r\n      keyInfoXml +\r\n      signedXmlContent.slice(insertPosition);\r\n  }\r\n\r\n  const qrCodeText = sanitizeQrCodeContent(qrCodePayload);\r\n  const urlChaveText = sanitize(qrCodeBaseUrl);\r\n  const infNfeSuplXml = [\r\n    '  <infNFeSupl>',\r\n    '    <qrCode>' + qrCodeText + '</qrCode>',\r\n    '    <urlChave>' + urlChaveText + '</urlChave>',\r\n    '  </infNFeSupl>',\r\n  ].join('\\n');\r\n\r\n  const cleanedXmlContent = signedXmlContent.replace(\r\n    /\\s*<infNFeSupl[\\s\\S]*?<\\/infNFeSupl>\\s*/g,\r\n    ''\r\n  );\r\n\r\n  const signatureMatch = /<(?:ds:)?Signature(?=\\s|>)/.exec(cleanedXmlContent);\r\n  if (signatureMatch) {\r\n    const insertIndex = signatureMatch.index;\r\n    const prefix = cleanedXmlContent.slice(0, insertIndex);\r\n    const suffix = cleanedXmlContent.slice(insertIndex);\r\n    const needsPrefixBreak = prefix.length && !prefix.endsWith('\\n');\r\n    const needsSuffixBreak = suffix.length && !suffix.startsWith('\\n');\r\n    signedXmlContent =\r\n      prefix +\r\n      (needsPrefixBreak ? '\\n' : '') +\r\n      infNfeSuplXml +\r\n      (needsSuffixBreak ? '\\n' : '') +\r\n      suffix;\r\n  } else {\r\n    const closingTag = '</NFe>';\r\n    if (cleanedXmlContent.includes(closingTag)) {\r\n      signedXmlContent = cleanedXmlContent.replace(\r\n        closingTag,\r\n        infNfeSuplXml + '\\n' + closingTag\r\n      );\r\n    } else {\r\n      signedXmlContent = cleanedXmlContent + '\\n' + infNfeSuplXml;\r\n    }\r\n  }\r\n\r\n  const xml = signedXmlContent.startsWith('<?xml')\r\n    ? signedXmlContent\r\n    : `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n${signedXmlContent}`;\r\n\r\n  const sanitizedXml = sanitizeXmlContent(xml);\r\n\r\n  let transmission = null;\r\n  try {\r\n    transmission = await transmitNfceToSefaz({\r\n      xml: sanitizedXml,\r\n      uf: storeUf,\r\n      environment,\r\n      certificate: certificatePem,\r\n      certificateChain,\r\n      privateKey: privateKeyPem,\r\n      lotId: `${cnf}${Date.now()}`,\r\n    });\r\n  } catch (error) {\r\n    const fileNameHint = xmlFileBaseName || `NFCe-${Date.now()}`;\r\n    const buildEnrichedError = (message) => {\r\n      const enriched = new Error(message);\r\n      enriched.name = 'NfceTransmissionError';\r\n      enriched.cause = error;\r\n      enriched.xmlContent = xml;\r\n      enriched.xmlAccessKey = accessKey;\r\n      enriched.xmlFileBaseName = fileNameHint;\r\n      return enriched;\r\n    };\r\n\r\n    if (error instanceof SefazTransmissionError || error?.name === 'SefazTransmissionError') {\r\n      const causeMessage = error?.details?.cause?.message || error?.cause?.message || '';\r\n      const detailedMessage = causeMessage\r\n        ? `${error.message || 'Falha ao transmitir NFC-e para a SEFAZ.'} (${causeMessage})`\r\n        : error.message || 'Falha ao transmitir NFC-e para a SEFAZ.';\r\n      throw buildEnrichedError(detailedMessage);\r\n    }\r\n\r\n    throw buildEnrichedError(\r\n      `Falha ao transmitir NFC-e para a SEFAZ: ${error?.message || 'erro desconhecido.'}`\r\n    );\r\n  }\r\n\r\n  return {\r\n    xml: sanitizedXml,\r\n    qrCodePayload,\r\n    digestValue,\r\n    signatureValue,\r\n    accessKey,\r\n    transmission,\r\n    totals: {\r\n      totalProducts,\r\n      totalLiquido,\r\n      desconto,\r\n      acrescimo,\r\n      troco,\r\n    },\r\n  };\r\n};\r\n\r\nmodule.exports = {\r\n  emitPdvSaleFiscal,\r\n};\r\n"
        }
    ]
}